/*! For license information please see index.js.LICENSE.txt */
(() => { var e = { 69: function (e) { e.exports = function () { function e(e, t) { for (var n = 0; n < t.length; n++) { var i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } function t(t, n, i) { return n && e(t.prototype, n), i && e(t, i), t } function n() { return (n = Object.assign || function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }).apply(this, arguments) } function i(e, t) { e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t } function r(e) { return (r = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e) })(e) } function s(e, t) { return (s = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e })(e, t) } function a(e, t, n) { return (a = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0 } catch (e) { return !1 } }() ? Reflect.construct : function (e, t, n) { var i = [null]; i.push.apply(i, t); var r = new (Function.bind.apply(e, i)); return n && s(r, n.prototype), r }).apply(null, arguments) } function o(e) { var t = "function" == typeof Map ? new Map : void 0; return (o = function (e) { if (null === e || -1 === Function.toString.call(e).indexOf("[native code]")) return e; if ("function" != typeof e) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== t) { if (t.has(e)) return t.get(e); t.set(e, n) } function n() { return a(e, arguments, r(this).constructor) } return n.prototype = Object.create(e.prototype, { constructor: { value: n, enumerable: !1, writable: !0, configurable: !0 } }), s(n, e) })(e) } function l(e, t) { try { var n = e() } catch (e) { return t(e) } return n && n.then ? n.then(void 0, t) : n } "undefined" != typeof Symbol && (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))), "undefined" != typeof Symbol && (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))); var c; !function (e) { e[e.off = 0] = "off", e[e.error = 1] = "error", e[e.warning = 2] = "warning", e[e.info = 3] = "info", e[e.debug = 4] = "debug" }(c || (c = {})); var u = c.off, h = function () { function e(e) { this.t = e } e.getLevel = function () { return u }, e.setLevel = function (e) { return u = c[e] }; var t = e.prototype; return t.error = function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this.i(console.error, c.error, t) }, t.warn = function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this.i(console.warn, c.warning, t) }, t.info = function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this.i(console.info, c.info, t) }, t.debug = function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this.i(console.log, c.debug, t) }, t.i = function (t, n, i) { n <= e.getLevel() && t.apply(console, ["[" + this.t + "] "].concat(i)) }, e }(), d = M, p = x, f = y, m = _, g = E, v = new RegExp(["(\\\\.)", "(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?"].join("|"), "g"); function y(e, t) { for (var n, i = [], r = 0, s = 0, a = "", o = t && t.delimiter || "/", l = t && t.whitelist || void 0, c = !1; null !== (n = v.exec(e));) { var u = n[0], h = n[1], d = n.index; if (a += e.slice(s, d), s = d + u.length, h) a += h[1], c = !0; else { var p = "", f = n[2], m = n[3], g = n[4], y = n[5]; if (!c && a.length) { var x = a.length - 1, _ = a[x]; (!l || l.indexOf(_) > -1) && (p = _, a = a.slice(0, x)) } a && (i.push(a), a = "", c = !1); var S = m || g, E = p || o; i.push({ name: f || r++, prefix: p, delimiter: E, optional: "?" === y || "*" === y, repeat: "+" === y || "*" === y, pattern: S ? b(S) : "[^" + w(E === o ? E : E + o) + "]+?" }) } } return (a || s < e.length) && i.push(a + e.substr(s)), i } function x(e, t) { return function (n, i) { var r = e.exec(n); if (!r) return !1; for (var s = r[0], a = r.index, o = {}, l = i && i.decode || decodeURIComponent, c = 1; c < r.length; c++)if (void 0 !== r[c]) { var u = t[c - 1]; o[u.name] = u.repeat ? r[c].split(u.delimiter).map((function (e) { return l(e, u) })) : l(r[c], u) } return { path: s, index: a, params: o } } } function _(e, t) { for (var n = new Array(e.length), i = 0; i < e.length; i++)"object" == typeof e[i] && (n[i] = new RegExp("^(?:" + e[i].pattern + ")$", S(t))); return function (t, i) { for (var r = "", s = i && i.encode || encodeURIComponent, a = !i || !1 !== i.validate, o = 0; o < e.length; o++) { var l = e[o]; if ("string" != typeof l) { var c, u = t ? t[l.name] : void 0; if (Array.isArray(u)) { if (!l.repeat) throw new TypeError('Expected "' + l.name + '" to not repeat, but got array'); if (0 === u.length) { if (l.optional) continue; throw new TypeError('Expected "' + l.name + '" to not be empty') } for (var h = 0; h < u.length; h++) { if (c = s(u[h], l), a && !n[o].test(c)) throw new TypeError('Expected all "' + l.name + '" to match "' + l.pattern + '"'); r += (0 === h ? l.prefix : l.delimiter) + c } } else if ("string" != typeof u && "number" != typeof u && "boolean" != typeof u) { if (!l.optional) throw new TypeError('Expected "' + l.name + '" to be ' + (l.repeat ? "an array" : "a string")) } else { if (c = s(String(u), l), a && !n[o].test(c)) throw new TypeError('Expected "' + l.name + '" to match "' + l.pattern + '", but got "' + c + '"'); r += l.prefix + c } } else r += l } return r } } function w(e) { return e.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1") } function b(e) { return e.replace(/([=!:$/()])/g, "\\$1") } function S(e) { return e && e.sensitive ? "" : "i" } function E(e, t, n) { for (var i = (n = n || {}).strict, r = !1 !== n.start, s = !1 !== n.end, a = n.delimiter || "/", o = [].concat(n.endsWith || []).map(w).concat("$").join("|"), l = r ? "^" : "", c = 0; c < e.length; c++) { var u = e[c]; if ("string" == typeof u) l += w(u); else { var h = u.repeat ? "(?:" + u.pattern + ")(?:" + w(u.delimiter) + "(?:" + u.pattern + "))*" : u.pattern; t && t.push(u), l += u.optional ? u.prefix ? "(?:" + w(u.prefix) + "(" + h + "))?" : "(" + h + ")?" : w(u.prefix) + "(" + h + ")" } } if (s) i || (l += "(?:" + w(a) + ")?"), l += "$" === o ? "$" : "(?=" + o + ")"; else { var d = e[e.length - 1], p = "string" == typeof d ? d[d.length - 1] === a : void 0 === d; i || (l += "(?:" + w(a) + "(?=" + o + "))?"), p || (l += "(?=" + w(a) + "|" + o + ")") } return new RegExp(l, S(n)) } function M(e, t, n) { return e instanceof RegExp ? function (e, t) { if (!t) return e; var n = e.source.match(/\((?!\?)/g); if (n) for (var i = 0; i < n.length; i++)t.push({ name: i, prefix: null, delimiter: null, optional: !1, repeat: !1, pattern: null }); return e }(e, t) : Array.isArray(e) ? function (e, t, n) { for (var i = [], r = 0; r < e.length; r++)i.push(M(e[r], t, n).source); return new RegExp("(?:" + i.join("|") + ")", S(n)) }(e, t, n) : function (e, t, n) { return E(y(e, n), t, n) }(e, t, n) } d.match = function (e, t) { var n = []; return x(M(e, n, t), n) }, d.regexpToFunction = p, d.parse = f, d.compile = function (e, t) { return _(y(e, t), t) }, d.tokensToFunction = m, d.tokensToRegExp = g; var T = { container: "container", history: "history", namespace: "namespace", prefix: "data-barba", prevent: "prevent", wrapper: "wrapper" }, C = new (function () { function e() { this.o = T, this.u = new DOMParser } var t = e.prototype; return t.toString = function (e) { return e.outerHTML }, t.toDocument = function (e) { return this.u.parseFromString(e, "text/html") }, t.toElement = function (e) { var t = document.createElement("div"); return t.innerHTML = e, t }, t.getHtml = function (e) { return void 0 === e && (e = document), this.toString(e.documentElement) }, t.getWrapper = function (e) { return void 0 === e && (e = document), e.querySelector("[" + this.o.prefix + '="' + this.o.wrapper + '"]') }, t.getContainer = function (e) { return void 0 === e && (e = document), e.querySelector("[" + this.o.prefix + '="' + this.o.container + '"]') }, t.removeContainer = function (e) { document.body.contains(e) && e.parentNode.removeChild(e) }, t.addContainer = function (e, t) { var n = this.getContainer(); n ? this.s(e, n) : t.appendChild(e) }, t.getNamespace = function (e) { void 0 === e && (e = document); var t = e.querySelector("[" + this.o.prefix + "-" + this.o.namespace + "]"); return t ? t.getAttribute(this.o.prefix + "-" + this.o.namespace) : null }, t.getHref = function (e) { if (e.tagName && "a" === e.tagName.toLowerCase()) { if ("string" == typeof e.href) return e.href; var t = e.getAttribute("href") || e.getAttribute("xlink:href"); if (t) return this.resolveUrl(t.baseVal || t) } return null }, t.resolveUrl = function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; var i = t.length; if (0 === i) throw new Error("resolveUrl requires at least one argument; got none."); var r = document.createElement("base"); if (r.href = arguments[0], 1 === i) return r.href; var s = document.getElementsByTagName("head")[0]; s.insertBefore(r, s.firstChild); for (var a, o = document.createElement("a"), l = 1; l < i; l++)o.href = arguments[l], r.href = a = o.href; return s.removeChild(r), a }, t.s = function (e, t) { t.parentNode.insertBefore(e, t.nextSibling) }, e }()), D = new (function () { function e() { this.h = [], this.v = -1 } var i = e.prototype; return i.init = function (e, t) { this.l = "barba"; var n = { ns: t, scroll: { x: window.scrollX, y: window.scrollY }, url: e }; this.h.push(n), this.v = 0; var i = { from: this.l, index: 0, states: [].concat(this.h) }; window.history && window.history.replaceState(i, "", e) }, i.change = function (e, t, n) { if (n && n.state) { var i = n.state, r = i.index; t = this.m(this.v - r), this.replace(i.states), this.v = r } else this.add(e, t); return t }, i.add = function (e, t) { var n = this.size, i = this.p(t), r = { ns: "tmp", scroll: { x: window.scrollX, y: window.scrollY }, url: e }; this.h.push(r), this.v = n; var s = { from: this.l, index: n, states: [].concat(this.h) }; switch (i) { case "push": window.history && window.history.pushState(s, "", e); break; case "replace": window.history && window.history.replaceState(s, "", e) } }, i.update = function (e, t) { var i = t || this.v, r = n({}, this.get(i), {}, e); this.set(i, r) }, i.remove = function (e) { e ? this.h.splice(e, 1) : this.h.pop(), this.v-- }, i.clear = function () { this.h = [], this.v = -1 }, i.replace = function (e) { this.h = e }, i.get = function (e) { return this.h[e] }, i.set = function (e, t) { return this.h[e] = t }, i.p = function (e) { var t = "push", n = e, i = T.prefix + "-" + T.history; return n.hasAttribute && n.hasAttribute(i) && (t = n.getAttribute(i)), t }, i.m = function (e) { return Math.abs(e) > 1 ? e > 0 ? "forward" : "back" : 0 === e ? "popstate" : e > 0 ? "back" : "forward" }, t(e, [{ key: "current", get: function () { return this.h[this.v] } }, { key: "state", get: function () { return this.h[this.h.length - 1] } }, { key: "previous", get: function () { return this.v < 1 ? null : this.h[this.v - 1] } }, { key: "size", get: function () { return this.h.length } }]), e }()), L = function (e, t) { try { var n = function () { if (!t.next.html) return Promise.resolve(e).then((function (e) { var n = t.next; if (e) { var i = C.toElement(e); n.namespace = C.getNamespace(i), n.container = C.getContainer(i), n.html = e, D.update({ ns: n.namespace }); var r = C.toDocument(e); document.title = r.title } })) }(); return Promise.resolve(n && n.then ? n.then((function () { })) : void 0) } catch (e) { return Promise.reject(e) } }, A = d, P = { __proto__: null, update: L, nextTick: function () { return new Promise((function (e) { window.requestAnimationFrame(e) })) }, pathToRegexp: A }, R = function () { return window.location.origin }, O = function (e) { return void 0 === e && (e = window.location.href), I(e).port }, I = function (e) { var t, n = e.match(/:\d+/); if (null === n) /^http/.test(e) && (t = 80), /^https/.test(e) && (t = 443); else { var i = n[0].substring(1); t = parseInt(i, 10) } var r, s = e.replace(R(), ""), a = {}, o = s.indexOf("#"); o >= 0 && (r = s.slice(o + 1), s = s.slice(0, o)); var l = s.indexOf("?"); return l >= 0 && (a = F(s.slice(l + 1)), s = s.slice(0, l)), { hash: r, path: s, port: t, query: a } }, F = function (e) { return e.split("&").reduce((function (e, t) { var n = t.split("="); return e[n[0]] = n[1], e }), {}) }, z = function (e) { return void 0 === e && (e = window.location.href), e.replace(/(\/#.*|\/|#.*)$/, "") }, k = { __proto__: null, getHref: function () { return window.location.href }, getOrigin: R, getPort: O, getPath: function (e) { return void 0 === e && (e = window.location.href), I(e).path }, parse: I, parseQuery: F, clean: z }; function N(e, t, n) { return void 0 === t && (t = 2e3), new Promise((function (i, r) { var s = new XMLHttpRequest; s.onreadystatechange = function () { if (s.readyState === XMLHttpRequest.DONE) if (200 === s.status) i(s.responseText); else if (s.status) { var t = { status: s.status, statusText: s.statusText }; n(e, t), r(t) } }, s.ontimeout = function () { var i = new Error("Timeout error [" + t + "]"); n(e, i), r(i) }, s.onerror = function () { var t = new Error("Fetch error"); n(e, t), r(t) }, s.open("GET", e), s.timeout = t, s.setRequestHeader("Accept", "text/html,application/xhtml+xml,application/xml"), s.setRequestHeader("x-barba", "yes"), s.send() })) } var B = function (e) { return !!e && ("object" == typeof e || "function" == typeof e) && "function" == typeof e.then }; function H(e, t) { return void 0 === t && (t = {}), function () { for (var n = arguments.length, i = new Array(n), r = 0; r < n; r++)i[r] = arguments[r]; var s = !1, a = new Promise((function (n, r) { t.async = function () { return s = !0, function (e, t) { e ? r(e) : n(t) } }; var a = e.apply(t, i); s || (B(a) ? a.then(n, r) : n(a)) })); return a } } var U = new (function (e) { function t() { var t; return (t = e.call(this) || this).logger = new h("@barba/core"), t.all = ["ready", "page", "reset", "currentAdded", "currentRemoved", "nextAdded", "nextRemoved", "beforeOnce", "once", "afterOnce", "before", "beforeLeave", "leave", "afterLeave", "beforeEnter", "enter", "afterEnter", "after"], t.registered = new Map, t.init(), t } i(t, e); var n = t.prototype; return n.init = function () { var e = this; this.registered.clear(), this.all.forEach((function (t) { e[t] || (e[t] = function (n, i) { e.registered.has(t) || e.registered.set(t, new Set), e.registered.get(t).add({ ctx: i || {}, fn: n }) }) })) }, n.do = function (e) { for (var t = this, n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++)i[r - 1] = arguments[r]; if (this.registered.has(e)) { var s = Promise.resolve(); return this.registered.get(e).forEach((function (e) { s = s.then((function () { return H(e.fn, e.ctx).apply(void 0, i) })) })), s.catch((function (n) { t.logger.debug("Hook error [" + e + "]"), t.logger.error(n) })) } return Promise.resolve() }, n.clear = function () { var e = this; this.all.forEach((function (t) { delete e[t] })), this.init() }, n.help = function () { this.logger.info("Available hooks: " + this.all.join(",")); var e = []; this.registered.forEach((function (t, n) { return e.push(n) })), this.logger.info("Registered hooks: " + e.join(",")) }, t }((function () { }))), V = function () { function e(e) { if (this.P = [], "boolean" == typeof e) this.g = e; else { var t = Array.isArray(e) ? e : [e]; this.P = t.map((function (e) { return A(e) })) } } return e.prototype.checkHref = function (e) { if ("boolean" == typeof this.g) return this.g; var t = I(e).path; return this.P.some((function (e) { return null !== e.exec(t) })) }, e }(), G = function (e) { function t(t) { var n; return (n = e.call(this, t) || this).k = new Map, n } i(t, e); var r = t.prototype; return r.set = function (e, t, n) { return this.k.set(e, { action: n, request: t }), { action: n, request: t } }, r.get = function (e) { return this.k.get(e) }, r.getRequest = function (e) { return this.k.get(e).request }, r.getAction = function (e) { return this.k.get(e).action }, r.has = function (e) { return !this.checkHref(e) && this.k.has(e) }, r.delete = function (e) { return this.k.delete(e) }, r.update = function (e, t) { var i = n({}, this.k.get(e), {}, t); return this.k.set(e, i), i }, t }(V), j = function () { return !window.history.pushState }, W = function (e) { return !e.el || !e.href }, q = function (e) { var t = e.event; return t.which > 1 || t.metaKey || t.ctrlKey || t.shiftKey || t.altKey }, $ = function (e) { var t = e.el; return t.hasAttribute("target") && "_blank" === t.target }, X = function (e) { var t = e.el; return void 0 !== t.protocol && window.location.protocol !== t.protocol || void 0 !== t.hostname && window.location.hostname !== t.hostname }, Y = function (e) { var t = e.el; return void 0 !== t.port && O() !== O(t.href) }, Z = function (e) { var t = e.el; return t.getAttribute && "string" == typeof t.getAttribute("download") }, K = function (e) { return e.el.hasAttribute(T.prefix + "-" + T.prevent) }, J = function (e) { return Boolean(e.el.closest("[" + T.prefix + "-" + T.prevent + '="all"]')) }, Q = function (e) { var t = e.href; return z(t) === z() && O(t) === O() }, ee = function (e) { function t(t) { var n; return (n = e.call(this, t) || this).suite = [], n.tests = new Map, n.init(), n } i(t, e); var n = t.prototype; return n.init = function () { this.add("pushState", j), this.add("exists", W), this.add("newTab", q), this.add("blank", $), this.add("corsDomain", X), this.add("corsPort", Y), this.add("download", Z), this.add("preventSelf", K), this.add("preventAll", J), this.add("sameUrl", Q, !1) }, n.add = function (e, t, n) { void 0 === n && (n = !0), this.tests.set(e, t), n && this.suite.push(e) }, n.run = function (e, t, n, i) { return this.tests.get(e)({ el: t, event: n, href: i }) }, n.checkLink = function (e, t, n) { var i = this; return this.suite.some((function (r) { return i.run(r, e, t, n) })) }, t }(V), te = function (e) { function t(n, i) { var r; void 0 === i && (i = "Barba error"); for (var s = arguments.length, a = new Array(s > 2 ? s - 2 : 0), o = 2; o < s; o++)a[o - 2] = arguments[o]; return (r = e.call.apply(e, [this].concat(a)) || this).error = n, r.label = i, Error.captureStackTrace && Error.captureStackTrace(function (e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e }(r), t), r.name = "BarbaError", r } return i(t, e), t }(o(Error)), ne = function () { function e(e) { void 0 === e && (e = []), this.logger = new h("@barba/core"), this.all = [], this.page = [], this.once = [], this.A = [{ name: "namespace", type: "strings" }, { name: "custom", type: "function" }], e && (this.all = this.all.concat(e)), this.update() } var t = e.prototype; return t.add = function (e, t) { "rule" === e ? this.A.splice(t.position || 0, 0, t.value) : this.all.push(t), this.update() }, t.resolve = function (e, t) { var n = this; void 0 === t && (t = {}); var i = t.once ? this.once : this.page; i = i.filter(t.self ? function (e) { return e.name && "self" === e.name } : function (e) { return !e.name || "self" !== e.name }); var r = new Map, s = i.find((function (i) { var s = !0, a = {}; return !(!t.self || "self" !== i.name) || (n.A.reverse().forEach((function (t) { s && (s = n.R(i, t, e, a), i.from && i.to && (s = n.R(i, t, e, a, "from") && n.R(i, t, e, a, "to")), i.from && !i.to && (s = n.R(i, t, e, a, "from")), !i.from && i.to && (s = n.R(i, t, e, a, "to"))) })), r.set(i, a), s) })), a = r.get(s), o = []; if (o.push(t.once ? "once" : "page"), t.self && o.push("self"), a) { var l, c = [s]; Object.keys(a).length > 0 && c.push(a), (l = this.logger).info.apply(l, ["Transition found [" + o.join(",") + "]"].concat(c)) } else this.logger.info("No transition found [" + o.join(",") + "]"); return s }, t.update = function () { var e = this; this.all = this.all.map((function (t) { return e.T(t) })).sort((function (e, t) { return e.priority - t.priority })).reverse().map((function (e) { return delete e.priority, e })), this.page = this.all.filter((function (e) { return void 0 !== e.leave || void 0 !== e.enter })), this.once = this.all.filter((function (e) { return void 0 !== e.once })) }, t.R = function (e, t, n, i, r) { var s = !0, a = !1, o = e, l = t.name, c = l, u = l, h = l, d = r ? o[r] : o, p = "to" === r ? n.next : n.current; if (r ? d && d[l] : d[l]) { switch (t.type) { case "strings": default: var f = Array.isArray(d[c]) ? d[c] : [d[c]]; p[c] && -1 !== f.indexOf(p[c]) && (a = !0), -1 === f.indexOf(p[c]) && (s = !1); break; case "object": var m = Array.isArray(d[u]) ? d[u] : [d[u]]; p[u] ? (p[u].name && -1 !== m.indexOf(p[u].name) && (a = !0), -1 === m.indexOf(p[u].name) && (s = !1)) : s = !1; break; case "function": d[h](n) ? a = !0 : s = !1 }a && (r ? (i[r] = i[r] || {}, i[r][l] = o[r][l]) : i[l] = o[l]) } return s }, t.O = function (e, t, n) { var i = 0; return (e[t] || e.from && e.from[t] || e.to && e.to[t]) && (i += Math.pow(10, n), e.from && e.from[t] && (i += 1), e.to && e.to[t] && (i += 2)), i }, t.T = function (e) { var t = this; e.priority = 0; var n = 0; return this.A.forEach((function (i, r) { n += t.O(e, i.name, r + 1) })), e.priority = n, e }, e }(), ie = function () { function e(e) { void 0 === e && (e = []), this.logger = new h("@barba/core"), this.S = !1, this.store = new ne(e) } var n = e.prototype; return n.get = function (e, t) { return this.store.resolve(e, t) }, n.doOnce = function (e) { var t = e.data, n = e.transition; try { var i = function () { r.S = !1 }, r = this, s = n || {}; r.S = !0; var a = l((function () { return Promise.resolve(r.j("beforeOnce", t, s)).then((function () { return Promise.resolve(r.once(t, s)).then((function () { return Promise.resolve(r.j("afterOnce", t, s)).then((function () { })) })) })) }), (function (e) { r.S = !1, r.logger.debug("Transition error [before/after/once]"), r.logger.error(e) })); return Promise.resolve(a && a.then ? a.then(i) : i()) } catch (e) { return Promise.reject(e) } }, n.doPage = function (e) { var t = e.data, n = e.transition, i = e.page, r = e.wrapper; try { var s = function (e) { if (a) return e; o.S = !1 }, a = !1, o = this, c = n || {}, u = !0 === c.sync || !1; o.S = !0; var h = l((function () { function e() { return Promise.resolve(o.j("before", t, c)).then((function () { function e(e) { return Promise.resolve(o.remove(t)).then((function () { return Promise.resolve(o.j("after", t, c)).then((function () { })) })) } var n = function () { if (u) return l((function () { return Promise.resolve(o.add(t, r)).then((function () { return Promise.resolve(o.j("beforeLeave", t, c)).then((function () { return Promise.resolve(o.j("beforeEnter", t, c)).then((function () { return Promise.resolve(Promise.all([o.leave(t, c), o.enter(t, c)])).then((function () { return Promise.resolve(o.j("afterLeave", t, c)).then((function () { return Promise.resolve(o.j("afterEnter", t, c)).then((function () { })) })) })) })) })) })) }), (function (e) { if (o.M(e)) throw new te(e, "Transition error [sync]") })); var e = function (e) { return l((function () { var e = function () { if (!1 !== n) return Promise.resolve(o.add(t, r)).then((function () { return Promise.resolve(o.j("beforeEnter", t, c)).then((function () { return Promise.resolve(o.enter(t, c, n)).then((function () { return Promise.resolve(o.j("afterEnter", t, c)).then((function () { })) })) })) })) }(); if (e && e.then) return e.then((function () { })) }), (function (e) { if (o.M(e)) throw new te(e, "Transition error [before/after/enter]") })) }, n = !1, s = l((function () { return Promise.resolve(o.j("beforeLeave", t, c)).then((function () { return Promise.resolve(Promise.all([o.leave(t, c), L(i, t)]).then((function (e) { return e[0] }))).then((function (e) { return n = e, Promise.resolve(o.j("afterLeave", t, c)).then((function () { })) })) })) }), (function (e) { if (o.M(e)) throw new te(e, "Transition error [before/after/leave]") })); return s && s.then ? s.then(e) : e() }(); return n && n.then ? n.then(e) : e() })) } var n = function () { if (u) return Promise.resolve(L(i, t)).then((function () { })) }(); return n && n.then ? n.then(e) : e() }), (function (e) { if (o.S = !1, e.name && "BarbaError" === e.name) throw o.logger.debug(e.label), o.logger.error(e.error), e; throw o.logger.debug("Transition error [page]"), o.logger.error(e), e })); return Promise.resolve(h && h.then ? h.then(s) : s(h)) } catch (e) { return Promise.reject(e) } }, n.once = function (e, t) { try { return Promise.resolve(U.do("once", e, t)).then((function () { return t.once ? H(t.once, t)(e) : Promise.resolve() })) } catch (e) { return Promise.reject(e) } }, n.leave = function (e, t) { try { return Promise.resolve(U.do("leave", e, t)).then((function () { return t.leave ? H(t.leave, t)(e) : Promise.resolve() })) } catch (e) { return Promise.reject(e) } }, n.enter = function (e, t, n) { try { return Promise.resolve(U.do("enter", e, t)).then((function () { return t.enter ? H(t.enter, t)(e, n) : Promise.resolve() })) } catch (e) { return Promise.reject(e) } }, n.add = function (e, t) { try { return C.addContainer(e.next.container, t), U.do("nextAdded", e), Promise.resolve() } catch (e) { return Promise.reject(e) } }, n.remove = function (e) { try { return C.removeContainer(e.current.container), U.do("currentRemoved", e), Promise.resolve() } catch (e) { return Promise.reject(e) } }, n.M = function (e) { return e.message ? !/Timeout error|Fetch error/.test(e.message) : !e.status }, n.j = function (e, t, n) { try { return Promise.resolve(U.do(e, t, n)).then((function () { return n[e] ? H(n[e], n)(t) : Promise.resolve() })) } catch (e) { return Promise.reject(e) } }, t(e, [{ key: "isRunning", get: function () { return this.S }, set: function (e) { this.S = e } }, { key: "hasOnce", get: function () { return this.store.once.length > 0 } }, { key: "hasSelf", get: function () { return this.store.all.some((function (e) { return "self" === e.name })) } }, { key: "shouldWait", get: function () { return this.store.all.some((function (e) { return e.to && !e.to.route || e.sync })) } }]), e }(), re = function () { function e(e) { var t = this; this.names = ["beforeLeave", "afterLeave", "beforeEnter", "afterEnter"], this.byNamespace = new Map, 0 !== e.length && (e.forEach((function (e) { t.byNamespace.set(e.namespace, e) })), this.names.forEach((function (e) { U[e](t.L(e)) }))) } return e.prototype.L = function (e) { var t = this; return function (n) { var i = e.match(/enter/i) ? n.next : n.current, r = t.byNamespace.get(i.namespace); return r && r[e] ? H(r[e], r)(n) : Promise.resolve() } }, e }(); Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector), Element.prototype.closest || (Element.prototype.closest = function (e) { var t = this; do { if (t.matches(e)) return t; t = t.parentElement || t.parentNode } while (null !== t && 1 === t.nodeType); return null }); var se = { container: null, html: "", namespace: "", url: { hash: "", href: "", path: "", port: null, query: {} } }; return new (function () { function e() { this.version = "2.9.7", this.schemaPage = se, this.Logger = h, this.logger = new h("@barba/core"), this.plugins = [], this.hooks = U, this.dom = C, this.helpers = P, this.history = D, this.request = N, this.url = k } var i = e.prototype; return i.use = function (e, t) { var n = this.plugins; n.indexOf(e) > -1 ? this.logger.warn("Plugin [" + e.name + "] already installed.") : "function" == typeof e.install ? (e.install(this, t), n.push(e)) : this.logger.warn("Plugin [" + e.name + '] has no "install" method.') }, i.init = function (e) { var t = void 0 === e ? {} : e, i = t.transitions, r = void 0 === i ? [] : i, s = t.views, a = void 0 === s ? [] : s, o = t.schema, l = void 0 === o ? T : o, c = t.requestError, u = t.timeout, d = void 0 === u ? 2e3 : u, p = t.cacheIgnore, f = void 0 !== p && p, m = t.prefetchIgnore, g = void 0 !== m && m, v = t.preventRunning, y = void 0 !== v && v, x = t.prevent, _ = void 0 === x ? null : x, w = t.debug, b = t.logLevel; if (h.setLevel(!0 === (void 0 !== w && w) ? "debug" : void 0 === b ? "off" : b), this.logger.info(this.version), Object.keys(l).forEach((function (e) { T[e] && (T[e] = l[e]) })), this.$ = c, this.timeout = d, this.cacheIgnore = f, this.prefetchIgnore = g, this.preventRunning = y, this._ = this.dom.getWrapper(), !this._) throw new Error("[@barba/core] No Barba wrapper found"); this._.setAttribute("aria-live", "polite"), this.q(); var S = this.data.current; if (!S.container) throw new Error("[@barba/core] No Barba container found"); if (this.cache = new G(f), this.prevent = new ee(g), this.transitions = new ie(r), this.views = new re(a), null !== _) { if ("function" != typeof _) throw new Error("[@barba/core] Prevent should be a function"); this.prevent.add("preventCustom", _) } this.history.init(S.url.href, S.namespace), this.B = this.B.bind(this), this.U = this.U.bind(this), this.D = this.D.bind(this), this.F(), this.plugins.forEach((function (e) { return e.init() })); var E = this.data; E.trigger = "barba", E.next = E.current, E.current = n({}, this.schemaPage), this.hooks.do("ready", E), this.once(E), this.q() }, i.destroy = function () { this.q(), this.H(), this.history.clear(), this.hooks.clear(), this.plugins = [] }, i.force = function (e) { window.location.assign(e) }, i.go = function (e, t, n) { var i; if (void 0 === t && (t = "barba"), this.transitions.isRunning) this.force(e); else if (!(i = "popstate" === t ? this.history.current && this.url.getPath(this.history.current.url) === this.url.getPath(e) : this.prevent.run("sameUrl", null, null, e)) || this.transitions.hasSelf) return t = this.history.change(e, t, n), n && (n.stopPropagation(), n.preventDefault()), this.page(e, t, i) }, i.once = function (e) { try { var t = this; return Promise.resolve(t.hooks.do("beforeEnter", e)).then((function () { function n() { return Promise.resolve(t.hooks.do("afterEnter", e)).then((function () { })) } var i = function () { if (t.transitions.hasOnce) { var n = t.transitions.get(e, { once: !0 }); return Promise.resolve(t.transitions.doOnce({ transition: n, data: e })).then((function () { })) } }(); return i && i.then ? i.then(n) : n() })) } catch (e) { return Promise.reject(e) } }, i.page = function (e, t, i) { try { var r = function () { var e = s.data; return Promise.resolve(s.hooks.do("page", e)).then((function () { var t = l((function () { var t = s.transitions.get(e, { once: !1, self: i }); return Promise.resolve(s.transitions.doPage({ data: e, page: a, transition: t, wrapper: s._ })).then((function () { s.q() })) }), (function () { 0 === h.getLevel() && s.force(e.current.url.href) })); if (t && t.then) return t.then((function () { })) })) }, s = this; s.data.next.url = n({ href: e }, s.url.parse(e)), s.data.trigger = t; var a = s.cache.has(e) ? s.cache.update(e, { action: "click" }).request : s.cache.set(e, s.request(e, s.timeout, s.onRequestError.bind(s, t)), "click").request, o = function () { if (s.transitions.shouldWait) return Promise.resolve(L(a, s.data)).then((function () { })) }(); return Promise.resolve(o && o.then ? o.then(r) : r()) } catch (e) { return Promise.reject(e) } }, i.onRequestError = function (e) { this.transitions.isRunning = !1; for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)n[i - 1] = arguments[i]; var r = n[0], s = n[1], a = this.cache.getAction(r); return this.cache.delete(r), !(this.$ && !1 === this.$(e, a, r, s) || ("click" === a && this.force(r), 1)) }, i.prefetch = function (e) { var t = this; this.cache.has(e) || this.cache.set(e, this.request(e, this.timeout, this.onRequestError.bind(this, "barba")).catch((function (e) { t.logger.error(e) })), "prefetch") }, i.F = function () { !0 !== this.prefetchIgnore && (document.addEventListener("mouseover", this.B), document.addEventListener("touchstart", this.B)), document.addEventListener("click", this.U), window.addEventListener("popstate", this.D) }, i.H = function () { !0 !== this.prefetchIgnore && (document.removeEventListener("mouseover", this.B), document.removeEventListener("touchstart", this.B)), document.removeEventListener("click", this.U), window.removeEventListener("popstate", this.D) }, i.B = function (e) { var t = this, n = this.I(e); if (n) { var i = this.dom.getHref(n); this.prevent.checkHref(i) || this.cache.has(i) || this.cache.set(i, this.request(i, this.timeout, this.onRequestError.bind(this, n)).catch((function (e) { t.logger.error(e) })), "enter") } }, i.U = function (e) { var t = this.I(e); if (t) return this.transitions.isRunning && this.preventRunning ? (e.preventDefault(), void e.stopPropagation()) : void this.go(this.dom.getHref(t), t, e) }, i.D = function (e) { this.go(this.url.getHref(), "popstate", e) }, i.I = function (e) { for (var t = e.target; t && !this.dom.getHref(t);)t = t.parentNode; if (t && !this.prevent.checkLink(t, e, this.dom.getHref(t))) return t }, i.q = function () { var e = this.url.getHref(), t = { container: this.dom.getContainer(), html: this.dom.getHtml(), namespace: this.dom.getNamespace(), url: n({ href: e }, this.url.parse(e)) }; this.C = { current: t, next: n({}, this.schemaPage), trigger: void 0 }, this.hooks.do("reset", this.data) }, t(e, [{ key: "data", get: function () { return this.C } }, { key: "wrapper", get: function () { return this._ } }]), e }()) }() }, 40: function (e) { var t; e.exports = ("2.1.10", t = window.requestIdleCallback || function (e) { var t = Date.now(); return setTimeout((function () { e({ didTimeout: !1, timeRemaining: function () { return Math.max(0, 50 - (Date.now() - t)) } }) }), 1) }, new (function () { function e() { this.name = "@barba/prefetch", this.version = "2.1.10", this.toPrefetch = new Set } var n = e.prototype; return n.install = function (e, t) { var n = void 0 === t ? {} : t, i = n.root, r = void 0 === i ? document.body : i, s = n.timeout, a = void 0 === s ? 2e3 : s; this.logger = new e.Logger(this.name), this.logger.info(this.version), this.barba = e, this.root = r, this.timeout = a }, n.init = function () { var e = this; this.barba.prefetchIgnore ? this.logger.warn("barba.prefetchIgnore is enabled") : this.barba.cacheIgnore ? this.logger.warn("barba.cacheIgnore is enabled") : (this.observer = new IntersectionObserver((function (t) { t.forEach((function (t) { if (t.isIntersecting) { var n = t.target, i = e.barba.dom.getHref(n); e.toPrefetch.has(i) && (e.observer.unobserve(n), e.barba.cache.has(i) ? e.barba.cache.update(i, { action: "prefetch" }) : e.barba.cache.set(i, e.barba.request(i, e.barba.timeout, e.barba.onRequestError.bind(e.barba, "barba")).catch((function (t) { e.logger.error(t) })), "prefetch")) } })) })), this.observe(), this.barba.hooks.after(this.observe, this)) }, n.observe = function () { var e = this; t((function () { e.root.querySelectorAll("a").forEach((function (t) { var n = t, i = e.barba.dom.getHref(n); e.barba.cache.has(i) || e.barba.prevent.checkHref(i) || e.barba.prevent.checkLink(n, {}, i) || (e.observer.observe(t), e.toPrefetch.add(i)) })) }), { timeout: this.timeout }) }, e }())) }, 662: () => { !function () { "use strict"; var e = "undefined" == typeof window, t = !e && "scrollBehavior" in document.documentElement.style, n = function () { return n = Object.assign || function (e) { for (var t, n = 1, i = arguments.length; n < i; n++)for (var r in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]); return e }, n.apply(this, arguments) }; function i(e, t) { var n = "function" == typeof Symbol && e[Symbol.iterator]; if (!n) return e; var i, r, s = n.call(e), a = []; try { for (; (void 0 === t || t-- > 0) && !(i = s.next()).done;)a.push(i.value) } catch (e) { r = { error: e } } finally { try { i && !i.done && (n = s.return) && n.call(s) } finally { if (r) throw r.error } } return a } function r() { return null != document.scrollingElement ? document.scrollingElement : document.documentElement } var s = new RegExp("scroll-behavior:\\s*([^;]*)"); function a(e, t) { var n = "scroll-behavior:" + t, i = e.getAttribute("style"); if (null != i && "" !== i) { var r = o(e); if (null != r) { var s = "scroll-behavior:" + r; i = (i = i.replace(s + ";", "")).replace(s, "") } e.setAttribute("style", i.endsWith(";") ? "" + i + n : ";" + i + n) } else e.setAttribute("style", n) } function o(e) { var t = e.getAttribute("style"); if (null != t && t.includes("scroll-behavior")) { var n = t.match(s); if (null != n) { var r = i(n, 2)[1]; if (null != r && "" !== r) return r } } } function l(e, t) { if (null != t && "smooth" === t.behavior) return "smooth"; var n, i = "style" in e ? e : r(); if ("style" in i) { var s = i.style.scrollBehavior; null != s && "" !== s && (n = s) } if (null == n) { var a = i.getAttribute("scroll-behavior"); null != a && "" !== a && (n = a) } if (null == n && (n = o(i)), null == n) { var l = getComputedStyle(i).getPropertyValue("scrollBehavior"); null != l && "" !== l && (n = l) } return n } function c(e) { return .5 * (1 - Math.cos(Math.PI * e)) } var u = { reset: function () { } }, h = "undefined" == typeof WeakMap ? void 0 : new WeakMap; var d = e ? void 0 : Element.prototype.scroll, p = e ? void 0 : window.scroll, f = e ? void 0 : Element.prototype.scrollBy, m = e ? void 0 : window.scrollBy, g = e ? void 0 : Element.prototype.scrollTo, v = e ? void 0 : window.scrollTo; function y(e, t) { this.__adjustingScrollPosition = !0, this.scrollLeft = e, this.scrollTop = t, delete this.__adjustingScrollPosition } function x(e, t) { return y.call(this, e, t) } function _(e, t) { this.__adjustingScrollPosition = !0, this.scrollLeft += e, this.scrollTop += t, delete this.__adjustingScrollPosition } function w(e, t) { switch (e) { case "scroll": return t instanceof Element ? null != d ? d : y : p; case "scrollBy": return t instanceof Element ? null != f ? f : _ : m; case "scrollTo": return t instanceof Element ? null != g ? g : x : v } } function b(e) { return null == e ? 0 : "number" == typeof e ? e : "string" == typeof e ? parseFloat(e) : 0 } function S(e) { return null != e && "object" == typeof e } function E(e, i, s, d) { !function (e, n, i) { var s = l(n, e); null == s || "auto" === s ? w(i, n).call(n, e.left, e.top) : function (e) { var n = e.startTime, i = e.startX, s = e.startY, l = e.endX, d = e.endY, p = e.method, f = e.scroller, m = 0, g = l - i, v = d - s, y = Math.max(Math.abs(g / 1e3 * 15e3), Math.abs(v / 1e3 * 15e3)), x = function (e) { if (t || null == h) return u; var n, i, s, l, c, d = r(), p = h.get(e); if (null != p) n = p.cachedScrollSnapValue, i = p.cachedScrollBehaviorStyleAttributeValue, s = p.secondaryScroller, l = p.secondaryScrollerCachedScrollSnapValue, c = p.secondaryScrollerCachedScrollBehaviorStyleAttributeValue, p.release(); else { n = "" === e.style.scrollSnapType ? null : e.style.scrollSnapType, i = o(e), s = e === d && d !== document.body ? document.body : void 0, l = null == s ? void 0 : "" === s.style.scrollSnapType ? null : s.style.scrollSnapType, c = null == s ? void 0 : o(s); var f = getComputedStyle(e).getPropertyValue("scroll-snap-type"), m = null == s ? void 0 : getComputedStyle(s).getPropertyValue("scroll-snap-type"); if ("none" === f && "none" === m) return u } e.style.scrollSnapType = "none", void 0 !== s && (s.style.scrollSnapType = "none"), void 0 !== i && a(e, i), void 0 !== s && void 0 !== c && a(s, c); var g = !1, v = e === d ? window : e; function y() { v.removeEventListener("scroll", x), null != h && h.delete(e), g = !0 } function x() { e.style.scrollSnapType = n, null != s && void 0 !== l && (s.style.scrollSnapType = l), void 0 !== i && a(e, i), void 0 !== s && void 0 !== c && a(s, c), y() } return h.set(e, { release: y, cachedScrollSnapValue: n, cachedScrollBehaviorStyleAttributeValue: i, secondaryScroller: s, secondaryScrollerCachedScrollSnapValue: l, secondaryScrollerCachedScrollBehaviorStyleAttributeValue: c }), { reset: function () { setTimeout((function () { g || v.addEventListener("scroll", x) })) } } }(f); requestAnimationFrame((function e(t) { m += t - n; var r = Math.max(0, Math.min(1, 0 === y ? 0 : m / y)), a = Math.floor(i + g * c(r)), o = Math.floor(s + v * c(r)); p(a, o), a !== l || o !== d ? requestAnimationFrame(e) : null != x && (x.reset(), x = void 0) })) }(function (e, t, n, i) { var s = "performance" in window ? performance.now() : Date.now(); if (e instanceof Element) return { startTime: s, startX: a = e.scrollLeft, startY: o = e.scrollTop, endX: Math.floor("scrollBy" === i ? a + t : t), endY: Math.floor("scrollBy" === i ? o + n : n), method: w("scrollTo", e).bind(e), scroller: e }; var a, o, l = window.scrollX, c = window.pageXOffset, u = window.scrollY, h = window.pageYOffset; return { startTime: s, startX: a = null == l || 0 === l ? c : l, startY: o = null == u || 0 === u ? h : u, endX: Math.floor("scrollBy" === i ? a + t : t), endY: Math.floor("scrollBy" === i ? o + n : n), method: w("scrollTo", window).bind(window), scroller: r() } }(n, e.left, e.top, i)) }(function (e, t) { if (void 0 === t && !S(e)) throw new TypeError("Failed to execute 'scroll' on 'Element': parameter 1 ('options') is not an object."); return S(e) ? n(n({}, M(e.left, e.top)), { behavior: null == e.behavior ? "auto" : e.behavior }) : n(n({}, M(e, t)), { behavior: "auto" }) }(s, d), e, i) } function M(e, t) { return { left: b(e), top: b(t) } } function T(e) { return "nodeType" in e && 1 === e.nodeType ? e.parentNode : "ShadowRoot" in window && e instanceof window.ShadowRoot ? e.host : e === document ? window : e instanceof Node ? e.parentNode : null } function C(e) { return "visible" !== e && "clip" !== e } function D(e) { if (e.clientHeight < e.scrollHeight || e.clientWidth < e.scrollWidth) { var t = getComputedStyle(e, null); return C(t.overflowY) || C(t.overflowX) } return !1 } function L(e) { for (var t = e, n = r(); null != t;) { var i = l(t); if (null != i && (t === n || D(t))) return [t, i]; t = T(t) } for (t = e; null != t;) { if (t === n || D(t)) return [t, "auto"]; t = T(t) } return [n, "auto"] } function A(e) { if (void 0 === e && (e = location), "origin" in e && null != e.origin) return e.origin; var t = null != e.port && e.port.length > 0 ? ":" + e.port : ""; return ("http:" === e.protocol && ":80" === t || "https:" === e.protocol && ":443" === t) && (t = ""), e.protocol + "//" + e.hostname + t } var P = /^#\d/; var R = e ? void 0 : Element.prototype.scrollIntoView; function O(e, t, n, i, r, s, a, o) { return s < e && a > t || s > e && a < t ? 0 : s <= e && o <= n || a >= t && o >= n ? s - e - i : a > t && o < n || s < e && o > n ? a - t + r : 0 } function I(e, t, n) { var i = n.block, s = n.inline, a = r(), o = null != window.visualViewport ? visualViewport.width : innerWidth, l = null != window.visualViewport ? visualViewport.height : innerHeight, c = null != window.scrollX ? window.scrollX : window.pageXOffset, u = null != window.scrollY ? window.scrollY : window.pageYOffset, h = e.getBoundingClientRect(), d = h.height, p = h.width, f = h.top, m = h.right, g = h.bottom, v = h.left, y = "start" === i || "nearest" === i ? f : "end" === i ? g : f + d / 2, x = "center" === s ? v + p / 2 : "end" === s ? m : v, _ = t.getBoundingClientRect(), w = _.height, b = _.width, S = _.top, E = _.right, M = _.bottom, T = _.left, C = getComputedStyle(t), D = parseInt(C.borderLeftWidth, 10), L = parseInt(C.borderTopWidth, 10), A = parseInt(C.borderRightWidth, 10), P = parseInt(C.borderBottomWidth, 10), R = 0, I = 0, F = "offsetWidth" in t ? t.offsetWidth - t.clientWidth - D - A : 0, z = "offsetHeight" in t ? t.offsetHeight - t.clientHeight - L - P : 0; if (a === t) R = "start" === i ? y : "end" === i ? y - l : "nearest" === i ? O(u, u + l, l, L, P, u + y, u + y + d, d) : y - l / 2, I = "start" === s ? x : "center" === s ? x - o / 2 : "end" === s ? x - o : O(c, c + o, o, D, A, c + x, c + x + p, p), R = Math.max(0, R + u), I = Math.max(0, I + c); else { R = "start" === i ? y - S - L : "end" === i ? y - M + P + z : "nearest" === i ? O(S, M, w, L, P + z, y, y + d, d) : y - (S + w / 2) + z / 2, I = "start" === s ? x - T - D : "center" === s ? x - (T + b / 2) + F / 2 : "end" === s ? x - E + A + F : O(T, E, b, D, A + F, x, x + p, p); var k = t.scrollLeft, N = t.scrollTop; R = Math.max(0, Math.min(N + R, t.scrollHeight - w + z)), I = Math.max(0, Math.min(k + I, t.scrollWidth - b + F)) } return { top: R, left: I } } var F = e ? void 0 : Object.getOwnPropertyDescriptor(Element.prototype, "scrollTop").set, z = e ? void 0 : Object.getOwnPropertyDescriptor(Element.prototype, "scrollLeft").set, k = !e && "scroll" in Element.prototype && "scrollTo" in Element.prototype && "scrollBy" in Element.prototype && "scrollIntoView" in Element.prototype; e || t && k || (Element.prototype.scroll = function (e, t) { E(this, "scroll", e, t) }, Element.prototype.scrollBy = function (e, t) { E(this, "scrollBy", e, t) }, Element.prototype.scrollTo = function (e, t) { E(this, "scrollTo", e, t) }, Element.prototype.scrollIntoView = function (e) { var t = null == e || !0 === e ? { block: "start", inline: "nearest" } : !1 === e ? { block: "end", inline: "nearest" } : e, r = i(L(this), 2), s = r[0], a = r[1], o = null != t.behavior ? t.behavior : a; if ("smooth" === o) s.scrollTo(n({ behavior: o }, I(this, s, t))); else if (null != R) R.call(this, t); else { var l = I(this, s, t), c = l.top, u = l.left; w("scrollTo", this).call(this, u, c) } }, null != HTMLElement.prototype.scrollIntoView && HTMLElement.prototype.scrollIntoView !== Element.prototype.scrollIntoView && (HTMLElement.prototype.scrollIntoView = Element.prototype.scrollIntoView), Object.defineProperty(Element.prototype, "scrollLeft", { set: function (e) { return this.__adjustingScrollPosition ? z.call(this, e) : (E(this, "scrollTo", e, this.scrollTop), e) } }), Object.defineProperty(Element.prototype, "scrollTop", { set: function (e) { return this.__adjustingScrollPosition ? F.call(this, e) : (E(this, "scrollTo", this.scrollLeft, e), e) } }), window.scroll = function (e, t) { E(this, "scroll", e, t) }, window.scrollBy = function (e, t) { E(this, "scrollBy", e, t) }, window.scrollTo = function (e, t) { E(this, "scrollTo", e, t) }, window.addEventListener("click", (function (e) { if (e.isTrusted && e.target instanceof HTMLAnchorElement) { var t = e.target, n = t.pathname, r = t.search, s = t.hash; if (A(e.target) === A(location) && n === location.pathname && r === location.search && null != s && !(s.length < 1)) { var a = function (e) { for (var t = e; null != t;) { if ("ShadowRoot" in window && t instanceof window.ShadowRoot) return t; var n = T(t); if (n === t) return document; t = n } return document }(e.target), o = null != s.match(P) ? a.getElementById(s.slice(1)) : a.querySelector(s); if (null != o) { var l = i(L(o), 2)[1]; "smooth" === l && (e.preventDefault(), o.scrollIntoView({ behavior: l })) } } } }))) }() }, 306: function (e, t, n) { var i, r; i = function () { "use strict"; var e = function () { r.log(2, "(COMPATIBILITY NOTICE) -> As of ScrollMagic 2.0.0 you need to use 'new ScrollMagic.Controller()' to create a new controller instance. Use 'new ScrollMagic.Scene()' to instance a scene.") }; e.version = "2.0.8", "undefined" != typeof window && window.addEventListener("mousewheel", void 0); var t = "data-scrollmagic-pin-spacer"; e.Controller = function (i) { var s, a, o = "ScrollMagic.Controller", l = "REVERSE", c = "PAUSED", u = n.defaults, h = this, d = r.extend({}, u, i), p = [], f = !1, m = 0, g = c, v = !0, y = 0, x = !0, _ = function () { d.refreshInterval > 0 && (a = window.setTimeout(C, d.refreshInterval)) }, w = function () { return d.vertical ? r.get.scrollTop(d.container) : r.get.scrollLeft(d.container) }, b = function () { return d.vertical ? r.get.height(d.container) : r.get.width(d.container) }, S = this._setScrollPos = function (e) { d.vertical ? v ? window.scrollTo(r.get.scrollLeft(), e) : d.container.scrollTop = e : v ? window.scrollTo(e, r.get.scrollTop()) : d.container.scrollLeft = e }, E = function () { if (x && f) { var e = r.type.Array(f) ? f : p.slice(0); f = !1; var t = m, n = (m = h.scrollPos()) - t; 0 !== n && (g = n > 0 ? "FORWARD" : l), g === l && e.reverse(), e.forEach((function (t, n) { D(3, "updating Scene " + (n + 1) + "/" + e.length + " (" + p.length + " total)"), t.update(!0) })), 0 === e.length && d.loglevel >= 3 && D(3, "updating 0 Scenes (nothing added to controller)") } }, M = function () { s = r.rAF(E) }, T = function (e) { D(3, "event fired causing an update:", e.type), "resize" == e.type && (y = b(), g = c), !0 !== f && (f = !0, M()) }, C = function () { if (!v && y != b()) { var e; try { e = new Event("resize", { bubbles: !1, cancelable: !1 }) } catch (t) { (e = document.createEvent("Event")).initEvent("resize", !1, !1) } d.container.dispatchEvent(e) } p.forEach((function (e, t) { e.refresh() })), _() }, D = this._log = function (e, t) { d.loglevel >= e && (Array.prototype.splice.call(arguments, 1, 0, "(" + o + ") ->"), r.log.apply(window, arguments)) }; this._options = d; var L = function (e) { if (e.length <= 1) return e; var t = e.slice(0); return t.sort((function (e, t) { return e.scrollOffset() > t.scrollOffset() ? 1 : -1 })), t }; return this.addScene = function (t) { if (r.type.Array(t)) t.forEach((function (e, t) { h.addScene(e) })); else if (t instanceof e.Scene) { if (t.controller() !== h) t.addTo(h); else if (p.indexOf(t) < 0) { for (var n in p.push(t), p = L(p), t.on("shift.controller_sort", (function () { p = L(p) })), d.globalSceneOptions) t[n] && t[n].call(t, d.globalSceneOptions[n]); D(3, "adding Scene (now " + p.length + " total)") } } else D(1, "ERROR: invalid argument supplied for '.addScene()'"); return h }, this.removeScene = function (e) { if (r.type.Array(e)) e.forEach((function (e, t) { h.removeScene(e) })); else { var t = p.indexOf(e); t > -1 && (e.off("shift.controller_sort"), p.splice(t, 1), D(3, "removing Scene (now " + p.length + " left)"), e.remove()) } return h }, this.updateScene = function (t, n) { return r.type.Array(t) ? t.forEach((function (e, t) { h.updateScene(e, n) })) : n ? t.update(!0) : !0 !== f && t instanceof e.Scene && (-1 == (f = f || []).indexOf(t) && f.push(t), f = L(f), M()), h }, this.update = function (e) { return T({ type: "resize" }), e && E(), h }, this.scrollTo = function (n, i) { if (r.type.Number(n)) S.call(d.container, n, i); else if (n instanceof e.Scene) n.controller() === h ? h.scrollTo(n.scrollOffset(), i) : D(2, "scrollTo(): The supplied scene does not belong to this controller. Scroll cancelled.", n); else if (r.type.Function(n)) S = n; else { var s = r.get.elements(n)[0]; if (s) { for (; s.parentNode.hasAttribute(t);)s = s.parentNode; var a = d.vertical ? "top" : "left", o = r.get.offset(d.container), l = r.get.offset(s); v || (o[a] -= h.scrollPos()), h.scrollTo(l[a] - o[a], i) } else D(2, "scrollTo(): The supplied argument is invalid. Scroll cancelled.", n) } return h }, this.scrollPos = function (e) { return arguments.length ? (r.type.Function(e) ? w = e : D(2, "Provided value for method 'scrollPos' is not a function. To change the current scroll position use 'scrollTo()'."), h) : w.call(h) }, this.info = function (e) { var t = { size: y, vertical: d.vertical, scrollPos: m, scrollDirection: g, container: d.container, isDocument: v }; return arguments.length ? void 0 !== t[e] ? t[e] : void D(1, 'ERROR: option "' + e + '" is not available') : t }, this.loglevel = function (e) { return arguments.length ? (d.loglevel != e && (d.loglevel = e), h) : d.loglevel }, this.enabled = function (e) { return arguments.length ? (x != e && (x = !!e, h.updateScene(p, !0)), h) : x }, this.destroy = function (e) { window.clearTimeout(a); for (var t = p.length; t--;)p[t].destroy(e); return d.container.removeEventListener("resize", T), d.container.removeEventListener("scroll", T), r.cAF(s), D(3, "destroyed " + o + " (reset: " + (e ? "true" : "false") + ")"), null }, function () { for (var t in d) u.hasOwnProperty(t) || (D(2, 'WARNING: Unknown option "' + t + '"'), delete d[t]); if (d.container = r.get.elements(d.container)[0], !d.container) throw D(1, "ERROR creating object " + o + ": No valid scroll container supplied"), o + " init failed."; (v = d.container === window || d.container === document.body || !document.body.contains(d.container)) && (d.container = window), y = b(), d.container.addEventListener("resize", T), d.container.addEventListener("scroll", T); var n = parseInt(d.refreshInterval, 10); d.refreshInterval = r.type.Number(n) ? n : u.refreshInterval, _(), D(3, "added new " + o + " controller (v" + e.version + ")") }(), h }; var n = { defaults: { container: window, vertical: !0, globalSceneOptions: {}, loglevel: 2, refreshInterval: 100 } }; e.Controller.addOption = function (e, t) { n.defaults[e] = t }, e.Controller.extend = function (t) { var n = this; e.Controller = function () { return n.apply(this, arguments), this.$super = r.extend({}, this), t.apply(this, arguments) || this }, r.extend(e.Controller, n), e.Controller.prototype = n.prototype, e.Controller.prototype.constructor = e.Controller }, e.Scene = function (n) { var s, a, o = "ScrollMagic.Scene", l = "BEFORE", c = "DURING", u = "AFTER", h = i.defaults, d = this, p = r.extend({}, h, n), f = l, m = 0, g = { start: 0, end: 0 }, v = 0, y = !0, x = {}; this.on = function (e, t) { return r.type.Function(t) ? (e = e.trim().split(" ")).forEach((function (e) { var n = e.split("."), i = n[0], r = n[1]; "*" != i && (x[i] || (x[i] = []), x[i].push({ namespace: r || "", callback: t })) })) : _(1, "ERROR when calling '.on()': Supplied callback for '" + e + "' is not a valid function!"), d }, this.off = function (e, t) { return e ? ((e = e.trim().split(" ")).forEach((function (e, n) { var i = e.split("."), r = i[0], s = i[1] || ""; ("*" === r ? Object.keys(x) : [r]).forEach((function (e) { for (var n = x[e] || [], i = n.length; i--;) { var r = n[i]; !r || s !== r.namespace && "*" !== s || t && t != r.callback || n.splice(i, 1) } n.length || delete x[e] })) })), d) : (_(1, "ERROR: Invalid event name supplied."), d) }, this.trigger = function (t, n) { if (t) { var i = t.trim().split("."), r = i[0], s = i[1], a = x[r]; _(3, "event fired:", r, n ? "->" : "", n || ""), a && a.forEach((function (t, i) { s && s !== t.namespace || t.callback.call(d, new e.Event(r, t.namespace, d, n)) })) } else _(1, "ERROR: Invalid event name supplied."); return d }, d.on("change.internal", (function (e) { "loglevel" !== e.what && "tweenChanges" !== e.what && ("triggerElement" === e.what ? M() : "reverse" === e.what && d.update()) })).on("shift.internal", (function (e) { S(), d.update() })); var _ = this._log = function (e, t) { p.loglevel >= e && (Array.prototype.splice.call(arguments, 1, 0, "(" + o + ") ->"), r.log.apply(window, arguments)) }; this.addTo = function (t) { return t instanceof e.Controller ? a != t && (a && a.removeScene(d), a = t, D(), E(!0), M(!0), S(), a.info("container").addEventListener("resize", T), t.addScene(d), d.trigger("add", { controller: a }), _(3, "added " + o + " to controller"), d.update()) : _(1, "ERROR: supplied argument of 'addTo()' is not a valid ScrollMagic Controller"), d }, this.enabled = function (e) { return arguments.length ? (y != e && (y = !!e, d.update(!0)), d) : y }, this.remove = function () { if (a) { a.info("container").removeEventListener("resize", T); var e = a; a = void 0, e.removeScene(d), d.trigger("remove"), _(3, "removed " + o + " from controller") } return d }, this.destroy = function (e) { return d.trigger("destroy", { reset: e }), d.remove(), d.off("*.*"), _(3, "destroyed " + o + " (reset: " + (e ? "true" : "false") + ")"), null }, this.update = function (e) { if (a) if (e) if (a.enabled() && y) { var t, n = a.info("scrollPos"); t = p.duration > 0 ? (n - g.start) / (g.end - g.start) : n >= g.start ? 1 : 0, d.trigger("update", { startPos: g.start, endPos: g.end, scrollPos: n }), d.progress(t) } else w && f === c && P(!0); else a.updateScene(d, !1); return d }, this.refresh = function () { return E(), M(), d }, this.progress = function (e) { if (arguments.length) { var t = !1, n = f, i = a ? a.info("scrollDirection") : "PAUSED", r = p.reverse || e >= m; if (0 === p.duration ? (t = m != e, f = 0 == (m = e < 1 && r ? 0 : 1) ? l : c) : e < 0 && f !== l && r ? (m = 0, f = l, t = !0) : e >= 0 && e < 1 && r ? (m = e, f = c, t = !0) : e >= 1 && f !== u ? (m = 1, f = u, t = !0) : f !== c || r || P(), t) { var s = { progress: m, state: f, scrollDirection: i }, o = f != n, h = function (e) { d.trigger(e, s) }; o && n !== c && (h("enter"), h(n === l ? "start" : "end")), h("progress"), o && f !== c && (h(f === l ? "start" : "end"), h("leave")) } return d } return m }; var w, b, S = function () { g = { start: v + p.offset }, a && p.triggerElement && (g.start -= a.info("size") * p.triggerHook), g.end = g.start + p.duration }, E = function (e) { if (s) { var t = "duration"; L(t, s.call(d)) && !e && (d.trigger("change", { what: t, newval: p.duration }), d.trigger("shift", { reason: t })) } }, M = function (e) { var n = 0, i = p.triggerElement; if (a && (i || v > 0)) { if (i) if (i.parentNode) { for (var s = a.info(), o = r.get.offset(s.container), l = s.vertical ? "top" : "left"; i.parentNode.hasAttribute(t);)i = i.parentNode; var c = r.get.offset(i); s.isDocument || (o[l] -= a.scrollPos()), n = c[l] - o[l] } else _(2, "WARNING: triggerElement was removed from DOM and will be reset to", void 0), d.triggerElement(void 0); var u = n != v; v = n, u && !e && d.trigger("shift", { reason: "triggerElementPosition" }) } }, T = function (e) { p.triggerHook > 0 && d.trigger("shift", { reason: "containerResize" }) }, C = r.extend(i.validate, { duration: function (e) { if (r.type.String(e) && e.match(/^(\.|\d)*\d+%$/)) { var t = parseFloat(e) / 100; e = function () { return a ? a.info("size") * t : 0 } } if (r.type.Function(e)) { s = e; try { e = parseFloat(s.call(d)) } catch (t) { e = -1 } } if (e = parseFloat(e), !r.type.Number(e) || e < 0) throw s ? (s = void 0, ['Invalid return value of supplied function for option "duration":', e]) : ['Invalid value for option "duration":', e]; return e } }), D = function (e) { (e = arguments.length ? [e] : Object.keys(C)).forEach((function (e, t) { var n; if (C[e]) try { n = C[e](p[e]) } catch (t) { n = h[e]; var i = r.type.String(t) ? [t] : t; r.type.Array(i) ? (i[0] = "ERROR: " + i[0], i.unshift(1), _.apply(this, i)) : _(1, "ERROR: Problem executing validation callback for option '" + e + "':", t.message) } finally { p[e] = n } })) }, L = function (e, t) { var n = !1, i = p[e]; return p[e] != t && (p[e] = t, D(e), n = i != p[e]), n }, A = function (e) { d[e] || (d[e] = function (t) { return arguments.length ? ("duration" === e && (s = void 0), L(e, t) && (d.trigger("change", { what: e, newval: p[e] }), i.shifts.indexOf(e) > -1 && d.trigger("shift", { reason: e })), d) : p[e] }) }; this.controller = function () { return a }, this.state = function () { return f }, this.scrollOffset = function () { return g.start }, this.triggerPosition = function () { var e = p.offset; return a && (p.triggerElement ? e += v : e += a.info("size") * d.triggerHook()), e }, d.on("shift.internal", (function (e) { var t = "duration" === e.reason; (f === u && t || f === c && 0 === p.duration) && P(), t && R() })).on("progress.internal", (function (e) { P() })).on("add.internal", (function (e) { R() })).on("destroy.internal", (function (e) { d.removePin(e.reset) })); var P = function (e) { if (w && a) { var t = a.info(), n = b.spacer.firstChild; if (e || f !== c) { var i = { position: b.inFlow ? "relative" : "absolute", top: 0, left: 0 }, s = r.css(n, "position") != i.position; b.pushFollowers ? p.duration > 0 && (f === u && 0 === parseFloat(r.css(b.spacer, "padding-top")) || f === l && 0 === parseFloat(r.css(b.spacer, "padding-bottom"))) && (s = !0) : i[t.vertical ? "top" : "left"] = p.duration * m, r.css(n, i), s && R() } else { "fixed" != r.css(n, "position") && (r.css(n, { position: "fixed" }), R()); var o = r.get.offset(b.spacer, !0), h = p.reverse || 0 === p.duration ? t.scrollPos - g.start : Math.round(m * p.duration * 10) / 10; o[t.vertical ? "top" : "left"] += h, r.css(b.spacer.firstChild, { top: o.top, left: o.left }) } } }, R = function () { if (w && a && b.inFlow) { var e = f === c, t = a.info("vertical"), n = b.spacer.firstChild, i = r.isMarginCollapseType(r.css(b.spacer, "display")), s = {}; b.relSize.width || b.relSize.autoFullWidth ? e ? r.css(w, { width: r.get.width(b.spacer) }) : r.css(w, { width: "100%" }) : (s["min-width"] = r.get.width(t ? w : n, !0, !0), s.width = e ? s["min-width"] : "auto"), b.relSize.height ? e ? r.css(w, { height: r.get.height(b.spacer) - (b.pushFollowers ? p.duration : 0) }) : r.css(w, { height: "100%" }) : (s["min-height"] = r.get.height(t ? n : w, !0, !i), s.height = e ? s["min-height"] : "auto"), b.pushFollowers && (s["padding" + (t ? "Top" : "Left")] = p.duration * m, s["padding" + (t ? "Bottom" : "Right")] = p.duration * (1 - m)), r.css(b.spacer, s) } }, O = function () { a && w && f === c && !a.info("isDocument") && P() }, I = function () { a && w && f === c && ((b.relSize.width || b.relSize.autoFullWidth) && r.get.width(window) != r.get.width(b.spacer.parentNode) || b.relSize.height && r.get.height(window) != r.get.height(b.spacer.parentNode)) && R() }, F = function (e) { a && w && f === c && !a.info("isDocument") && (e.preventDefault(), a._setScrollPos(a.info("scrollPos") - ((e.wheelDelta || e[a.info("vertical") ? "wheelDeltaY" : "wheelDeltaX"]) / 3 || 30 * -e.detail))) }; this.setPin = function (e, n) { var i = n && n.hasOwnProperty("pushFollowers"); if (n = r.extend({}, { pushFollowers: !0, spacerClass: "scrollmagic-pin-spacer" }, n), !(e = r.get.elements(e)[0])) return _(1, "ERROR calling method 'setPin()': Invalid pin element supplied."), d; if ("fixed" === r.css(e, "position")) return _(1, "ERROR calling method 'setPin()': Pin does not work with elements that are positioned 'fixed'."), d; if (w) { if (w === e) return d; d.removePin() } var s = (w = e).parentNode.style.display, a = ["top", "left", "bottom", "right", "margin", "marginLeft", "marginRight", "marginTop", "marginBottom"]; w.parentNode.style.display = "none"; var o = "absolute" != r.css(w, "position"), l = r.css(w, a.concat(["display"])), c = r.css(w, ["width", "height"]); w.parentNode.style.display = s, !o && n.pushFollowers && (_(2, "WARNING: If the pinned element is positioned absolutely pushFollowers will be disabled."), n.pushFollowers = !1), window.setTimeout((function () { w && 0 === p.duration && i && n.pushFollowers && _(2, "WARNING: pushFollowers =", !0, "has no effect, when scene duration is 0.") }), 0); var u = w.parentNode.insertBefore(document.createElement("div"), w), h = r.extend(l, { position: o ? "relative" : "absolute", boxSizing: "content-box", mozBoxSizing: "content-box", webkitBoxSizing: "content-box" }); if (o || r.extend(h, r.css(w, ["width", "height"])), r.css(u, h), u.setAttribute(t, ""), r.addClass(u, n.spacerClass), b = { spacer: u, relSize: { width: "%" === c.width.slice(-1), height: "%" === c.height.slice(-1), autoFullWidth: "auto" === c.width && o && r.isMarginCollapseType(l.display) }, pushFollowers: n.pushFollowers, inFlow: o }, !w.___origStyle) { w.___origStyle = {}; var f = w.style; a.concat(["width", "height", "position", "boxSizing", "mozBoxSizing", "webkitBoxSizing"]).forEach((function (e) { w.___origStyle[e] = f[e] || "" })) } return b.relSize.width && r.css(u, { width: c.width }), b.relSize.height && r.css(u, { height: c.height }), u.appendChild(w), r.css(w, { position: o ? "relative" : "absolute", margin: "auto", top: "auto", left: "auto", bottom: "auto", right: "auto" }), (b.relSize.width || b.relSize.autoFullWidth) && r.css(w, { boxSizing: "border-box", mozBoxSizing: "border-box", webkitBoxSizing: "border-box" }), window.addEventListener("scroll", O), window.addEventListener("resize", O), window.addEventListener("resize", I), w.addEventListener("mousewheel", F), w.addEventListener("DOMMouseScroll", F), _(3, "added pin"), P(), d }, this.removePin = function (e) { if (w) { if (f === c && P(!0), e || !a) { var n = b.spacer.firstChild; if (n.hasAttribute(t)) { var i = b.spacer.style, s = {};["margin", "marginLeft", "marginRight", "marginTop", "marginBottom"].forEach((function (e) { s[e] = i[e] || "" })), r.css(n, s) } b.spacer.parentNode.insertBefore(n, b.spacer), b.spacer.parentNode.removeChild(b.spacer), w.parentNode.hasAttribute(t) || (r.css(w, w.___origStyle), delete w.___origStyle) } window.removeEventListener("scroll", O), window.removeEventListener("resize", O), window.removeEventListener("resize", I), w.removeEventListener("mousewheel", F), w.removeEventListener("DOMMouseScroll", F), w = void 0, _(3, "removed pin (reset: " + (e ? "true" : "false") + ")") } return d }; var z, k = []; return d.on("destroy.internal", (function (e) { d.removeClassToggle(e.reset) })), this.setClassToggle = function (e, t) { var n = r.get.elements(e); return 0 !== n.length && r.type.String(t) ? (k.length > 0 && d.removeClassToggle(), z = t, k = n, d.on("enter.internal_class leave.internal_class", (function (e) { var t = "enter" === e.type ? r.addClass : r.removeClass; k.forEach((function (e, n) { t(e, z) })) })), d) : (_(1, "ERROR calling method 'setClassToggle()': Invalid " + (0 === n.length ? "element" : "classes") + " supplied."), d) }, this.removeClassToggle = function (e) { return e && k.forEach((function (e, t) { r.removeClass(e, z) })), d.off("start.internal_class end.internal_class"), z = void 0, k = [], d }, function () { for (var e in p) h.hasOwnProperty(e) || (_(2, 'WARNING: Unknown option "' + e + '"'), delete p[e]); for (var t in h) A(t); D() }(), d }; var i = { defaults: { duration: 0, offset: 0, triggerElement: void 0, triggerHook: .5, reverse: !0, loglevel: 2 }, validate: { offset: function (e) { if (e = parseFloat(e), !r.type.Number(e)) throw ['Invalid value for option "offset":', e]; return e }, triggerElement: function (e) { if (e = e || void 0) { var t = r.get.elements(e)[0]; if (!t || !t.parentNode) throw ['Element defined in option "triggerElement" was not found:', e]; e = t } return e }, triggerHook: function (e) { var t = { onCenter: .5, onEnter: 1, onLeave: 0 }; if (r.type.Number(e)) e = Math.max(0, Math.min(parseFloat(e), 1)); else { if (!(e in t)) throw ['Invalid value for option "triggerHook": ', e]; e = t[e] } return e }, reverse: function (e) { return !!e }, loglevel: function (e) { if (e = parseInt(e), !r.type.Number(e) || e < 0 || e > 3) throw ['Invalid value for option "loglevel":', e]; return e } }, shifts: ["duration", "offset", "triggerHook"] }; e.Scene.addOption = function (t, n, r, s) { t in i.defaults ? e._util.log(1, "[static] ScrollMagic.Scene -> Cannot add Scene option '" + t + "', because it already exists.") : (i.defaults[t] = n, i.validate[t] = r, s && i.shifts.push(t)) }, e.Scene.extend = function (t) { var n = this; e.Scene = function () { return n.apply(this, arguments), this.$super = r.extend({}, this), t.apply(this, arguments) || this }, r.extend(e.Scene, n), e.Scene.prototype = n.prototype, e.Scene.prototype.constructor = e.Scene }, e.Event = function (e, t, n, i) { for (var r in i = i || {}) this[r] = i[r]; return this.type = e, this.target = this.currentTarget = n, this.namespace = t || "", this.timeStamp = this.timestamp = Date.now(), this }; var r = e._util = function (e) { var t, n = {}, i = function (e) { return parseFloat(e) || 0 }, r = function (t) { return t.currentStyle ? t.currentStyle : e.getComputedStyle(t) }, s = function (t, n, s, a) { if ((n = n === document ? e : n) === e) a = !1; else if (!f.DomElement(n)) return 0; t = t.charAt(0).toUpperCase() + t.substr(1).toLowerCase(); var o = (s ? n["offset" + t] || n["outer" + t] : n["client" + t] || n["inner" + t]) || 0; if (s && a) { var l = r(n); o += "Height" === t ? i(l.marginTop) + i(l.marginBottom) : i(l.marginLeft) + i(l.marginRight) } return o }, a = function (e) { return e.replace(/^[^a-z]+([a-z])/g, "$1").replace(/-([a-z])/g, (function (e) { return e[1].toUpperCase() })) }; n.extend = function (e) { for (e = e || {}, t = 1; t < arguments.length; t++)if (arguments[t]) for (var n in arguments[t]) arguments[t].hasOwnProperty(n) && (e[n] = arguments[t][n]); return e }, n.isMarginCollapseType = function (e) { return ["block", "flex", "list-item", "table", "-webkit-box"].indexOf(e) > -1 }; var o = 0, l = ["ms", "moz", "webkit", "o"], c = e.requestAnimationFrame, u = e.cancelAnimationFrame; for (t = 0; !c && t < l.length; ++t)c = e[l[t] + "RequestAnimationFrame"], u = e[l[t] + "CancelAnimationFrame"] || e[l[t] + "CancelRequestAnimationFrame"]; c || (c = function (t) { var n = (new Date).getTime(), i = Math.max(0, 16 - (n - o)), r = e.setTimeout((function () { t(n + i) }), i); return o = n + i, r }), u || (u = function (t) { e.clearTimeout(t) }), n.rAF = c.bind(e), n.cAF = u.bind(e); var h = ["error", "warn", "log"], d = e.console || {}; for (d.log = d.log || function () { }, t = 0; t < h.length; t++) { var p = h[t]; d[p] || (d[p] = d.log) } n.log = function (e) { (e > h.length || e <= 0) && (e = h.length); var t = new Date, n = ("0" + t.getHours()).slice(-2) + ":" + ("0" + t.getMinutes()).slice(-2) + ":" + ("0" + t.getSeconds()).slice(-2) + ":" + ("00" + t.getMilliseconds()).slice(-3), i = h[e - 1], r = Array.prototype.splice.call(arguments, 1), s = Function.prototype.bind.call(d[i], d); r.unshift(n), s.apply(d, r) }; var f = n.type = function (e) { return Object.prototype.toString.call(e).replace(/^\[object (.+)\]$/, "$1").toLowerCase() }; f.String = function (e) { return "string" === f(e) }, f.Function = function (e) { return "function" === f(e) }, f.Array = function (e) { return Array.isArray(e) }, f.Number = function (e) { return !f.Array(e) && e - parseFloat(e) + 1 >= 0 }, f.DomElement = function (e) { return "object" == typeof HTMLElement || "function" == typeof HTMLElement ? e instanceof HTMLElement || e instanceof SVGElement : e && "object" == typeof e && null !== e && 1 === e.nodeType && "string" == typeof e.nodeName }; var m = n.get = {}; return m.elements = function (t) { var n = []; if (f.String(t)) try { t = document.querySelectorAll(t) } catch (e) { return n } if ("nodelist" === f(t) || f.Array(t) || t instanceof NodeList) for (var i = 0, r = n.length = t.length; i < r; i++) { var s = t[i]; n[i] = f.DomElement(s) ? s : m.elements(s) } else (f.DomElement(t) || t === document || t === e) && (n = [t]); return n }, m.scrollTop = function (t) { return t && "number" == typeof t.scrollTop ? t.scrollTop : e.pageYOffset || 0 }, m.scrollLeft = function (t) { return t && "number" == typeof t.scrollLeft ? t.scrollLeft : e.pageXOffset || 0 }, m.width = function (e, t, n) { return s("width", e, t, n) }, m.height = function (e, t, n) { return s("height", e, t, n) }, m.offset = function (e, t) { var n = { top: 0, left: 0 }; if (e && e.getBoundingClientRect) { var i = e.getBoundingClientRect(); n.top = i.top, n.left = i.left, t || (n.top += m.scrollTop(), n.left += m.scrollLeft()) } return n }, n.addClass = function (e, t) { t && (e.classList ? e.classList.add(t) : e.className += " " + t) }, n.removeClass = function (e, t) { t && (e.classList ? e.classList.remove(t) : e.className = e.className.replace(new RegExp("(^|\\b)" + t.split(" ").join("|") + "(\\b|$)", "gi"), " ")) }, n.css = function (e, t) { if (f.String(t)) return r(e)[a(t)]; if (f.Array(t)) { var n = {}, i = r(e); return t.forEach((function (e, t) { n[e] = i[a(e)] })), n } for (var s in t) { var o = t[s]; o == parseFloat(o) && (o += "px"), e.style[a(s)] = o } }, n }(window || {}); return e.Scene.prototype.addIndicators = function () { return e._util.log(1, "(ScrollMagic.Scene) -> ERROR calling addIndicators() due to missing Plugin 'debug.addIndicators'. Please make sure to include plugins/debug.addIndicators.js"), this }, e.Scene.prototype.removeIndicators = function () { return e._util.log(1, "(ScrollMagic.Scene) -> ERROR calling removeIndicators() due to missing Plugin 'debug.addIndicators'. Please make sure to include plugins/debug.addIndicators.js"), this }, e.Scene.prototype.setTween = function () { return e._util.log(1, "(ScrollMagic.Scene) -> ERROR calling setTween() due to missing Plugin 'animation.gsap'. Please make sure to include plugins/animation.gsap.js"), this }, e.Scene.prototype.removeTween = function () { return e._util.log(1, "(ScrollMagic.Scene) -> ERROR calling removeTween() due to missing Plugin 'animation.gsap'. Please make sure to include plugins/animation.gsap.js"), this }, e.Scene.prototype.setVelocity = function () { return e._util.log(1, "(ScrollMagic.Scene) -> ERROR calling setVelocity() due to missing Plugin 'animation.velocity'. Please make sure to include plugins/animation.velocity.js"), this }, e.Scene.prototype.removeVelocity = function () { return e._util.log(1, "(ScrollMagic.Scene) -> ERROR calling removeVelocity() due to missing Plugin 'animation.velocity'. Please make sure to include plugins/animation.velocity.js"), this }, e }, void 0 === (r = i.call(t, n, t, e)) || (e.exports = r) } }, t = {}; function n(i) { var r = t[i]; if (void 0 !== r) return r.exports; var s = t[i] = { exports: {} }; return e[i].call(s.exports, s, s.exports, n), s.exports } n.n = e => { var t = e && e.__esModule ? () => e.default : () => e; return n.d(t, { a: t }), t }, n.d = (e, t) => { for (var i in t) n.o(t, i) && !n.o(e, i) && Object.defineProperty(e, i, { enumerable: !0, get: t[i] }) }, n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), (() => { "use strict"; var e = n(69), t = n.n(e), i = n(40), r = n.n(i); function s(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e } function a(e, t) { e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t } var o, l, c, u, h, d, p, f, m, g, v, y, x, _ = { autoSleep: 120, force3D: "auto", nullTargetWarn: 1, units: { lineHeight: "" } }, w = { duration: .5, overwrite: !1, delay: 0 }, b = 1e8, S = 1e-8, E = 2 * Math.PI, M = E / 4, T = 0, C = Math.sqrt, D = Math.cos, L = Math.sin, A = function (e) { return "string" == typeof e }, P = function (e) { return "function" == typeof e }, R = function (e) { return "number" == typeof e }, O = function (e) { return void 0 === e }, I = function (e) { return "object" == typeof e }, F = function (e) { return !1 !== e }, z = function () { return "undefined" != typeof window }, k = function (e) { return P(e) || A(e) }, N = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function () { }, B = Array.isArray, H = /(?:-?\.?\d|\.)+/gi, U = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, V = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, G = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, j = /[+-]=-?[.\d]+/, W = /[^,'"\[\]\s]+/gi, q = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, X = {}, Y = {}, Z = function (e) { return (Y = be(e, X)) && dn }, K = function (e, t) { return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()") }, J = function (e, t) { return !t && console.warn(e) }, Q = function (e, t) { return e && (X[e] = t) && Y && (Y[e] = t) || X }, ee = function () { return 0 }, te = {}, ne = [], ie = {}, re = {}, se = {}, ae = 30, oe = [], le = "", ce = function (e) { var t, n, i = e[0]; if (I(i) || P(i) || (e = [e]), !(t = (i._gsap || {}).harness)) { for (n = oe.length; n-- && !oe[n].targetTest(i);); t = oe[n] } for (n = e.length; n--;)e[n] && (e[n]._gsap || (e[n]._gsap = new It(e[n], t))) || e.splice(n, 1); return e }, ue = function (e) { return e._gsap || ce(Qe(e))[0]._gsap }, he = function (e, t, n) { return (n = e[t]) && P(n) ? e[t]() : O(n) && e.getAttribute && e.getAttribute(t) || n }, de = function (e, t) { return (e = e.split(",")).forEach(t) || e }, pe = function (e) { return Math.round(1e5 * e) / 1e5 || 0 }, fe = function (e) { return Math.round(1e7 * e) / 1e7 || 0 }, me = function (e, t) { var n = t.charAt(0), i = parseFloat(t.substr(2)); return e = parseFloat(e), "+" === n ? e + i : "-" === n ? e - i : "*" === n ? e * i : e / i }, ge = function (e, t) { for (var n = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < n;); return i < n }, ve = function () { var e, t, n = ne.length, i = ne.slice(0); for (ie = {}, ne.length = 0, e = 0; e < n; e++)(t = i[e]) && t._lazy && (t.render(t._lazy[0], t._lazy[1], !0)._lazy = 0) }, ye = function (e, t, n, i) { ne.length && ve(), e.render(t, n, i), ne.length && ve() }, xe = function (e) { var t = parseFloat(e); return (t || 0 === t) && (e + "").match(W).length < 2 ? t : A(e) ? e.trim() : e }, _e = function (e) { return e }, we = function (e, t) { for (var n in t) n in e || (e[n] = t[n]); return e }, be = function (e, t) { for (var n in t) e[n] = t[n]; return e }, Se = function e(t, n) { for (var i in n) "__proto__" !== i && "constructor" !== i && "prototype" !== i && (t[i] = I(n[i]) ? e(t[i] || (t[i] = {}), n[i]) : n[i]); return t }, Ee = function (e, t) { var n, i = {}; for (n in e) n in t || (i[n] = e[n]); return i }, Me = function (e) { var t, n = e.parent || l, i = e.keyframes ? (t = B(e.keyframes), function (e, n) { for (var i in n) i in e || "duration" === i && t || "ease" === i || (e[i] = n[i]) }) : we; if (F(e.inherit)) for (; n;)i(e, n.vars.defaults), n = n.parent || n._dp; return e }, Te = function (e, t, n, i, r) { void 0 === n && (n = "_first"), void 0 === i && (i = "_last"); var s, a = e[i]; if (r) for (s = t[r]; a && a[r] > s;)a = a._prev; return a ? (t._next = a._next, a._next = t) : (t._next = e[n], e[n] = t), t._next ? t._next._prev = t : e[i] = t, t._prev = a, t.parent = t._dp = e, t }, Ce = function (e, t, n, i) { void 0 === n && (n = "_first"), void 0 === i && (i = "_last"); var r = t._prev, s = t._next; r ? r._next = s : e[n] === t && (e[n] = s), s ? s._prev = r : e[i] === t && (e[i] = r), t._next = t._prev = t.parent = null }, De = function (e, t) { e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove(e), e._act = 0 }, Le = function (e, t) { if (e && (!t || t._end > e._dur || t._start < 0)) for (var n = e; n;)n._dirty = 1, n = n.parent; return e }, Ae = function (e) { for (var t = e.parent; t && t.parent;)t._dirty = 1, t.totalDuration(), t = t.parent; return e }, Pe = function e(t) { return !t || t._ts && e(t.parent) }, Re = function (e) { return e._repeat ? Oe(e._tTime, e = e.duration() + e._rDelay) * e : 0 }, Oe = function (e, t) { var n = Math.floor(e /= t); return e && n === e ? n - 1 : n }, Ie = function (e, t) { return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur) }, Fe = function (e) { return e._end = fe(e._start + (e._tDur / Math.abs(e._ts || e._rts || S) || 0)) }, ze = function (e, t) { var n = e._dp; return n && n.smoothChildTiming && e._ts && (e._start = fe(n._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), Fe(e), n._dirty || Le(n, e)), e }, ke = function (e, t) { var n; if ((t._time || t._initted && !t._dur) && (n = Ie(e.rawTime(), t), (!t._dur || Ye(0, t.totalDuration(), n) - t._tTime > S) && t.render(n, !0)), Le(e, t)._dp && e._initted && e._time >= e._dur && e._ts) { if (e._dur < e.duration()) for (n = e; n._dp;)n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp; e._zTime = -1e-8 } }, Ne = function (e, t, n, i) { return t.parent && De(t), t._start = fe((R(n) ? n : n || e !== l ? qe(e, n, t) : e._time) + t._delay), t._end = fe(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), Te(e, t, "_first", "_last", e._sort ? "_start" : 0), Ve(t) || (e._recent = t), i || ke(e, t), e }, Be = function (e, t) { return (X.ScrollTrigger || K("scrollTrigger", t)) && X.ScrollTrigger.create(t, e) }, He = function (e, t, n, i) { return Vt(e, t), e._initted ? !n && e._pt && (e._dur && !1 !== e.vars.lazy || !e._dur && e.vars.lazy) && p !== wt.frame ? (ne.push(e), e._lazy = [t, i], 1) : void 0 : 1 }, Ue = function e(t) { var n = t.parent; return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || e(n)) }, Ve = function (e) { var t = e.data; return "isFromStart" === t || "isStart" === t }, Ge = function (e, t, n, i) { var r = e._repeat, s = fe(t) || 0, a = e._tTime / e._tDur; return a && !i && (e._time *= s / e._dur), e._dur = s, e._tDur = r ? r < 0 ? 1e10 : fe(s * (r + 1) + e._rDelay * r) : s, a > 0 && !i ? ze(e, e._tTime = e._tDur * a) : e.parent && Fe(e), n || Le(e.parent, e), e }, je = function (e) { return e instanceof zt ? Le(e) : Ge(e, e._dur) }, We = { _start: 0, endTime: ee, totalDuration: ee }, qe = function e(t, n, i) { var r, s, a, o = t.labels, l = t._recent || We, c = t.duration() >= b ? l.endTime(!1) : t._dur; return A(n) && (isNaN(n) || n in o) ? (s = n.charAt(0), a = "%" === n.substr(-1), r = n.indexOf("="), "<" === s || ">" === s ? (r >= 0 && (n = n.replace(/=/, "")), ("<" === s ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) * (a ? (r < 0 ? l : i).totalDuration() / 100 : 1)) : r < 0 ? (n in o || (o[n] = c), o[n]) : (s = parseFloat(n.charAt(r - 1) + n.substr(r + 1)), a && i && (s = s / 100 * (B(i) ? i[0] : i).totalDuration()), r > 1 ? e(t, n.substr(0, r - 1), i) + s : c + s)) : null == n ? c : +n }, $e = function (e, t, n) { var i, r, s = R(t[1]), a = (s ? 2 : 1) + (e < 2 ? 0 : 1), o = t[a]; if (s && (o.duration = t[1]), o.parent = n, e) { for (i = o, r = n; r && !("immediateRender" in i);)i = r.vars.defaults || {}, r = F(r.vars.inherit) && r.parent; o.immediateRender = F(i.immediateRender), e < 2 ? o.runBackwards = 1 : o.startAt = t[a - 1] } return new $t(t[0], o, t[a + 1]) }, Xe = function (e, t) { return e || 0 === e ? t(e) : t }, Ye = function (e, t, n) { return n < e ? e : n > t ? t : n }, Ze = function (e, t) { return A(e) && (t = q.exec(e)) ? t[1] : "" }, Ke = [].slice, Je = function (e, t) { return e && I(e) && "length" in e && (!t && !e.length || e.length - 1 in e && I(e[0])) && !e.nodeType && e !== c }, Qe = function (e, t, n) { return !A(e) || n || !u && bt() ? B(e) ? function (e, t, n) { return void 0 === n && (n = []), e.forEach((function (e) { var i; return A(e) && !t || Je(e, 1) ? (i = n).push.apply(i, Qe(e)) : n.push(e) })) || n }(e, n) : Je(e) ? Ke.call(e, 0) : e ? [e] : [] : Ke.call((t || h).querySelectorAll(e), 0) }, et = function (e) { return e.sort((function () { return .5 - Math.random() })) }, tt = function (e) { if (P(e)) return e; var t = I(e) ? e : { each: e }, n = Lt(t.ease), i = t.from || 0, r = parseFloat(t.base) || 0, s = {}, a = i > 0 && i < 1, o = isNaN(i) || a, l = t.axis, c = i, u = i; return A(i) ? c = u = { center: .5, edges: .5, end: 1 }[i] || 0 : !a && o && (c = i[0], u = i[1]), function (e, a, h) { var d, p, f, m, g, v, y, x, _, w = (h || t).length, S = s[w]; if (!S) { if (!(_ = "auto" === t.grid ? 0 : (t.grid || [1, b])[1])) { for (y = -b; y < (y = h[_++].getBoundingClientRect().left) && _ < w;); _-- } for (S = s[w] = [], d = o ? Math.min(_, w) * c - .5 : i % _, p = _ === b ? 0 : o ? w * u / _ - .5 : i / _ | 0, y = 0, x = b, v = 0; v < w; v++)f = v % _ - d, m = p - (v / _ | 0), S[v] = g = l ? Math.abs("y" === l ? m : f) : C(f * f + m * m), g > y && (y = g), g < x && (x = g); "random" === i && et(S), S.max = y - x, S.min = x, S.v = w = (parseFloat(t.amount) || parseFloat(t.each) * (_ > w ? w - 1 : l ? "y" === l ? w / _ : _ : Math.max(_, w / _)) || 0) * ("edges" === i ? -1 : 1), S.b = w < 0 ? r - w : r, S.u = Ze(t.amount || t.each) || 0, n = n && w < 0 ? Ct(n) : n } return w = (S[e] - S.min) / S.max || 0, fe(S.b + (n ? n(w) : w) * S.v) + S.u } }, nt = function (e) { var t = Math.pow(10, ((e + "").split(".")[1] || "").length); return function (n) { var i = Math.round(parseFloat(n) / e) * e * t; return (i - i % 1) / t + (R(n) ? 0 : Ze(n)) } }, it = function (e, t) { var n, i, r = B(e); return !r && I(e) && (n = r = e.radius || b, e.values ? (e = Qe(e.values), (i = !R(e[0])) && (n *= n)) : e = nt(e.increment)), Xe(t, r ? P(e) ? function (t) { return i = e(t), Math.abs(i - t) <= n ? i : t } : function (t) { for (var r, s, a = parseFloat(i ? t.x : t), o = parseFloat(i ? t.y : 0), l = b, c = 0, u = e.length; u--;)(r = i ? (r = e[u].x - a) * r + (s = e[u].y - o) * s : Math.abs(e[u] - a)) < l && (l = r, c = u); return c = !n || l <= n ? e[c] : t, i || c === t || R(t) ? c : c + Ze(t) } : nt(e)) }, rt = function (e, t, n, i) { return Xe(B(e) ? !t : !0 === n ? !!(n = 0) : !i, (function () { return B(e) ? e[~~(Math.random() * e.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((e - n / 2 + Math.random() * (t - e + .99 * n)) / n) * n * i) / i })) }, st = function (e, t, n) { return Xe(n, (function (n) { return e[~~t(n)] })) }, at = function (e) { for (var t, n, i, r, s = 0, a = ""; ~(t = e.indexOf("random(", s));)i = e.indexOf(")", t), r = "[" === e.charAt(t + 7), n = e.substr(t + 7, i - t - 7).match(r ? W : H), a += e.substr(s, t - s) + rt(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5), s = i + 1; return a + e.substr(s, e.length - s) }, ot = function (e, t, n, i, r) { var s = t - e, a = i - n; return Xe(r, (function (t) { return n + ((t - e) / s * a || 0) })) }, lt = function (e, t, n) { var i, r, s, a = e.labels, o = b; for (i in a) (r = a[i] - t) < 0 == !!n && r && o > (r = Math.abs(r)) && (s = i, o = r); return s }, ct = function (e, t, n) { var i, r, s = e.vars, a = s[t]; if (a) return i = s[t + "Params"], r = s.callbackScope || e, n && ne.length && ve(), i ? a.apply(r, i) : a.call(r) }, ut = function (e) { return De(e), e.scrollTrigger && e.scrollTrigger.kill(!1), e.progress() < 1 && ct(e, "onInterrupt"), e }, ht = function (e) { var t = (e = !e.name && e.default || e).name, n = P(e), i = t && !n && e.init ? function () { this._props = [] } : e, r = { init: ee, render: nn, add: Ht, kill: sn, modifier: rn, rawVars: 0 }, s = { targetTest: 0, get: 0, getSetter: Jt, aliases: {}, register: 0 }; if (bt(), e !== i) { if (re[t]) return; we(i, we(Ee(e, r), s)), be(i.prototype, be(r, Ee(e, s))), re[i.prop = t] = i, e.targetTest && (oe.push(i), te[t] = 1), t = ("css" === t ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin" } Q(t, i), e.register && e.register(dn, i, ln) }, dt = 255, pt = { aqua: [0, dt, dt], lime: [0, dt, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, dt], navy: [0, 0, 128], white: [dt, dt, dt], olive: [128, 128, 0], yellow: [dt, dt, 0], orange: [dt, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [dt, 0, 0], pink: [dt, 192, 203], cyan: [0, dt, dt], transparent: [dt, dt, dt, 0] }, ft = function (e, t, n) { return (6 * (e += e < 0 ? 1 : e > 1 ? -1 : 0) < 1 ? t + (n - t) * e * 6 : e < .5 ? n : 3 * e < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) * dt + .5 | 0 }, mt = function (e, t, n) { var i, r, s, a, o, l, c, u, h, d, p = e ? R(e) ? [e >> 16, e >> 8 & dt, e & dt] : 0 : pt.black; if (!p) { if ("," === e.substr(-1) && (e = e.substr(0, e.length - 1)), pt[e]) p = pt[e]; else if ("#" === e.charAt(0)) { if (e.length < 6 && (i = e.charAt(1), r = e.charAt(2), s = e.charAt(3), e = "#" + i + i + r + r + s + s + (5 === e.length ? e.charAt(4) + e.charAt(4) : "")), 9 === e.length) return [(p = parseInt(e.substr(1, 6), 16)) >> 16, p >> 8 & dt, p & dt, parseInt(e.substr(7), 16) / 255]; p = [(e = parseInt(e.substr(1), 16)) >> 16, e >> 8 & dt, e & dt] } else if ("hsl" === e.substr(0, 3)) if (p = d = e.match(H), t) { if (~e.indexOf("=")) return p = e.match(U), n && p.length < 4 && (p[3] = 1), p } else a = +p[0] % 360 / 360, o = +p[1] / 100, i = 2 * (l = +p[2] / 100) - (r = l <= .5 ? l * (o + 1) : l + o - l * o), p.length > 3 && (p[3] *= 1), p[0] = ft(a + 1 / 3, i, r), p[1] = ft(a, i, r), p[2] = ft(a - 1 / 3, i, r); else p = e.match(H) || pt.transparent; p = p.map(Number) } return t && !d && (i = p[0] / dt, r = p[1] / dt, s = p[2] / dt, l = ((c = Math.max(i, r, s)) + (u = Math.min(i, r, s))) / 2, c === u ? a = o = 0 : (h = c - u, o = l > .5 ? h / (2 - c - u) : h / (c + u), a = c === i ? (r - s) / h + (r < s ? 6 : 0) : c === r ? (s - i) / h + 2 : (i - r) / h + 4, a *= 60), p[0] = ~~(a + .5), p[1] = ~~(100 * o + .5), p[2] = ~~(100 * l + .5)), n && p.length < 4 && (p[3] = 1), p }, gt = function (e) { var t = [], n = [], i = -1; return e.split(yt).forEach((function (e) { var r = e.match(V) || []; t.push.apply(t, r), n.push(i += r.length + 1) })), t.c = n, t }, vt = function (e, t, n) { var i, r, s, a, o = "", l = (e + o).match(yt), c = t ? "hsla(" : "rgba(", u = 0; if (!l) return e; if (l = l.map((function (e) { return (e = mt(e, t, 1)) && c + (t ? e[0] + "," + e[1] + "%," + e[2] + "%," + e[3] : e.join(",")) + ")" })), n && (s = gt(e), (i = n.c).join(o) !== s.c.join(o))) for (a = (r = e.replace(yt, "1").split(V)).length - 1; u < a; u++)o += r[u] + (~i.indexOf(u) ? l.shift() || c + "0,0,0,0)" : (s.length ? s : l.length ? l : n).shift()); if (!r) for (a = (r = e.split(yt)).length - 1; u < a; u++)o += r[u] + l[u]; return o + r[a] }, yt = function () { var e, t = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b"; for (e in pt) t += "|" + e + "\\b"; return new RegExp(t + ")", "gi") }(), xt = /hsl[a]?\(/, _t = function (e) { var t, n = e.join(" "); if (yt.lastIndex = 0, yt.test(n)) return t = xt.test(n), e[1] = vt(e[1], t), e[0] = vt(e[0], t, gt(e[1])), !0 }, wt = function () { var e, t, n, i, r, s, a = Date.now, o = 500, l = 33, p = a(), f = p, g = 1e3 / 240, v = g, y = [], x = function n(c) { var u, h, d, m, x = a() - f, _ = !0 === c; if (x > o && (p += x - l), ((u = (d = (f += x) - p) - v) > 0 || _) && (m = ++i.frame, r = d - 1e3 * i.time, i.time = d /= 1e3, v += u + (u >= g ? 4 : g - u), h = 1), _ || (e = t(n)), h) for (s = 0; s < y.length; s++)y[s](d, r, m, c) }; return i = { time: 0, frame: 0, tick: function () { x(!0) }, deltaRatio: function (e) { return r / (1e3 / (e || 60)) }, wake: function () { d && (!u && z() && (c = u = window, h = c.document || {}, X.gsap = dn, (c.gsapVersions || (c.gsapVersions = [])).push(dn.version), Z(Y || c.GreenSockGlobals || !c.gsap && c || {}), n = c.requestAnimationFrame), e && i.sleep(), t = n || function (e) { return setTimeout(e, v - 1e3 * i.time + 1 | 0) }, m = 1, x(2)) }, sleep: function () { (n ? c.cancelAnimationFrame : clearTimeout)(e), m = 0, t = ee }, lagSmoothing: function (e, t) { o = e || 1e8, l = Math.min(t, o, 0) }, fps: function (e) { g = 1e3 / (e || 240), v = 1e3 * i.time + g }, add: function (e, t, n) { var r = t ? function (t, n, s, a) { e(t, n, s, a), i.remove(r) } : e; return i.remove(e), y[n ? "unshift" : "push"](r), bt(), r }, remove: function (e, t) { ~(t = y.indexOf(e)) && y.splice(t, 1) && s >= t && s-- }, _listeners: y } }(), bt = function () { return !m && wt.wake() }, St = {}, Et = /^[\d.\-M][\d.\-,\s]/, Mt = /["']/g, Tt = function (e) { for (var t, n, i, r = {}, s = e.substr(1, e.length - 3).split(":"), a = s[0], o = 1, l = s.length; o < l; o++)n = s[o], t = o !== l - 1 ? n.lastIndexOf(",") : n.length, i = n.substr(0, t), r[a] = isNaN(i) ? i.replace(Mt, "").trim() : +i, a = n.substr(t + 1).trim(); return r }, Ct = function (e) { return function (t) { return 1 - e(1 - t) } }, Dt = function e(t, n) { for (var i, r = t._first; r;)r instanceof zt ? e(r, n) : !r.vars.yoyoEase || r._yoyo && r._repeat || r._yoyo === n || (r.timeline ? e(r.timeline, n) : (i = r._ease, r._ease = r._yEase, r._yEase = i, r._yoyo = n)), r = r._next }, Lt = function (e, t) { return e && (P(e) ? e : St[e] || function (e) { var t, n, i, r, s = (e + "").split("("), a = St[s[0]]; return a && s.length > 1 && a.config ? a.config.apply(null, ~e.indexOf("{") ? [Tt(s[1])] : (t = e, n = t.indexOf("(") + 1, i = t.indexOf(")"), r = t.indexOf("(", n), t.substring(n, ~r && r < i ? t.indexOf(")", i + 1) : i)).split(",").map(xe)) : St._CE && Et.test(e) ? St._CE("", e) : a }(e)) || t }, At = function (e, t, n, i) { void 0 === n && (n = function (e) { return 1 - t(1 - e) }), void 0 === i && (i = function (e) { return e < .5 ? t(2 * e) / 2 : 1 - t(2 * (1 - e)) / 2 }); var r, s = { easeIn: t, easeOut: n, easeInOut: i }; return de(e, (function (e) { for (var t in St[e] = X[e] = s, St[r = e.toLowerCase()] = n, s) St[r + ("easeIn" === t ? ".in" : "easeOut" === t ? ".out" : ".inOut")] = St[e + "." + t] = s[t] })), s }, Pt = function (e) { return function (t) { return t < .5 ? (1 - e(1 - 2 * t)) / 2 : .5 + e(2 * (t - .5)) / 2 } }, Rt = function e(t, n, i) { var r = n >= 1 ? n : 1, s = (i || (t ? .3 : .45)) / (n < 1 ? n : 1), a = s / E * (Math.asin(1 / r) || 0), o = function (e) { return 1 === e ? 1 : r * Math.pow(2, -10 * e) * L((e - a) * s) + 1 }, l = "out" === t ? o : "in" === t ? function (e) { return 1 - o(1 - e) } : Pt(o); return s = E / s, l.config = function (n, i) { return e(t, n, i) }, l }, Ot = function e(t, n) { void 0 === n && (n = 1.70158); var i = function (e) { return e ? --e * e * ((n + 1) * e + n) + 1 : 0 }, r = "out" === t ? i : "in" === t ? function (e) { return 1 - i(1 - e) } : Pt(i); return r.config = function (n) { return e(t, n) }, r }; de("Linear,Quad,Cubic,Quart,Quint,Strong", (function (e, t) { var n = t < 5 ? t + 1 : t; At(e + ",Power" + (n - 1), t ? function (e) { return Math.pow(e, n) } : function (e) { return e }, (function (e) { return 1 - Math.pow(1 - e, n) }), (function (e) { return e < .5 ? Math.pow(2 * e, n) / 2 : 1 - Math.pow(2 * (1 - e), n) / 2 })) })), St.Linear.easeNone = St.none = St.Linear.easeIn, At("Elastic", Rt("in"), Rt("out"), Rt()), g = 7.5625, y = 1 / (v = 2.75), At("Bounce", (function (e) { return 1 - x(1 - e) }), x = function (e) { return e < y ? g * e * e : e < .7272727272727273 ? g * Math.pow(e - 1.5 / v, 2) + .75 : e < .9090909090909092 ? g * (e -= 2.25 / v) * e + .9375 : g * Math.pow(e - 2.625 / v, 2) + .984375 }), At("Expo", (function (e) { return e ? Math.pow(2, 10 * (e - 1)) : 0 })), At("Circ", (function (e) { return -(C(1 - e * e) - 1) })), At("Sine", (function (e) { return 1 === e ? 1 : 1 - D(e * M) })), At("Back", Ot("in"), Ot("out"), Ot()), St.SteppedEase = St.steps = X.SteppedEase = { config: function (e, t) { void 0 === e && (e = 1); var n = 1 / e, i = e + (t ? 0 : 1), r = t ? 1 : 0; return function (e) { return ((i * Ye(0, .99999999, e) | 0) + r) * n } } }, w.ease = St["quad.out"], de("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function (e) { return le += e + "," + e + "Params," })); var It = function (e, t) { this.id = T++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : he, this.set = t ? t.getSetter : Jt }, Ft = function () { function e(e) { this.vars = e, this._delay = +e.delay || 0, (this._repeat = e.repeat === 1 / 0 ? -2 : e.repeat || 0) && (this._rDelay = e.repeatDelay || 0, this._yoyo = !!e.yoyo || !!e.yoyoEase), this._ts = 1, Ge(this, +e.duration, 1, 1), this.data = e.data, m || wt.wake() } var t = e.prototype; return t.delay = function (e) { return e || 0 === e ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + e - this._delay), this._delay = e, this) : this._delay }, t.duration = function (e) { return arguments.length ? this.totalDuration(this._repeat > 0 ? e + (e + this._rDelay) * this._repeat : e) : this.totalDuration() && this._dur }, t.totalDuration = function (e) { return arguments.length ? (this._dirty = 0, Ge(this, this._repeat < 0 ? e : (e - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur }, t.totalTime = function (e, t) { if (bt(), !arguments.length) return this._tTime; var n = this._dp; if (n && n.smoothChildTiming && this._ts) { for (ze(this, e), !n._dp || n.parent || ke(n, this); n && n.parent;)n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0), n = n.parent; !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && e < this._tDur || this._ts < 0 && e > 0 || !this._tDur && !e) && Ne(this._dp, this, this._start - this._delay) } return (this._tTime !== e || !this._dur && !t || this._initted && Math.abs(this._zTime) === S || !e && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = e), ye(this, e, t)), this }, t.time = function (e, t) { return arguments.length ? this.totalTime(Math.min(this.totalDuration(), e + Re(this)) % (this._dur + this._rDelay) || (e ? this._dur : 0), t) : this._time }, t.totalProgress = function (e, t) { return arguments.length ? this.totalTime(this.totalDuration() * e, t) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio }, t.progress = function (e, t) { return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? e : 1 - e) + Re(this), t) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio }, t.iteration = function (e, t) { var n = this.duration() + this._rDelay; return arguments.length ? this.totalTime(this._time + (e - 1) * n, t) : this._repeat ? Oe(this._tTime, n) + 1 : 1 }, t.timeScale = function (e) { if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts; if (this._rts === e) return this; var t = this.parent && this._ts ? Ie(this.parent._time, this) : this._tTime; return this._rts = +e || 0, this._ts = this._ps || -1e-8 === e ? 0 : this._rts, this.totalTime(Ye(-this._delay, this._tDur, t), !0), Fe(this), Ae(this) }, t.paused = function (e) { return arguments.length ? (this._ps !== e && (this._ps = e, e ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (bt(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== S && (this._tTime -= S)))), this) : this._ps }, t.startTime = function (e) { if (arguments.length) { this._start = e; var t = this.parent || this._dp; return t && (t._sort || !this.parent) && Ne(t, this, e - this._delay), this } return this._start }, t.endTime = function (e) { return this._start + (F(e) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1) }, t.rawTime = function (e) { var t = this.parent || this._dp; return t ? e && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Ie(t.rawTime(e), this) : this._tTime : this._tTime }, t.globalTime = function (e) { for (var t = this, n = arguments.length ? e : t.rawTime(); t;)n = t._start + n / (t._ts || 1), t = t._dp; return n }, t.repeat = function (e) { return arguments.length ? (this._repeat = e === 1 / 0 ? -2 : e, je(this)) : -2 === this._repeat ? 1 / 0 : this._repeat }, t.repeatDelay = function (e) { if (arguments.length) { var t = this._time; return this._rDelay = e, je(this), t ? this.time(t) : this } return this._rDelay }, t.yoyo = function (e) { return arguments.length ? (this._yoyo = e, this) : this._yoyo }, t.seek = function (e, t) { return this.totalTime(qe(this, e), F(t)) }, t.restart = function (e, t) { return this.play().totalTime(e ? -this._delay : 0, F(t)) }, t.play = function (e, t) { return null != e && this.seek(e, t), this.reversed(!1).paused(!1) }, t.reverse = function (e, t) { return null != e && this.seek(e || this.totalDuration(), t), this.reversed(!0).paused(!1) }, t.pause = function (e, t) { return null != e && this.seek(e, t), this.paused(!0) }, t.resume = function () { return this.paused(!1) }, t.reversed = function (e) { return arguments.length ? (!!e !== this.reversed() && this.timeScale(-this._rts || (e ? -1e-8 : 0)), this) : this._rts < 0 }, t.invalidate = function () { return this._initted = this._act = 0, this._zTime = -1e-8, this }, t.isActive = function () { var e, t = this.parent || this._dp, n = this._start; return !(t && !(this._ts && this._initted && t.isActive() && (e = t.rawTime(!0)) >= n && e < this.endTime(!0) - S)) }, t.eventCallback = function (e, t, n) { var i = this.vars; return arguments.length > 1 ? (t ? (i[e] = t, n && (i[e + "Params"] = n), "onUpdate" === e && (this._onUpdate = t)) : delete i[e], this) : i[e] }, t.then = function (e) { var t = this; return new Promise((function (n) { var i = P(e) ? e : _e, r = function () { var e = t.then; t.then = null, P(i) && (i = i(t)) && (i.then || i === t) && (t.then = e), n(i), t.then = e }; t._initted && 1 === t.totalProgress() && t._ts >= 0 || !t._tTime && t._ts < 0 ? r() : t._prom = r })) }, t.kill = function () { ut(this) }, e }(); we(Ft.prototype, { _time: 0, _start: 0, _end: 0, _tTime: 0, _tDur: 0, _dirty: 0, _repeat: 0, _yoyo: !1, parent: null, _initted: !1, _rDelay: 0, _ts: 1, _dp: 0, ratio: 0, _zTime: -1e-8, _prom: 0, _ps: !1, _rts: 1 }); var zt = function (e) { function t(t, n) { var i; return void 0 === t && (t = {}), (i = e.call(this, t) || this).labels = {}, i.smoothChildTiming = !!t.smoothChildTiming, i.autoRemoveChildren = !!t.autoRemoveChildren, i._sort = F(t.sortChildren), l && Ne(t.parent || l, s(i), n), t.reversed && i.reverse(), t.paused && i.paused(!0), t.scrollTrigger && Be(s(i), t.scrollTrigger), i } a(t, e); var n = t.prototype; return n.to = function (e, t, n) { return $e(0, arguments, this), this }, n.from = function (e, t, n) { return $e(1, arguments, this), this }, n.fromTo = function (e, t, n, i) { return $e(2, arguments, this), this }, n.set = function (e, t, n) { return t.duration = 0, t.parent = this, Me(t).repeatDelay || (t.repeat = 0), t.immediateRender = !!t.immediateRender, new $t(e, t, qe(this, n), 1), this }, n.call = function (e, t, n) { return Ne(this, $t.delayedCall(0, e, t), n) }, n.staggerTo = function (e, t, n, i, r, s, a) { return n.duration = t, n.stagger = n.stagger || i, n.onComplete = s, n.onCompleteParams = a, n.parent = this, new $t(e, n, qe(this, r)), this }, n.staggerFrom = function (e, t, n, i, r, s, a) { return n.runBackwards = 1, Me(n).immediateRender = F(n.immediateRender), this.staggerTo(e, t, n, i, r, s, a) }, n.staggerFromTo = function (e, t, n, i, r, s, a, o) { return i.startAt = n, Me(i).immediateRender = F(i.immediateRender), this.staggerTo(e, t, i, r, s, a, o) }, n.render = function (e, t, n) { var i, r, s, a, o, c, u, h, d, p, f, m, g = this._time, v = this._dirty ? this.totalDuration() : this._tDur, y = this._dur, x = e <= 0 ? 0 : fe(e), _ = this._zTime < 0 != e < 0 && (this._initted || !y); if (this !== l && x > v && e >= 0 && (x = v), x !== this._tTime || n || _) { if (g !== this._time && y && (x += this._time - g, e += this._time - g), i = x, d = this._start, c = !(h = this._ts), _ && (y || (g = this._zTime), (e || !t) && (this._zTime = e)), this._repeat) { if (f = this._yoyo, o = y + this._rDelay, this._repeat < -1 && e < 0) return this.totalTime(100 * o + e, t, n); if (i = fe(x % o), x === v ? (a = this._repeat, i = y) : ((a = ~~(x / o)) && a === x / o && (i = y, a--), i > y && (i = y)), p = Oe(this._tTime, o), !g && this._tTime && p !== a && (p = a), f && 1 & a && (i = y - i, m = 1), a !== p && !this._lock) { var w = f && 1 & p, b = w === (f && 1 & a); if (a < p && (w = !w), g = w ? 0 : y, this._lock = 1, this.render(g || (m ? 0 : fe(a * o)), t, !y)._lock = 0, this._tTime = x, !t && this.parent && ct(this, "onRepeat"), this.vars.repeatRefresh && !m && (this.invalidate()._lock = 1), g && g !== this._time || c !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this; if (y = this._dur, v = this._tDur, b && (this._lock = 2, g = w ? y : -1e-4, this.render(g, !0), this.vars.repeatRefresh && !m && this.invalidate()), this._lock = 0, !this._ts && !c) return this; Dt(this, m) } } if (this._hasPause && !this._forcing && this._lock < 2 && (u = function (e, t, n) { var i; if (n > t) for (i = e._first; i && i._start <= n;) { if ("isPause" === i.data && i._start > t) return i; i = i._next } else for (i = e._last; i && i._start >= n;) { if ("isPause" === i.data && i._start < t) return i; i = i._prev } }(this, fe(g), fe(i)), u && (x -= i - (i = u._start))), this._tTime = x, this._time = i, this._act = !h, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = e, g = 0), !g && i && !t && (ct(this, "onStart"), this._tTime !== x)) return this; if (i >= g && e >= 0) for (r = this._first; r;) { if (s = r._next, (r._act || i >= r._start) && r._ts && u !== r) { if (r.parent !== this) return this.render(e, t, n); if (r.render(r._ts > 0 ? (i - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (i - r._start) * r._ts, t, n), i !== this._time || !this._ts && !c) { u = 0, s && (x += this._zTime = -1e-8); break } } r = s } else { r = this._last; for (var E = e < 0 ? e : i; r;) { if (s = r._prev, (r._act || E <= r._end) && r._ts && u !== r) { if (r.parent !== this) return this.render(e, t, n); if (r.render(r._ts > 0 ? (E - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (E - r._start) * r._ts, t, n), i !== this._time || !this._ts && !c) { u = 0, s && (x += this._zTime = E ? -1e-8 : S); break } } r = s } } if (u && !t && (this.pause(), u.render(i >= g ? 0 : -1e-8)._zTime = i >= g ? 1 : -1, this._ts)) return this._start = d, Fe(this), this.render(e, t, n); this._onUpdate && !t && ct(this, "onUpdate", !0), (x === v && this._tTime >= this.totalDuration() || !x && g) && (d !== this._start && Math.abs(h) === Math.abs(this._ts) || this._lock || ((e || !y) && (x === v && this._ts > 0 || !x && this._ts < 0) && De(this, 1), t || e < 0 && !g || !x && !g && v || (ct(this, x === v && e >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(x < v && this.timeScale() > 0) && this._prom()))) } return this }, n.add = function (e, t) { var n = this; if (R(t) || (t = qe(this, t, e)), !(e instanceof Ft)) { if (B(e)) return e.forEach((function (e) { return n.add(e, t) })), this; if (A(e)) return this.addLabel(e, t); if (!P(e)) return this; e = $t.delayedCall(0, e) } return this !== e ? Ne(this, e, t) : this }, n.getChildren = function (e, t, n, i) { void 0 === e && (e = !0), void 0 === t && (t = !0), void 0 === n && (n = !0), void 0 === i && (i = -b); for (var r = [], s = this._first; s;)s._start >= i && (s instanceof $t ? t && r.push(s) : (n && r.push(s), e && r.push.apply(r, s.getChildren(!0, t, n)))), s = s._next; return r }, n.getById = function (e) { for (var t = this.getChildren(1, 1, 1), n = t.length; n--;)if (t[n].vars.id === e) return t[n] }, n.remove = function (e) { return A(e) ? this.removeLabel(e) : P(e) ? this.killTweensOf(e) : (Ce(this, e), e === this._recent && (this._recent = this._last), Le(this)) }, n.totalTime = function (t, n) { return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = fe(wt.time - (this._ts > 0 ? t / this._ts : (this.totalDuration() - t) / -this._ts))), e.prototype.totalTime.call(this, t, n), this._forcing = 0, this) : this._tTime }, n.addLabel = function (e, t) { return this.labels[e] = qe(this, t), this }, n.removeLabel = function (e) { return delete this.labels[e], this }, n.addPause = function (e, t, n) { var i = $t.delayedCall(0, t || ee, n); return i.data = "isPause", this._hasPause = 1, Ne(this, i, qe(this, e)) }, n.removePause = function (e) { var t = this._first; for (e = qe(this, e); t;)t._start === e && "isPause" === t.data && De(t), t = t._next }, n.killTweensOf = function (e, t, n) { for (var i = this.getTweensOf(e, n), r = i.length; r--;)kt !== i[r] && i[r].kill(e, t); return this }, n.getTweensOf = function (e, t) { for (var n, i = [], r = Qe(e), s = this._first, a = R(t); s;)s instanceof $t ? ge(s._targets, r) && (a ? (!kt || s._initted && s._ts) && s.globalTime(0) <= t && s.globalTime(s.totalDuration()) > t : !t || s.isActive()) && i.push(s) : (n = s.getTweensOf(r, t)).length && i.push.apply(i, n), s = s._next; return i }, n.tweenTo = function (e, t) { t = t || {}; var n, i = this, r = qe(i, e), s = t, a = s.startAt, o = s.onStart, l = s.onStartParams, c = s.immediateRender, u = $t.to(i, we({ ease: t.ease || "none", lazy: !1, immediateRender: !1, time: r, overwrite: "auto", duration: t.duration || Math.abs((r - (a && "time" in a ? a.time : i._time)) / i.timeScale()) || S, onStart: function () { if (i.pause(), !n) { var e = t.duration || Math.abs((r - (a && "time" in a ? a.time : i._time)) / i.timeScale()); u._dur !== e && Ge(u, e, 0, 1).render(u._time, !0, !0), n = 1 } o && o.apply(u, l || []) } }, t)); return c ? u.render(0) : u }, n.tweenFromTo = function (e, t, n) { return this.tweenTo(t, we({ startAt: { time: qe(this, e) } }, n)) }, n.recent = function () { return this._recent }, n.nextLabel = function (e) { return void 0 === e && (e = this._time), lt(this, qe(this, e)) }, n.previousLabel = function (e) { return void 0 === e && (e = this._time), lt(this, qe(this, e), 1) }, n.currentLabel = function (e) { return arguments.length ? this.seek(e, !0) : this.previousLabel(this._time + S) }, n.shiftChildren = function (e, t, n) { void 0 === n && (n = 0); for (var i, r = this._first, s = this.labels; r;)r._start >= n && (r._start += e, r._end += e), r = r._next; if (t) for (i in s) s[i] >= n && (s[i] += e); return Le(this) }, n.invalidate = function () { var t = this._first; for (this._lock = 0; t;)t.invalidate(), t = t._next; return e.prototype.invalidate.call(this) }, n.clear = function (e) { void 0 === e && (e = !0); for (var t, n = this._first; n;)t = n._next, this.remove(n), n = t; return this._dp && (this._time = this._tTime = this._pTime = 0), e && (this.labels = {}), Le(this) }, n.totalDuration = function (e) { var t, n, i, r = 0, s = this, a = s._last, o = b; if (arguments.length) return s.timeScale((s._repeat < 0 ? s.duration() : s.totalDuration()) / (s.reversed() ? -e : e)); if (s._dirty) { for (i = s.parent; a;)t = a._prev, a._dirty && a.totalDuration(), (n = a._start) > o && s._sort && a._ts && !s._lock ? (s._lock = 1, Ne(s, a, n - a._delay, 1)._lock = 0) : o = n, n < 0 && a._ts && (r -= n, (!i && !s._dp || i && i.smoothChildTiming) && (s._start += n / s._ts, s._time -= n, s._tTime -= n), s.shiftChildren(-n, !1, -Infinity), o = 0), a._end > r && a._ts && (r = a._end), a = t; Ge(s, s === l && s._time > r ? s._time : r, 1, 1), s._dirty = 0 } return s._tDur }, t.updateRoot = function (e) { if (l._ts && (ye(l, Ie(e, l)), p = wt.frame), wt.frame >= ae) { ae += _.autoSleep || 120; var t = l._first; if ((!t || !t._ts) && _.autoSleep && wt._listeners.length < 2) { for (; t && !t._ts;)t = t._next; t || wt.sleep() } } }, t }(Ft); we(zt.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 }); var kt, Nt, Bt = function (e, t, n, i, r, s, a) { var o, l, c, u, h, d, p, f, m = new ln(this._pt, e, t, 0, 1, tn, null, r), g = 0, v = 0; for (m.b = n, m.e = i, n += "", (p = ~(i += "").indexOf("random(")) && (i = at(i)), s && (s(f = [n, i], e, t), n = f[0], i = f[1]), l = n.match(G) || []; o = G.exec(i);)u = o[0], h = i.substring(g, o.index), c ? c = (c + 1) % 5 : "rgba(" === h.substr(-5) && (c = 1), u !== l[v++] && (d = parseFloat(l[v - 1]) || 0, m._pt = { _next: m._pt, p: h || 1 === v ? h : ",", s: d, c: "=" === u.charAt(1) ? me(d, u) - d : parseFloat(u) - d, m: c && c < 4 ? Math.round : 0 }, g = G.lastIndex); return m.c = g < i.length ? i.substring(g, i.length) : "", m.fp = a, (j.test(i) || p) && (m.e = 0), this._pt = m, m }, Ht = function (e, t, n, i, r, s, a, o, l) { P(i) && (i = i(r || 0, e, s)); var c, u = e[t], h = "get" !== n ? n : P(u) ? l ? e[t.indexOf("set") || !P(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](l) : e[t]() : u, d = P(u) ? l ? Zt : Yt : Xt; if (A(i) && (~i.indexOf("random(") && (i = at(i)), "=" === i.charAt(1) && ((c = me(h, i) + (Ze(h) || 0)) || 0 === c) && (i = c)), h !== i || Nt) return isNaN(h * i) || "" === i ? (!u && !(t in e) && K(t, i), Bt.call(this, e, t, h, i, d, o || _.stringFilter, l)) : (c = new ln(this._pt, e, t, +h || 0, i - (h || 0), "boolean" == typeof u ? en : Qt, 0, d), l && (c.fp = l), a && c.modifier(a, this, e), this._pt = c) }, Ut = function (e, t, n, i, r, s) { var a, o, l, c; if (re[e] && !1 !== (a = new re[e]).init(r, a.rawVars ? t[e] : function (e, t, n, i, r) { if (P(e) && (e = jt(e, r, t, n, i)), !I(e) || e.style && e.nodeType || B(e) || N(e)) return A(e) ? jt(e, r, t, n, i) : e; var s, a = {}; for (s in e) a[s] = jt(e[s], r, t, n, i); return a }(t[e], i, r, s, n), n, i, s) && (n._pt = o = new ln(n._pt, r, e, 0, 1, a.render, a, 0, a.priority), n !== f)) for (l = n._ptLookup[n._targets.indexOf(r)], c = a._props.length; c--;)l[a._props[c]] = o; return a }, Vt = function e(t, n) { var i, r, s, a, c, u, h, d, p, f, m, g, v, y = t.vars, x = y.ease, _ = y.startAt, E = y.immediateRender, M = y.lazy, T = y.onUpdate, C = y.onUpdateParams, D = y.callbackScope, L = y.runBackwards, A = y.yoyoEase, P = y.keyframes, R = y.autoRevert, O = t._dur, I = t._startAt, z = t._targets, k = t.parent, N = k && "nested" === k.data ? k.parent._targets : z, B = "auto" === t._overwrite && !o, H = t.timeline; if (H && (!P || !x) && (x = "none"), t._ease = Lt(x, w.ease), t._yEase = A ? Ct(Lt(!0 === A ? x : A, w.ease)) : 0, A && t._yoyo && !t._repeat && (A = t._yEase, t._yEase = t._ease, t._ease = A), t._from = !H && !!y.runBackwards, !H || P && !y.stagger) { if (g = (d = z[0] ? ue(z[0]).harness : 0) && y[d.prop], i = Ee(y, te), I && (De(I.render(-1, !0)), I._lazy = 0), _) if (De(t._startAt = $t.set(z, we({ data: "isStart", overwrite: !1, parent: k, immediateRender: !0, lazy: F(M), startAt: null, delay: 0, onUpdate: T, onUpdateParams: C, callbackScope: D, stagger: 0 }, _))), n < 0 && !E && !R && t._startAt.render(-1, !0), E) { if (n > 0 && !R && (t._startAt = 0), O && n <= 0) return void (n && (t._zTime = n)) } else !1 === R && (t._startAt = 0); else if (L && O) if (I) !R && (t._startAt = 0); else if (n && (E = !1), s = we({ overwrite: !1, data: "isFromStart", lazy: E && F(M), immediateRender: E, stagger: 0, parent: k }, i), g && (s[d.prop] = g), De(t._startAt = $t.set(z, s)), n < 0 && t._startAt.render(-1, !0), t._zTime = n, E) { if (!n) return } else e(t._startAt, S); for (t._pt = t._ptCache = 0, M = O && F(M) || M && !O, r = 0; r < z.length; r++) { if (h = (c = z[r])._gsap || ce(z)[r]._gsap, t._ptLookup[r] = f = {}, ie[h.id] && ne.length && ve(), m = N === z ? r : N.indexOf(c), d && !1 !== (p = new d).init(c, g || i, t, m, N) && (t._pt = a = new ln(t._pt, c, p.name, 0, 1, p.render, p, 0, p.priority), p._props.forEach((function (e) { f[e] = a })), p.priority && (u = 1)), !d || g) for (s in i) re[s] && (p = Ut(s, i, t, m, c, N)) ? p.priority && (u = 1) : f[s] = a = Ht.call(t, c, s, "get", i[s], m, N, 0, y.stringFilter); t._op && t._op[r] && t.kill(c, t._op[r]), B && t._pt && (kt = t, l.killTweensOf(c, f, t.globalTime(n)), v = !t.parent, kt = 0), t._pt && M && (ie[h.id] = 1) } u && on(t), t._onInit && t._onInit(t) } t._onUpdate = T, t._initted = (!t._op || t._pt) && !v, P && n <= 0 && H.render(b, !0, !0) }, Gt = function (e, t, n, i) { var r, s, a = t.ease || i || "power1.inOut"; if (B(t)) s = n[e] || (n[e] = []), t.forEach((function (e, n) { return s.push({ t: n / (t.length - 1) * 100, v: e, e: a }) })); else for (r in t) s = n[r] || (n[r] = []), "ease" === r || s.push({ t: parseFloat(e), v: t[r], e: a }) }, jt = function (e, t, n, i, r) { return P(e) ? e.call(t, n, i, r) : A(e) && ~e.indexOf("random(") ? at(e) : e }, Wt = le + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", qt = {}; de(Wt + ",id,stagger,delay,duration,paused,scrollTrigger", (function (e) { return qt[e] = 1 })); var $t = function (e) { function t(t, n, i, r) { var a; "number" == typeof n && (i.duration = n, n = i, i = null); var c, u, h, d, p, f, m, g, v = (a = e.call(this, r ? n : Me(n)) || this).vars, y = v.duration, x = v.delay, w = v.immediateRender, b = v.stagger, S = v.overwrite, E = v.keyframes, M = v.defaults, T = v.scrollTrigger, C = v.yoyoEase, D = n.parent || l, L = (B(t) || N(t) ? R(t[0]) : "length" in n) ? [t] : Qe(t); if (a._targets = L.length ? ce(L) : J("GSAP target " + t + " not found. https://greensock.com", !_.nullTargetWarn) || [], a._ptLookup = [], a._overwrite = S, E || b || k(y) || k(x)) { if (n = a.vars, (c = a.timeline = new zt({ data: "nested", defaults: M || {} })).kill(), c.parent = c._dp = s(a), c._start = 0, b || k(y) || k(x)) { if (d = L.length, m = b && tt(b), I(b)) for (p in b) ~Wt.indexOf(p) && (g || (g = {}), g[p] = b[p]); for (u = 0; u < d; u++)(h = Ee(n, qt)).stagger = 0, C && (h.yoyoEase = C), g && be(h, g), f = L[u], h.duration = +jt(y, s(a), u, f, L), h.delay = (+jt(x, s(a), u, f, L) || 0) - a._delay, !b && 1 === d && h.delay && (a._delay = x = h.delay, a._start += x, h.delay = 0), c.to(f, h, m ? m(u, f, L) : 0), c._ease = St.none; c.duration() ? y = x = 0 : a.timeline = 0 } else if (E) { Me(we(c.vars.defaults, { ease: "none" })), c._ease = Lt(E.ease || n.ease || "none"); var A, P, O, z = 0; if (B(E)) E.forEach((function (e) { return c.to(L, e, ">") })); else { for (p in h = {}, E) "ease" === p || "easeEach" === p || Gt(p, E[p], h, E.easeEach); for (p in h) for (A = h[p].sort((function (e, t) { return e.t - t.t })), z = 0, u = 0; u < A.length; u++)(O = { ease: (P = A[u]).e, duration: (P.t - (u ? A[u - 1].t : 0)) / 100 * y })[p] = P.v, c.to(L, O, z), z += O.duration; c.duration() < y && c.to({}, { duration: y - c.duration() }) } } y || a.duration(y = c.duration()) } else a.timeline = 0; return !0 !== S || o || (kt = s(a), l.killTweensOf(L), kt = 0), Ne(D, s(a), i), n.reversed && a.reverse(), n.paused && a.paused(!0), (w || !y && !E && a._start === fe(D._time) && F(w) && Pe(s(a)) && "nested" !== D.data) && (a._tTime = -1e-8, a.render(Math.max(0, -x))), T && Be(s(a), T), a } a(t, e); var n = t.prototype; return n.render = function (e, t, n) { var i, r, s, a, o, l, c, u, h, d = this._time, p = this._tDur, f = this._dur, m = e > p - S && e >= 0 ? p : e < S ? 0 : e; if (f) { if (m !== this._tTime || !e || n || !this._initted && this._tTime || this._startAt && this._zTime < 0 != e < 0) { if (i = m, u = this.timeline, this._repeat) { if (a = f + this._rDelay, this._repeat < -1 && e < 0) return this.totalTime(100 * a + e, t, n); if (i = fe(m % a), m === p ? (s = this._repeat, i = f) : ((s = ~~(m / a)) && s === m / a && (i = f, s--), i > f && (i = f)), (l = this._yoyo && 1 & s) && (h = this._yEase, i = f - i), o = Oe(this._tTime, a), i === d && !n && this._initted) return this._tTime = m, this; s !== o && (u && this._yEase && Dt(u, l), !this.vars.repeatRefresh || l || this._lock || (this._lock = n = 1, this.render(fe(a * s), !0).invalidate()._lock = 0)) } if (!this._initted) { if (He(this, e < 0 ? e : i, n, t)) return this._tTime = 0, this; if (d !== this._time) return this; if (f !== this._dur) return this.render(e, t, n) } if (this._tTime = m, this._time = i, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = c = (h || this._ease)(i / f), this._from && (this.ratio = c = 1 - c), i && !d && !t && (ct(this, "onStart"), this._tTime !== m)) return this; for (r = this._pt; r;)r.r(c, r.d), r = r._next; u && u.render(e < 0 ? e : !i && l ? -1e-8 : u._dur * u._ease(i / this._dur), t, n) || this._startAt && (this._zTime = e), this._onUpdate && !t && (e < 0 && this._startAt && this._startAt.render(e, !0, n), ct(this, "onUpdate")), this._repeat && s !== o && this.vars.onRepeat && !t && this.parent && ct(this, "onRepeat"), m !== this._tDur && m || this._tTime !== m || (e < 0 && this._startAt && !this._onUpdate && this._startAt.render(e, !0, !0), (e || !f) && (m === this._tDur && this._ts > 0 || !m && this._ts < 0) && De(this, 1), t || e < 0 && !d || !m && !d || (ct(this, m === p ? "onComplete" : "onReverseComplete", !0), this._prom && !(m < p && this.timeScale() > 0) && this._prom())) } } else !function (e, t, n, i) { var r, s, a, o = e.ratio, l = t < 0 || !t && (!e._start && Ue(e) && (e._initted || !Ve(e)) || (e._ts < 0 || e._dp._ts < 0) && !Ve(e)) ? 0 : 1, c = e._rDelay, u = 0; if (c && e._repeat && (u = Ye(0, e._tDur, t), s = Oe(u, c), e._yoyo && 1 & s && (l = 1 - l), s !== Oe(e._tTime, c) && (o = 1 - l, e.vars.repeatRefresh && e._initted && e.invalidate())), l !== o || i || e._zTime === S || !t && e._zTime) { if (!e._initted && He(e, t, i, n)) return; for (a = e._zTime, e._zTime = t || (n ? S : 0), n || (n = t && !a), e.ratio = l, e._from && (l = 1 - l), e._time = 0, e._tTime = u, r = e._pt; r;)r.r(l, r.d), r = r._next; e._startAt && t < 0 && e._startAt.render(t, !0, !0), e._onUpdate && !n && ct(e, "onUpdate"), u && e._repeat && !n && e.parent && ct(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === l && (l && De(e, 1), n || (ct(e, l ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom())) } else e._zTime || (e._zTime = t) }(this, e, t, n); return this }, n.targets = function () { return this._targets }, n.invalidate = function () { return this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(), e.prototype.invalidate.call(this) }, n.resetTo = function (e, t, n, i) { m || wt.wake(), this._ts || this.play(); var r = Math.min(this._dur, (this._dp._time - this._start) * this._ts); return this._initted || Vt(this, r), function (e, t, n, i, r, s, a) { var o, l, c, u = (e._pt && e._ptCache || (e._ptCache = {}))[t]; if (!u) for (u = e._ptCache[t] = [], l = e._ptLookup, c = e._targets.length; c--;) { if ((o = l[c][t]) && o.d && o.d._pt) for (o = o.d._pt; o && o.p !== t;)o = o._next; if (!o) return Nt = 1, e.vars[t] = "+=0", Vt(e, a), Nt = 0, 1; u.push(o) } for (c = u.length; c--;)(o = u[c]).s = !i && 0 !== i || r ? o.s + (i || 0) + s * o.c : i, o.c = n - o.s, o.e && (o.e = pe(n) + Ze(o.e)), o.b && (o.b = o.s + Ze(o.b)) }(this, e, t, n, i, this._ease(r / this._dur), r) ? this.resetTo(e, t, n, i) : (ze(this, 0), this.parent || Te(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0)) }, n.kill = function (e, t) { if (void 0 === t && (t = "all"), !(e || t && "all" !== t)) return this._lazy = this._pt = 0, this.parent ? ut(this) : this; if (this.timeline) { var n = this.timeline.totalDuration(); return this.timeline.killTweensOf(e, t, kt && !0 !== kt.vars.overwrite)._first || ut(this), this.parent && n !== this.timeline.totalDuration() && Ge(this, this._dur * this.timeline._tDur / n, 0, 1), this } var i, r, s, a, o, l, c, u = this._targets, h = e ? Qe(e) : u, d = this._ptLookup, p = this._pt; if ((!t || "all" === t) && function (e, t) { for (var n = e.length, i = n === t.length; i && n-- && e[n] === t[n];); return n < 0 }(u, h)) return "all" === t && (this._pt = 0), ut(this); for (i = this._op = this._op || [], "all" !== t && (A(t) && (o = {}, de(t, (function (e) { return o[e] = 1 })), t = o), t = function (e, t) { var n, i, r, s, a = e[0] ? ue(e[0]).harness : 0, o = a && a.aliases; if (!o) return t; for (i in n = be({}, t), o) if (i in n) for (r = (s = o[i].split(",")).length; r--;)n[s[r]] = n[i]; return n }(u, t)), c = u.length; c--;)if (~h.indexOf(u[c])) for (o in r = d[c], "all" === t ? (i[c] = t, a = r, s = {}) : (s = i[c] = i[c] || {}, a = t), a) (l = r && r[o]) && ("kill" in l.d && !0 !== l.d.kill(o) || Ce(this, l, "_pt"), delete r[o]), "all" !== s && (s[o] = 1); return this._initted && !this._pt && p && ut(this), this }, t.to = function (e, n) { return new t(e, n, arguments[2]) }, t.from = function (e, t) { return $e(1, arguments) }, t.delayedCall = function (e, n, i, r) { return new t(n, 0, { immediateRender: !1, lazy: !1, overwrite: !1, delay: e, onComplete: n, onReverseComplete: n, onCompleteParams: i, onReverseCompleteParams: i, callbackScope: r }) }, t.fromTo = function (e, t, n) { return $e(2, arguments) }, t.set = function (e, n) { return n.duration = 0, n.repeatDelay || (n.repeat = 0), new t(e, n) }, t.killTweensOf = function (e, t, n) { return l.killTweensOf(e, t, n) }, t }(Ft); we($t.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 }), de("staggerTo,staggerFrom,staggerFromTo", (function (e) { $t[e] = function () { var t = new zt, n = Ke.call(arguments, 0); return n.splice("staggerFromTo" === e ? 5 : 4, 0, 0), t[e].apply(t, n) } })); var Xt = function (e, t, n) { return e[t] = n }, Yt = function (e, t, n) { return e[t](n) }, Zt = function (e, t, n, i) { return e[t](i.fp, n) }, Kt = function (e, t, n) { return e.setAttribute(t, n) }, Jt = function (e, t) { return P(e[t]) ? Yt : O(e[t]) && e.setAttribute ? Kt : Xt }, Qt = function (e, t) { return t.set(t.t, t.p, Math.round(1e6 * (t.s + t.c * e)) / 1e6, t) }, en = function (e, t) { return t.set(t.t, t.p, !!(t.s + t.c * e), t) }, tn = function (e, t) { var n = t._pt, i = ""; if (!e && t.b) i = t.b; else if (1 === e && t.e) i = t.e; else { for (; n;)i = n.p + (n.m ? n.m(n.s + n.c * e) : Math.round(1e4 * (n.s + n.c * e)) / 1e4) + i, n = n._next; i += t.c } t.set(t.t, t.p, i, t) }, nn = function (e, t) { for (var n = t._pt; n;)n.r(e, n.d), n = n._next }, rn = function (e, t, n, i) { for (var r, s = this._pt; s;)r = s._next, s.p === i && s.modifier(e, t, n), s = r }, sn = function (e) { for (var t, n, i = this._pt; i;)n = i._next, i.p === e && !i.op || i.op === e ? Ce(this, i, "_pt") : i.dep || (t = 1), i = n; return !t }, an = function (e, t, n, i) { i.mSet(e, t, i.m.call(i.tween, n, i.mt), i) }, on = function (e) { for (var t, n, i, r, s = e._pt; s;) { for (t = s._next, n = i; n && n.pr > s.pr;)n = n._next; (s._prev = n ? n._prev : r) ? s._prev._next = s : i = s, (s._next = n) ? n._prev = s : r = s, s = t } e._pt = i }, ln = function () { function e(e, t, n, i, r, s, a, o, l) { this.t = t, this.s = i, this.c = r, this.p = n, this.r = s || Qt, this.d = a || this, this.set = o || Xt, this.pr = l || 0, this._next = e, e && (e._prev = this) } return e.prototype.modifier = function (e, t, n) { this.mSet = this.mSet || this.set, this.set = an, this.m = e, this.mt = n, this.tween = t }, e }(); de(le + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function (e) { return te[e] = 1 })), X.TweenMax = X.TweenLite = $t, X.TimelineLite = X.TimelineMax = zt, l = new zt({ sortChildren: !1, defaults: w, autoRemoveChildren: !0, id: "root", smoothChildTiming: !0 }), _.stringFilter = _t; var cn = { registerPlugin: function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; t.forEach((function (e) { return ht(e) })) }, timeline: function (e) { return new zt(e) }, getTweensOf: function (e, t) { return l.getTweensOf(e, t) }, getProperty: function (e, t, n, i) { A(e) && (e = Qe(e)[0]); var r = ue(e || {}).get, s = n ? _e : xe; return "native" === n && (n = ""), e ? t ? s((re[t] && re[t].get || r)(e, t, n, i)) : function (t, n, i) { return s((re[t] && re[t].get || r)(e, t, n, i)) } : e }, quickSetter: function (e, t, n) { if ((e = Qe(e)).length > 1) { var i = e.map((function (e) { return dn.quickSetter(e, t, n) })), r = i.length; return function (e) { for (var t = r; t--;)i[t](e) } } e = e[0] || {}; var s = re[t], a = ue(e), o = a.harness && (a.harness.aliases || {})[t] || t, l = s ? function (t) { var i = new s; f._pt = 0, i.init(e, n ? t + n : t, f, 0, [e]), i.render(1, i), f._pt && nn(1, f) } : a.set(e, o); return s ? l : function (t) { return l(e, o, n ? t + n : t, a, 1) } }, quickTo: function (e, t, n) { var i, r = dn.to(e, be(((i = {})[t] = "+=0.1", i.paused = !0, i), n || {})), s = function (e, n, i) { return r.resetTo(t, e, n, i) }; return s.tween = r, s }, isTweening: function (e) { return l.getTweensOf(e, !0).length > 0 }, defaults: function (e) { return e && e.ease && (e.ease = Lt(e.ease, w.ease)), Se(w, e || {}) }, config: function (e) { return Se(_, e || {}) }, registerEffect: function (e) { var t = e.name, n = e.effect, i = e.plugins, r = e.defaults, s = e.extendTimeline; (i || "").split(",").forEach((function (e) { return e && !re[e] && !X[e] && J(t + " effect requires " + e + " plugin.") })), se[t] = function (e, t, i) { return n(Qe(e), we(t || {}, r), i) }, s && (zt.prototype[t] = function (e, n, i) { return this.add(se[t](e, I(n) ? n : (i = n) && {}, this), i) }) }, registerEase: function (e, t) { St[e] = Lt(t) }, parseEase: function (e, t) { return arguments.length ? Lt(e, t) : St }, getById: function (e) { return l.getById(e) }, exportRoot: function (e, t) { void 0 === e && (e = {}); var n, i, r = new zt(e); for (r.smoothChildTiming = F(e.smoothChildTiming), l.remove(r), r._dp = 0, r._time = r._tTime = l._time, n = l._first; n;)i = n._next, !t && !n._dur && n instanceof $t && n.vars.onComplete === n._targets[0] || Ne(r, n, n._start - n._delay), n = i; return Ne(l, r, 0), r }, utils: { wrap: function e(t, n, i) { var r = n - t; return B(t) ? st(t, e(0, t.length), n) : Xe(i, (function (e) { return (r + (e - t) % r) % r + t })) }, wrapYoyo: function e(t, n, i) { var r = n - t, s = 2 * r; return B(t) ? st(t, e(0, t.length - 1), n) : Xe(i, (function (e) { return t + ((e = (s + (e - t) % s) % s || 0) > r ? s - e : e) })) }, distribute: tt, random: rt, snap: it, normalize: function (e, t, n) { return ot(e, t, 0, 1, n) }, getUnit: Ze, clamp: function (e, t, n) { return Xe(n, (function (n) { return Ye(e, t, n) })) }, splitColor: mt, toArray: Qe, selector: function (e) { return e = Qe(e)[0] || J("Invalid scope") || {}, function (t) { var n = e.current || e.nativeElement || e; return Qe(t, n.querySelectorAll ? n : n === e ? J("Invalid scope") || h.createElement("div") : e) } }, mapRange: ot, pipe: function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return function (e) { return t.reduce((function (e, t) { return t(e) }), e) } }, unitize: function (e, t) { return function (n) { return e(parseFloat(n)) + (t || Ze(n)) } }, interpolate: function e(t, n, i, r) { var s = isNaN(t + n) ? 0 : function (e) { return (1 - e) * t + e * n }; if (!s) { var a, o, l, c, u, h = A(t), d = {}; if (!0 === i && (r = 1) && (i = null), h) t = { p: t }, n = { p: n }; else if (B(t) && !B(n)) { for (l = [], c = t.length, u = c - 2, o = 1; o < c; o++)l.push(e(t[o - 1], t[o])); c--, s = function (e) { e *= c; var t = Math.min(u, ~~e); return l[t](e - t) }, i = n } else r || (t = be(B(t) ? [] : {}, t)); if (!l) { for (a in n) Ht.call(d, t, a, "get", n[a]); s = function (e) { return nn(e, d) || (h ? t.p : t) } } } return Xe(i, s) }, shuffle: et }, install: Z, effects: se, ticker: wt, updateRoot: zt.updateRoot, plugins: re, globalTimeline: l, core: { PropTween: ln, globals: Q, Tween: $t, Timeline: zt, Animation: Ft, getCache: ue, _removeLinkedListItem: Ce, suppressOverwrites: function (e) { return o = e } } }; de("to,from,fromTo,delayedCall,set,killTweensOf", (function (e) { return cn[e] = $t[e] })), wt.add(zt.updateRoot), f = cn.to({}, { duration: 0 }); var un = function (e, t) { for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t;)n = n._next; return n }, hn = function (e, t) { return { name: e, rawVars: 1, init: function (e, n, i) { i._onInit = function (e) { var i, r; if (A(n) && (i = {}, de(n, (function (e) { return i[e] = 1 })), n = i), t) { for (r in i = {}, n) i[r] = t(n[r]); n = i } !function (e, t) { var n, i, r, s = e._targets; for (n in t) for (i = s.length; i--;)(r = e._ptLookup[i][n]) && (r = r.d) && (r._pt && (r = un(r, n)), r && r.modifier && r.modifier(t[n], e, s[i], n)) }(e, n) } } } }, dn = cn.registerPlugin({ name: "attr", init: function (e, t, n, i, r) { var s, a; for (s in t) (a = this.add(e, "setAttribute", (e.getAttribute(s) || 0) + "", t[s], i, r, 0, 0, s)) && (a.op = s), this._props.push(s) } }, { name: "endArray", init: function (e, t) { for (var n = t.length; n--;)this.add(e, n, e[n] || 0, t[n]) } }, hn("roundProps", nt), hn("modifiers"), hn("snap", it)) || cn; $t.version = zt.version = dn.version = "3.10.3", d = 1, z() && bt(), St.Power0, St.Power1, St.Power2, St.Power3, St.Power4, St.Linear, St.Quad, St.Cubic, St.Quart, St.Quint, St.Strong, St.Elastic, St.Back, St.SteppedEase, St.Bounce, St.Sine, St.Expo, St.Circ; var pn, fn, mn, gn, vn, yn, xn, _n = {}, wn = 180 / Math.PI, bn = Math.PI / 180, Sn = Math.atan2, En = /([A-Z])/g, Mn = /(left|right|width|margin|padding|x)/i, Tn = /[\s,\(]\S/, Cn = { autoAlpha: "opacity,visibility", scale: "scaleX,scaleY", alpha: "opacity" }, Dn = function (e, t) { return t.set(t.t, t.p, Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u, t) }, Ln = function (e, t) { return t.set(t.t, t.p, 1 === e ? t.e : Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u, t) }, An = function (e, t) { return t.set(t.t, t.p, e ? Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u : t.b, t) }, Pn = function (e, t) { var n = t.s + t.c * e; t.set(t.t, t.p, ~~(n + (n < 0 ? -.5 : .5)) + t.u, t) }, Rn = function (e, t) { return t.set(t.t, t.p, e ? t.e : t.b, t) }, On = function (e, t) { return t.set(t.t, t.p, 1 !== e ? t.b : t.e, t) }, In = function (e, t, n) { return e.style[t] = n }, Fn = function (e, t, n) { return e.style.setProperty(t, n) }, zn = function (e, t, n) { return e._gsap[t] = n }, kn = function (e, t, n) { return e._gsap.scaleX = e._gsap.scaleY = n }, Nn = function (e, t, n, i, r) { var s = e._gsap; s.scaleX = s.scaleY = n, s.renderTransform(r, s) }, Bn = function (e, t, n, i, r) { var s = e._gsap; s[t] = n, s.renderTransform(r, s) }, Hn = "transform", Un = Hn + "Origin", Vn = function (e, t) { var n = fn.createElementNS ? fn.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : fn.createElement(e); return n.style ? n : fn.createElement(e) }, Gn = function e(t, n, i) { var r = getComputedStyle(t); return r[n] || r.getPropertyValue(n.replace(En, "-$1").toLowerCase()) || r.getPropertyValue(n) || !i && e(t, Wn(n) || n, 1) || "" }, jn = "O,Moz,ms,Ms,Webkit".split(","), Wn = function (e, t, n) { var i = (t || vn).style, r = 5; if (e in i && !n) return e; for (e = e.charAt(0).toUpperCase() + e.substr(1); r-- && !(jn[r] + e in i);); return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? jn[r] : "") + e }, qn = function () { "undefined" != typeof window && window.document && (pn = window, fn = pn.document, mn = fn.documentElement, vn = Vn("div") || { style: {} }, Vn("div"), Hn = Wn(Hn), Un = Hn + "Origin", vn.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", xn = !!Wn("perspective"), gn = 1) }, $n = function e(t) { var n, i = Vn("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), r = this.parentNode, s = this.nextSibling, a = this.style.cssText; if (mn.appendChild(i), i.appendChild(this), this.style.display = "block", t) try { n = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = e } catch (e) { } else this._gsapBBox && (n = this._gsapBBox()); return r && (s ? r.insertBefore(this, s) : r.appendChild(this)), mn.removeChild(i), this.style.cssText = a, n }, Xn = function (e, t) { for (var n = t.length; n--;)if (e.hasAttribute(t[n])) return e.getAttribute(t[n]) }, Yn = function (e) { var t; try { t = e.getBBox() } catch (n) { t = $n.call(e, !0) } return t && (t.width || t.height) || e.getBBox === $n || (t = $n.call(e, !0)), !t || t.width || t.x || t.y ? t : { x: +Xn(e, ["x", "cx", "x1"]) || 0, y: +Xn(e, ["y", "cy", "y1"]) || 0, width: 0, height: 0 } }, Zn = function (e) { return !(!e.getCTM || e.parentNode && !e.ownerSVGElement || !Yn(e)) }, Kn = function (e, t) { if (t) { var n = e.style; t in _n && t !== Un && (t = Hn), n.removeProperty ? ("ms" !== t.substr(0, 2) && "webkit" !== t.substr(0, 6) || (t = "-" + t), n.removeProperty(t.replace(En, "-$1").toLowerCase())) : n.removeAttribute(t) } }, Jn = function (e, t, n, i, r, s) { var a = new ln(e._pt, t, n, 0, 1, s ? On : Rn); return e._pt = a, a.b = i, a.e = r, e._props.push(n), a }, Qn = { deg: 1, rad: 1, turn: 1 }, ei = function e(t, n, i, r) { var s, a, o, l, c = parseFloat(i) || 0, u = (i + "").trim().substr((c + "").length) || "px", h = vn.style, d = Mn.test(n), p = "svg" === t.tagName.toLowerCase(), f = (p ? "client" : "offset") + (d ? "Width" : "Height"), m = 100, g = "px" === r, v = "%" === r; return r === u || !c || Qn[r] || Qn[u] ? c : ("px" !== u && !g && (c = e(t, n, i, "px")), l = t.getCTM && Zn(t), !v && "%" !== u || !_n[n] && !~n.indexOf("adius") ? (h[d ? "width" : "height"] = m + (g ? u : r), a = ~n.indexOf("adius") || "em" === r && t.appendChild && !p ? t : t.parentNode, l && (a = (t.ownerSVGElement || {}).parentNode), a && a !== fn && a.appendChild || (a = fn.body), (o = a._gsap) && v && o.width && d && o.time === wt.time ? pe(c / o.width * m) : ((v || "%" === u) && (h.position = Gn(t, "position")), a === t && (h.position = "static"), a.appendChild(vn), s = vn[f], a.removeChild(vn), h.position = "absolute", d && v && ((o = ue(a)).time = wt.time, o.width = a[f]), pe(g ? s * c / m : s && c ? m / s * c : 0))) : (s = l ? t.getBBox()[d ? "width" : "height"] : t[f], pe(v ? c / s * m : c / 100 * s))) }, ti = function (e, t, n, i) { var r; return gn || qn(), t in Cn && "transform" !== t && ~(t = Cn[t]).indexOf(",") && (t = t.split(",")[0]), _n[t] && "transform" !== t ? (r = di(e, i), r = "transformOrigin" !== t ? r[t] : r.svg ? r.origin : pi(Gn(e, Un)) + " " + r.zOrigin + "px") : (!(r = e.style[t]) || "auto" === r || i || ~(r + "").indexOf("calc(")) && (r = si[t] && si[t](e, t, n) || Gn(e, t) || he(e, t) || ("opacity" === t ? 1 : 0)), n && !~(r + "").trim().indexOf(" ") ? ei(e, t, r, n) + n : r }, ni = function (e, t, n, i) { if (!n || "none" === n) { var r = Wn(t, e, 1), s = r && Gn(e, r, 1); s && s !== n ? (t = r, n = s) : "borderColor" === t && (n = Gn(e, "borderTopColor")) } var a, o, l, c, u, h, d, p, f, m, g, v = new ln(this._pt, e.style, t, 0, 1, tn), y = 0, x = 0; if (v.b = n, v.e = i, n += "", "auto" == (i += "") && (e.style[t] = i, i = Gn(e, t) || i, e.style[t] = n), _t(a = [n, i]), i = a[1], l = (n = a[0]).match(V) || [], (i.match(V) || []).length) { for (; o = V.exec(i);)d = o[0], f = i.substring(y, o.index), u ? u = (u + 1) % 5 : "rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5) || (u = 1), d !== (h = l[x++] || "") && (c = parseFloat(h) || 0, g = h.substr((c + "").length), "=" === d.charAt(1) && (d = me(c, d) + g), p = parseFloat(d), m = d.substr((p + "").length), y = V.lastIndex - m.length, m || (m = m || _.units[t] || g, y === i.length && (i += m, v.e += m)), g !== m && (c = ei(e, t, h, m) || 0), v._pt = { _next: v._pt, p: f || 1 === x ? f : ",", s: c, c: p - c, m: u && u < 4 || "zIndex" === t ? Math.round : 0 }); v.c = y < i.length ? i.substring(y, i.length) : "" } else v.r = "display" === t && "none" === i ? On : Rn; return j.test(i) && (v.e = 0), this._pt = v, v }, ii = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" }, ri = function (e, t) { if (t.tween && t.tween._time === t.tween._dur) { var n, i, r, s = t.t, a = s.style, o = t.u, l = s._gsap; if ("all" === o || !0 === o) a.cssText = "", i = 1; else for (r = (o = o.split(",")).length; --r > -1;)n = o[r], _n[n] && (i = 1, n = "transformOrigin" === n ? Un : Hn), Kn(s, n); i && (Kn(s, Hn), l && (l.svg && s.removeAttribute("transform"), di(s, 1), l.uncache = 1)) } }, si = { clearProps: function (e, t, n, i, r) { if ("isFromStart" !== r.data) { var s = e._pt = new ln(e._pt, t, n, 0, 0, ri); return s.u = i, s.pr = -10, s.tween = r, e._props.push(n), 1 } } }, ai = [1, 0, 0, 1, 0, 0], oi = {}, li = function (e) { return "matrix(1, 0, 0, 1, 0, 0)" === e || "none" === e || !e }, ci = function (e) { var t = Gn(e, Hn); return li(t) ? ai : t.substr(7).match(U).map(pe) }, ui = function (e, t) { var n, i, r, s, a = e._gsap || ue(e), o = e.style, l = ci(e); return a.svg && e.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(r = e.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? ai : l : (l !== ai || e.offsetParent || e === mn || a.svg || (r = o.display, o.display = "block", (n = e.parentNode) && e.offsetParent || (s = 1, i = e.nextSibling, mn.appendChild(e)), l = ci(e), r ? o.display = r : Kn(e, "display"), s && (i ? n.insertBefore(e, i) : n ? n.appendChild(e) : mn.removeChild(e))), t && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l) }, hi = function (e, t, n, i, r, s) { var a, o, l, c = e._gsap, u = r || ui(e, !0), h = c.xOrigin || 0, d = c.yOrigin || 0, p = c.xOffset || 0, f = c.yOffset || 0, m = u[0], g = u[1], v = u[2], y = u[3], x = u[4], _ = u[5], w = t.split(" "), b = parseFloat(w[0]) || 0, S = parseFloat(w[1]) || 0; n ? u !== ai && (o = m * y - g * v) && (l = b * (-g / o) + S * (m / o) - (m * _ - g * x) / o, b = b * (y / o) + S * (-v / o) + (v * _ - y * x) / o, S = l) : (b = (a = Yn(e)).x + (~w[0].indexOf("%") ? b / 100 * a.width : b), S = a.y + (~(w[1] || w[0]).indexOf("%") ? S / 100 * a.height : S)), i || !1 !== i && c.smooth ? (x = b - h, _ = S - d, c.xOffset = p + (x * m + _ * v) - x, c.yOffset = f + (x * g + _ * y) - _) : c.xOffset = c.yOffset = 0, c.xOrigin = b, c.yOrigin = S, c.smooth = !!i, c.origin = t, c.originIsAbsolute = !!n, e.style[Un] = "0px 0px", s && (Jn(s, c, "xOrigin", h, b), Jn(s, c, "yOrigin", d, S), Jn(s, c, "xOffset", p, c.xOffset), Jn(s, c, "yOffset", f, c.yOffset)), e.setAttribute("data-svg-origin", b + " " + S) }, di = function (e, t) { var n = e._gsap || new It(e); if ("x" in n && !t && !n.uncache) return n; var i, r, s, a, o, l, c, u, h, d, p, f, m, g, v, y, x, w, b, S, E, M, T, C, D, L, A, P, R, O, I, F, z = e.style, k = n.scaleX < 0, N = "px", B = "deg", H = Gn(e, Un) || "0"; return i = r = s = l = c = u = h = d = p = 0, a = o = 1, n.svg = !(!e.getCTM || !Zn(e)), g = ui(e, n.svg), n.svg && (C = (!n.uncache || "0px 0px" === H) && !t && e.getAttribute("data-svg-origin"), hi(e, C || H, !!C || n.originIsAbsolute, !1 !== n.smooth, g)), f = n.xOrigin || 0, m = n.yOrigin || 0, g !== ai && (w = g[0], b = g[1], S = g[2], E = g[3], i = M = g[4], r = T = g[5], 6 === g.length ? (a = Math.sqrt(w * w + b * b), o = Math.sqrt(E * E + S * S), l = w || b ? Sn(b, w) * wn : 0, (h = S || E ? Sn(S, E) * wn + l : 0) && (o *= Math.abs(Math.cos(h * bn))), n.svg && (i -= f - (f * w + m * S), r -= m - (f * b + m * E))) : (F = g[6], O = g[7], A = g[8], P = g[9], R = g[10], I = g[11], i = g[12], r = g[13], s = g[14], c = (v = Sn(F, R)) * wn, v && (C = M * (y = Math.cos(-v)) + A * (x = Math.sin(-v)), D = T * y + P * x, L = F * y + R * x, A = M * -x + A * y, P = T * -x + P * y, R = F * -x + R * y, I = O * -x + I * y, M = C, T = D, F = L), u = (v = Sn(-S, R)) * wn, v && (y = Math.cos(-v), I = E * (x = Math.sin(-v)) + I * y, w = C = w * y - A * x, b = D = b * y - P * x, S = L = S * y - R * x), l = (v = Sn(b, w)) * wn, v && (C = w * (y = Math.cos(v)) + b * (x = Math.sin(v)), D = M * y + T * x, b = b * y - w * x, T = T * y - M * x, w = C, M = D), c && Math.abs(c) + Math.abs(l) > 359.9 && (c = l = 0, u = 180 - u), a = pe(Math.sqrt(w * w + b * b + S * S)), o = pe(Math.sqrt(T * T + F * F)), v = Sn(M, T), h = Math.abs(v) > 2e-4 ? v * wn : 0, p = I ? 1 / (I < 0 ? -I : I) : 0), n.svg && (C = e.getAttribute("transform"), n.forceCSS = e.setAttribute("transform", "") || !li(Gn(e, Hn)), C && e.setAttribute("transform", C))), Math.abs(h) > 90 && Math.abs(h) < 270 && (k ? (a *= -1, h += l <= 0 ? 180 : -180, l += l <= 0 ? 180 : -180) : (o *= -1, h += h <= 0 ? 180 : -180)), t = t || n.uncache, n.x = i - ((n.xPercent = i && (!t && n.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-i) ? -50 : 0))) ? e.offsetWidth * n.xPercent / 100 : 0) + N, n.y = r - ((n.yPercent = r && (!t && n.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-r) ? -50 : 0))) ? e.offsetHeight * n.yPercent / 100 : 0) + N, n.z = s + N, n.scaleX = pe(a), n.scaleY = pe(o), n.rotation = pe(l) + B, n.rotationX = pe(c) + B, n.rotationY = pe(u) + B, n.skewX = h + B, n.skewY = d + B, n.transformPerspective = p + N, (n.zOrigin = parseFloat(H.split(" ")[2]) || 0) && (z[Un] = pi(H)), n.xOffset = n.yOffset = 0, n.force3D = _.force3D, n.renderTransform = n.svg ? _i : xn ? xi : mi, n.uncache = 0, n }, pi = function (e) { return (e = e.split(" "))[0] + " " + e[1] }, fi = function (e, t, n) { var i = Ze(t); return pe(parseFloat(t) + parseFloat(ei(e, "x", n + "px", i))) + i }, mi = function (e, t) { t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, xi(e, t) }, gi = "0deg", vi = "0px", yi = ") ", xi = function (e, t) { var n = t || this, i = n.xPercent, r = n.yPercent, s = n.x, a = n.y, o = n.z, l = n.rotation, c = n.rotationY, u = n.rotationX, h = n.skewX, d = n.skewY, p = n.scaleX, f = n.scaleY, m = n.transformPerspective, g = n.force3D, v = n.target, y = n.zOrigin, x = "", _ = "auto" === g && e && 1 !== e || !0 === g; if (y && (u !== gi || c !== gi)) { var w, b = parseFloat(c) * bn, S = Math.sin(b), E = Math.cos(b); b = parseFloat(u) * bn, w = Math.cos(b), s = fi(v, s, S * w * -y), a = fi(v, a, -Math.sin(b) * -y), o = fi(v, o, E * w * -y + y) } m !== vi && (x += "perspective(" + m + yi), (i || r) && (x += "translate(" + i + "%, " + r + "%) "), (_ || s !== vi || a !== vi || o !== vi) && (x += o !== vi || _ ? "translate3d(" + s + ", " + a + ", " + o + ") " : "translate(" + s + ", " + a + yi), l !== gi && (x += "rotate(" + l + yi), c !== gi && (x += "rotateY(" + c + yi), u !== gi && (x += "rotateX(" + u + yi), h === gi && d === gi || (x += "skew(" + h + ", " + d + yi), 1 === p && 1 === f || (x += "scale(" + p + ", " + f + yi), v.style[Hn] = x || "translate(0, 0)" }, _i = function (e, t) { var n, i, r, s, a, o = t || this, l = o.xPercent, c = o.yPercent, u = o.x, h = o.y, d = o.rotation, p = o.skewX, f = o.skewY, m = o.scaleX, g = o.scaleY, v = o.target, y = o.xOrigin, x = o.yOrigin, _ = o.xOffset, w = o.yOffset, b = o.forceCSS, S = parseFloat(u), E = parseFloat(h); d = parseFloat(d), p = parseFloat(p), (f = parseFloat(f)) && (p += f = parseFloat(f), d += f), d || p ? (d *= bn, p *= bn, n = Math.cos(d) * m, i = Math.sin(d) * m, r = Math.sin(d - p) * -g, s = Math.cos(d - p) * g, p && (f *= bn, a = Math.tan(p - f), r *= a = Math.sqrt(1 + a * a), s *= a, f && (a = Math.tan(f), n *= a = Math.sqrt(1 + a * a), i *= a)), n = pe(n), i = pe(i), r = pe(r), s = pe(s)) : (n = m, s = g, i = r = 0), (S && !~(u + "").indexOf("px") || E && !~(h + "").indexOf("px")) && (S = ei(v, "x", u, "px"), E = ei(v, "y", h, "px")), (y || x || _ || w) && (S = pe(S + y - (y * n + x * r) + _), E = pe(E + x - (y * i + x * s) + w)), (l || c) && (a = v.getBBox(), S = pe(S + l / 100 * a.width), E = pe(E + c / 100 * a.height)), a = "matrix(" + n + "," + i + "," + r + "," + s + "," + S + "," + E + ")", v.setAttribute("transform", a), b && (v.style[Hn] = a) }, wi = function (e, t, n, i, r) { var s, a, o = 360, l = A(r), c = parseFloat(r) * (l && ~r.indexOf("rad") ? wn : 1) - i, u = i + c + "deg"; return l && ("short" === (s = r.split("_")[1]) && (c %= o) != c % 180 && (c += c < 0 ? o : -360), "cw" === s && c < 0 ? c = (c + 36e9) % o - ~~(c / o) * o : "ccw" === s && c > 0 && (c = (c - 36e9) % o - ~~(c / o) * o)), e._pt = a = new ln(e._pt, t, n, i, c, Ln), a.e = u, a.u = "deg", e._props.push(n), a }, bi = function (e, t) { for (var n in t) e[n] = t[n]; return e }, Si = function (e, t, n) { var i, r, s, a, o, l, c, u = bi({}, n._gsap), h = n.style; for (r in u.svg ? (s = n.getAttribute("transform"), n.setAttribute("transform", ""), h[Hn] = t, i = di(n, 1), Kn(n, Hn), n.setAttribute("transform", s)) : (s = getComputedStyle(n)[Hn], h[Hn] = t, i = di(n, 1), h[Hn] = s), _n) (s = u[r]) !== (a = i[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (o = Ze(s) !== (c = Ze(a)) ? ei(n, r, s, c) : parseFloat(s), l = parseFloat(a), e._pt = new ln(e._pt, i, r, o, l - o, Dn), e._pt.u = c || 0, e._props.push(r)); bi(i, u) }; de("padding,margin,Width,Radius", (function (e, t) { var n = "Top", i = "Right", r = "Bottom", s = "Left", a = (t < 3 ? [n, i, r, s] : [n + s, n + i, r + i, r + s]).map((function (n) { return t < 2 ? e + n : "border" + n + e })); si[t > 1 ? "border" + e : e] = function (e, t, n, i, r) { var s, o; if (arguments.length < 4) return s = a.map((function (t) { return ti(e, t, n) })), 5 === (o = s.join(" ")).split(s[0]).length ? s[0] : o; s = (i + "").split(" "), o = {}, a.forEach((function (e, t) { return o[e] = s[t] = s[t] || s[(t - 1) / 2 | 0] })), e.init(t, o, r) } })); var Ei, Mi, Ti = { name: "css", register: qn, targetTest: function (e) { return e.style && e.nodeType }, init: function (e, t, n, i, r) { var s, a, o, l, c, u, h, d, p, f, m, g, v, y, x, w, b, S, E, M = this._props, T = e.style, C = n.vars.startAt; for (h in gn || qn(), t) if ("autoRound" !== h && (a = t[h], !re[h] || !Ut(h, t, n, i, e, r))) if (c = typeof a, u = si[h], "function" === c && (c = typeof (a = a.call(n, i, e, r))), "string" === c && ~a.indexOf("random(") && (a = at(a)), u) u(this, e, h, a, n) && (x = 1); else if ("--" === h.substr(0, 2)) s = (getComputedStyle(e).getPropertyValue(h) + "").trim(), a += "", yt.lastIndex = 0, yt.test(s) || (d = Ze(s), p = Ze(a)), p ? d !== p && (s = ei(e, h, s, p) + p) : d && (a += d), this.add(T, "setProperty", s, a, i, r, 0, 0, h), M.push(h); else if ("undefined" !== c) { if (C && h in C ? (s = "function" == typeof C[h] ? C[h].call(n, i, e, r) : C[h], A(s) && ~s.indexOf("random(") && (s = at(s)), Ze(s + "") || (s += _.units[h] || Ze(ti(e, h)) || ""), "=" === (s + "").charAt(1) && (s = ti(e, h))) : s = ti(e, h), l = parseFloat(s), (f = "string" === c && "=" === a.charAt(1) && a.substr(0, 2)) && (a = a.substr(2)), o = parseFloat(a), h in Cn && ("autoAlpha" === h && (1 === l && "hidden" === ti(e, "visibility") && o && (l = 0), Jn(this, T, "visibility", l ? "inherit" : "hidden", o ? "inherit" : "hidden", !o)), "scale" !== h && "transform" !== h && ~(h = Cn[h]).indexOf(",") && (h = h.split(",")[0])), m = h in _n) if (g || ((v = e._gsap).renderTransform && !t.parseTransform || di(e, t.parseTransform), y = !1 !== t.smoothOrigin && v.smooth, (g = this._pt = new ln(this._pt, T, Hn, 0, 1, v.renderTransform, v, 0, -1)).dep = 1), "scale" === h) this._pt = new ln(this._pt, v, "scaleY", v.scaleY, (f ? me(v.scaleY, f + o) : o) - v.scaleY || 0), M.push("scaleY", h), h += "X"; else { if ("transformOrigin" === h) { b = void 0, S = void 0, E = void 0, b = (w = a).split(" "), S = b[0], E = b[1] || "50%", "top" !== S && "bottom" !== S && "left" !== E && "right" !== E || (w = S, S = E, E = w), b[0] = ii[S] || S, b[1] = ii[E] || E, a = b.join(" "), v.svg ? hi(e, a, 0, y, 0, this) : ((p = parseFloat(a.split(" ")[2]) || 0) !== v.zOrigin && Jn(this, v, "zOrigin", v.zOrigin, p), Jn(this, T, h, pi(s), pi(a))); continue } if ("svgOrigin" === h) { hi(e, a, 1, y, 0, this); continue } if (h in oi) { wi(this, v, h, l, f ? me(l, f + a) : a); continue } if ("smoothOrigin" === h) { Jn(this, v, "smooth", v.smooth, a); continue } if ("force3D" === h) { v[h] = a; continue } if ("transform" === h) { Si(this, a, e); continue } } else h in T || (h = Wn(h) || h); if (m || (o || 0 === o) && (l || 0 === l) && !Tn.test(a) && h in T) o || (o = 0), (d = (s + "").substr((l + "").length)) !== (p = Ze(a) || (h in _.units ? _.units[h] : d)) && (l = ei(e, h, s, p)), this._pt = new ln(this._pt, m ? v : T, h, l, (f ? me(l, f + o) : o) - l, m || "px" !== p && "zIndex" !== h || !1 === t.autoRound ? Dn : Pn), this._pt.u = p || 0, d !== p && "%" !== p && (this._pt.b = s, this._pt.r = An); else if (h in T) ni.call(this, e, h, s, f ? f + a : a); else { if (!(h in e)) { K(h, a); continue } this.add(e, h, s || e[h], f ? f + a : a, i, r) } M.push(h) } x && on(this) }, get: ti, aliases: Cn, getSetter: function (e, t, n) { var i = Cn[t]; return i && i.indexOf(",") < 0 && (t = i), t in _n && t !== Un && (e._gsap.x || ti(e, "x")) ? n && yn === n ? "scale" === t ? kn : zn : (yn = n || {}) && ("scale" === t ? Nn : Bn) : e.style && !O(e.style[t]) ? In : ~t.indexOf("-") ? Fn : Jt(e, t) }, core: { _removeProperty: Kn, _getMatrix: ui } }; dn.utils.checkPrefix = Wn, Mi = de("x,y,z,scale,scaleX,scaleY,xPercent,yPercent" + "," + (Ei = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function (e) { _n[e] = 1 })), de(Ei, (function (e) { _.units[e] = "deg", oi[e] = 1 })), Cn[Mi[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + Ei, de("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function (e) { var t = e.split(":"); Cn[t[1]] = Mi[t[0]] })), de("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function (e) { _.units[e] = "px" })), dn.registerPlugin(Ti); var Ci = dn.registerPlugin(Ti) || dn; function Di(e, t) { for (var n = 0; n < t.length; n++) { var i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } Ci.core.Tween; var Li, Ai, Pi, Ri, Oi, Ii, Fi, zi, ki, Ni, Bi, Hi, Ui = function () { return Li || "undefined" != typeof window && (Li = window.gsap) && Li.registerPlugin && Li }, Vi = 1, Gi = [], ji = [], Wi = [], qi = Date.now, $i = function (e, t) { return t }, Xi = function (e, t) { return ~Wi.indexOf(e) && Wi[Wi.indexOf(e) + 1][t] }, Yi = function (e) { return !!~Ni.indexOf(e) }, Zi = function (e, t, n, i, r) { return e.addEventListener(t, n, { passive: !i, capture: !!r }) }, Ki = function (e, t, n) { return e.removeEventListener(t, n) }, Ji = function () { return Bi && Bi.isPressed || ji.cache++ }, Qi = function (e) { return function (t) { return t || 0 === t ? (Vi && (Pi.history.scrollRestoration = "manual"), e(t), e.v = t, e.c = ji.cache, Bi && Bi.isPressed && $i("ss", t)) : (ji.cache !== e.c || $i("ref")) && (e.c = ji.cache, e.v = e()), e.v } }, er = { s: "scrollLeft", p: "left", p2: "Left", os: "right", os2: "Right", d: "width", d2: "Width", a: "x", sc: Qi((function (e) { return arguments.length ? Pi.scrollTo(e, tr.sc()) : Pi.pageXOffset || Ri.scrollLeft || Oi.scrollLeft || Ii.scrollLeft || 0 })) }, tr = { s: "scrollTop", p: "top", p2: "Top", os: "bottom", os2: "Bottom", d: "height", d2: "Height", a: "y", op: er, sc: Qi((function (e) { return arguments.length ? Pi.scrollTo(er.sc(), e) : Pi.pageYOffset || Ri.scrollTop || Oi.scrollTop || Ii.scrollTop || 0 })) }, nr = function (e) { return Li.utils.toArray(e)[0] || ("string" == typeof e && !1 !== Li.config().nullTargetWarn ? console.warn("Element not found:", e) : null) }, ir = function (e, t) { var n = t.s, i = t.sc, r = ji.indexOf(e), s = i === tr.sc ? 1 : 2; return !~r && (r = ji.push(e) - 1), ji[r + s] || (ji[r + s] = Xi(e, n) || (Yi(e) ? i : Qi((function (t) { return arguments.length ? e[n] = t : e[n] })))) }, rr = function (e, t, n) { var i = e, r = e, s = qi(), a = s, o = t || 50, l = Math.max(500, 3 * o), c = function (e, t) { var l = qi(); t || l - s > o ? (r = i, i = e, a = s, s = l) : n ? i += e : i = r + (e - r) / (l - a) * (s - a) }; return { update: c, reset: function () { r = i = n ? 0 : i, a = s = 0 }, getVelocity: function (e) { var t = a, o = r, u = qi(); return (e || 0 === e) && e !== i && c(e), s === a || u - a > l ? 0 : (i + (n ? o : -o)) / ((n ? u : s) - t) * 1e3 } } }, sr = function (e, t) { return t && !e._gsapAllow && e.preventDefault(), e.changedTouches ? e.changedTouches[0] : e }, ar = function (e) { var t = Math.max.apply(Math, e), n = Math.min.apply(Math, e); return Math.abs(t) >= Math.abs(n) ? t : n }, or = function () { (ki = Li.core.globals().ScrollTrigger) && ki.core && function () { var e = ki.core, t = e.bridge || {}, n = e._scrollers, i = e._proxies; n.push.apply(n, ji), i.push.apply(i, Wi), ji = n, Wi = i, $i = function (e, n) { return t[e](n) } }() }, lr = function (e) { return (Li = e || Ui()) && "undefined" != typeof document && document.body && (Pi = window, Ri = document, Oi = Ri.documentElement, Ii = Ri.body, Ni = [Pi, Ri, Oi, Ii], Li.utils.clamp, zi = "onpointerenter" in Ii ? "pointer" : "mouse", Fi = cr.isTouch = Pi.matchMedia && Pi.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in Pi || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, Hi = cr.eventTypes = ("ontouchstart" in Oi ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in Oi ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout((function () { return Vi = 0 }), 500), or(), Ai = 1), Ai }; er.op = tr, ji.cache = 0; var cr = function () { function e(e) { this.init(e) } var t, n; return e.prototype.init = function (e) { Ai || lr(Li) || console.warn("Please gsap.registerPlugin(Observer)"), ki || or(); var t = e.tolerance, n = e.dragMinimum, i = e.type, r = e.target, s = e.lineHeight, a = e.debounce, o = e.preventDefault, l = e.onStop, c = e.onStopDelay, u = e.ignore, h = e.wheelSpeed, d = e.event, p = e.onDragStart, f = e.onDragEnd, m = e.onDrag, g = e.onPress, v = e.onRelease, y = e.onRight, x = e.onLeft, _ = e.onUp, w = e.onDown, b = e.onChangeX, S = e.onChangeY, E = e.onChange, M = e.onToggleX, T = e.onToggleY, C = e.onHover, D = e.onHoverEnd, L = e.onMove, A = e.ignoreCheck, P = e.isNormalizer, R = e.onGestureStart, O = e.onGestureEnd, I = e.onWheel, F = e.onEnable, z = e.onDisable, k = e.onClick, N = e.scrollSpeed, B = e.capture, H = e.allowClicks, U = e.lockAxis, V = e.onLockAxis; this.target = r = nr(r) || Oi, this.vars = e, u && (u = Li.utils.toArray(u)), t = t || 0, n = n || 0, h = h || 1, N = N || 1, i = i || "wheel,touch,pointer", a = !1 !== a, s || (s = parseFloat(Pi.getComputedStyle(Ii).lineHeight) || 22); var G, j, W, q, $, X, Y, Z = this, K = 0, J = 0, Q = ir(r, er), ee = ir(r, tr), te = Q(), ne = ee(), ie = ~i.indexOf("touch") && !~i.indexOf("pointer") && "pointerdown" === Hi[0], re = Yi(r), se = r.ownerDocument || Ri, ae = [0, 0, 0], oe = [0, 0, 0], le = 0, ce = function () { return le = qi() }, ue = function (e, t) { return (Z.event = e) && u && ~u.indexOf(e.target) || t && ie && "touch" !== e.pointerType || A && A(e, t) }, he = function () { var e = Z.deltaX = ar(ae), n = Z.deltaY = ar(oe), i = Math.abs(e) >= t, r = Math.abs(n) >= t; E && (i || r) && E(Z, e, n, ae, oe), i && (y && Z.deltaX > 0 && y(Z), x && Z.deltaX < 0 && x(Z), b && b(Z), M && Z.deltaX < 0 != K < 0 && M(Z), K = Z.deltaX, ae[0] = ae[1] = ae[2] = 0), r && (w && Z.deltaY > 0 && w(Z), _ && Z.deltaY < 0 && _(Z), S && S(Z), T && Z.deltaY < 0 != J < 0 && T(Z), J = Z.deltaY, oe[0] = oe[1] = oe[2] = 0), (q || W) && (L && L(Z), V && X && V(Z), W && (m(Z), W = !1), q = X = !1), $ && (I(Z), $ = !1), G = 0 }, de = function (e, t, n) { ae[n] += e, oe[n] += t, Z._vx.update(e), Z._vy.update(t), a ? G || (G = requestAnimationFrame(he)) : he() }, pe = function (e, t) { "y" !== Y && (ae[2] += e, Z._vx.update(e, !0)), "x" !== Y && (oe[2] += t, Z._vy.update(t, !0)), U && !Y && (Z.axis = Y = Math.abs(e) > Math.abs(t) ? "x" : "y", X = !0), a ? G || (G = requestAnimationFrame(he)) : he() }, fe = function (e) { if (!ue(e, 1)) { var t = (e = sr(e, o)).clientX, i = e.clientY, r = t - Z.x, s = i - Z.y, a = Z.isDragging; Z.x = t, Z.y = i, (a || Math.abs(Z.startX - t) >= n || Math.abs(Z.startY - i) >= n) && (m && (W = !0), a || (Z.isDragging = !0), pe(r, s), a || p && p(Z)) } }, me = Z.onPress = function (e) { ue(e, 1) || (Z.axis = Y = null, j.pause(), Z.isPressed = !0, e = sr(e), K = J = 0, Z.startX = Z.x = e.clientX, Z.startY = Z.y = e.clientY, Z._vx.reset(), Z._vy.reset(), Zi(P ? r : se, Hi[1], fe, o, B), Z.deltaX = Z.deltaY = 0, g && g(Z)) }, ge = function (e) { if (!ue(e, 1)) { Ki(P ? r : se, Hi[1], fe); var t = Z.isDragging && (Math.abs(Z.x - Z.startX) > 3 || Math.abs(Z.y - Z.startY) > 3), n = sr(e); t || (Z._vx.reset(), Z._vy.reset(), o && H && Li.delayedCall(.05, (function () { if (qi() - le > 300 && !e.defaultPrevented) if (e.target.click) e.target.click(); else if (se.createEvent) { var t = se.createEvent("MouseEvents"); t.initMouseEvent("click", !0, !0, Pi, 1, n.screenX, n.screenY, n.clientX, n.clientY, !1, !1, !1, !1, 0, null), e.target.dispatchEvent(t) } }))), Z.isDragging = Z.isGesturing = Z.isPressed = !1, l && !P && j.restart(!0), f && t && f(Z), v && v(Z, t) } }, ve = function (e) { return e.touches && e.touches.length > 1 && (Z.isGesturing = !0) && R(e, Z.isDragging) }, ye = function () { return (Z.isGesturing = !1) || O(Z) }, xe = function (e) { if (!ue(e)) { var t = Q(), n = ee(); de((t - te) * N, (n - ne) * N, 1), te = t, ne = n, l && j.restart(!0) } }, _e = function (e) { if (!ue(e)) { e = sr(e, o), I && ($ = !0); var t = (1 === e.deltaMode ? s : 2 === e.deltaMode ? Pi.innerHeight : 1) * h; de(e.deltaX * t, e.deltaY * t, 0), l && !P && j.restart(!0) } }, we = function (e) { if (!ue(e)) { var t = e.clientX, n = e.clientY, i = t - Z.x, r = n - Z.y; Z.x = t, Z.y = n, q = !0, (i || r) && pe(i, r) } }, be = function (e) { Z.event = e, C(Z) }, Se = function (e) { Z.event = e, D(Z) }, Ee = function (e) { return ue(e) || sr(e, o) && k(Z) }; j = Z._dc = Li.delayedCall(c || .25, (function () { Z._vx.reset(), Z._vy.reset(), j.pause(), l && l(Z) })).pause(), Z.deltaX = Z.deltaY = 0, Z._vx = rr(0, 50, !0), Z._vy = rr(0, 50, !0), Z.scrollX = Q, Z.scrollY = ee, Z.isDragging = Z.isGesturing = Z.isPressed = !1, Z.enable = function (e) { return Z.isEnabled || (Zi(re ? se : r, "scroll", Ji), i.indexOf("scroll") >= 0 && Zi(re ? se : r, "scroll", xe, o, B), i.indexOf("wheel") >= 0 && Zi(r, "wheel", _e, o, B), (i.indexOf("touch") >= 0 && Fi || i.indexOf("pointer") >= 0) && (Zi(r, Hi[0], me, o, B), Zi(se, Hi[2], ge), Zi(se, Hi[3], ge), H && Zi(r, "click", ce, !1, !0), k && Zi(r, "click", Ee), R && Zi(se, "gesturestart", ve), O && Zi(se, "gestureend", ye), C && Zi(r, zi + "enter", be), D && Zi(r, zi + "leave", Se), L && Zi(r, zi + "move", we)), Z.isEnabled = !0, e && e.type && me(e), F && F(Z)), Z }, Z.disable = function () { Z.isEnabled && (Gi.filter((function (e) { return e !== Z && Yi(e.target) })).length || Ki(re ? se : r, "scroll", Ji), Z.isPressed && (Z._vx.reset(), Z._vy.reset(), Ki(P ? r : se, Hi[1], fe)), Ki(re ? se : r, "scroll", xe), Ki(r, "wheel", _e), Ki(r, Hi[0], me), Ki(se, Hi[2], ge), Ki(se, Hi[3], ge), Ki(r, "click", ce), Ki(r, "click", Ee), Ki(se, "gesturestart", ve), Ki(se, "gestureend", ye), Ki(r, zi + "enter", be), Ki(r, zi + "leave", Se), Ki(r, zi + "move", we), Z.isEnabled = Z.isPressed = Z.isDragging = !1, z && z(Z)) }, Z.kill = function () { Z.disable(); var e = Gi.indexOf(Z); e >= 0 && Gi.splice(e, 1), Bi === Z && (Bi = 0) }, Gi.push(Z), P && Yi(r) && (Bi = Z), Z.enable(d) }, t = e, (n = [{ key: "velocityX", get: function () { return this._vx.getVelocity() } }, { key: "velocityY", get: function () { return this._vy.getVelocity() } }]) && Di(t.prototype, n), e }(); cr.version = "3.10.3", cr.create = function (e) { return new cr(e) }, cr.register = lr, cr.getAll = function () { return Gi.slice() }, cr.getById = function (e) { return Gi.filter((function (t) { return t.vars.id === e }))[0] }, Ui() && Li.registerPlugin(cr); var ur, hr, dr, pr, fr, mr, gr, vr, yr, xr, _r, wr, br, Sr, Er, Mr, Tr, Cr, Dr, Lr, Ar, Pr, Rr, Or, Ir, Fr, zr, kr, Nr, Br, Hr, Ur, Vr = 1, Gr = Date.now, jr = Gr(), Wr = 0, qr = 0, $r = function () { return Sr = 1 }, Xr = function () { return Sr = 0 }, Yr = function (e) { return e }, Zr = function (e) { return Math.round(1e5 * e) / 1e5 || 0 }, Kr = function () { return "undefined" != typeof window }, Jr = function () { return ur || Kr() && (ur = window.gsap) && ur.registerPlugin && ur }, Qr = function (e) { return !!~gr.indexOf(e) }, es = function (e) { return Xi(e, "getBoundingClientRect") || (Qr(e) ? function () { return ca.width = dr.innerWidth, ca.height = dr.innerHeight, ca } : function () { return bs(e) }) }, ts = function (e, t) { var n = t.s, i = t.d2, r = t.d, s = t.a; return (n = "scroll" + i) && (s = Xi(e, n)) ? s() - es(e)()[r] : Qr(e) ? (fr[n] || mr[n]) - (dr["inner" + i] || fr["client" + i] || mr["client" + i]) : e[n] - e["offset" + i] }, ns = function (e, t) { for (var n = 0; n < Dr.length; n += 3)(!t || ~t.indexOf(Dr[n + 1])) && e(Dr[n], Dr[n + 1], Dr[n + 2]) }, is = function (e) { return "string" == typeof e }, rs = function (e) { return "function" == typeof e }, ss = function (e) { return "number" == typeof e }, as = function (e) { return "object" == typeof e }, os = function (e) { return rs(e) && e() }, ls = function (e, t) { return function () { var n = os(e), i = os(t); return function () { os(n), os(i) } } }, cs = function (e, t, n) { return e && e.progress(t ? 0 : 1) && n && e.pause() }, us = function (e, t) { if (e.enabled) { var n = t(e); n && n.totalTime && (e.callbackAnimation = n) } }, hs = Math.abs, ds = "right", ps = "bottom", fs = "width", ms = "height", gs = "padding", vs = "margin", ys = "Width", xs = "px", _s = function (e) { return dr.getComputedStyle(e) }, ws = function (e, t) { for (var n in t) n in e || (e[n] = t[n]); return e }, bs = function (e, t) { var n = t && "matrix(1, 0, 0, 1, 0, 0)" !== _s(e)[Er] && ur.to(e, { x: 0, y: 0, xPercent: 0, yPercent: 0, rotation: 0, rotationX: 0, rotationY: 0, scale: 1, skewX: 0, skewY: 0 }).progress(1), i = e.getBoundingClientRect(); return n && n.progress(0).kill(), i }, Ss = function (e, t) { var n = t.d2; return e["offset" + n] || e["client" + n] || 0 }, Es = function (e) { var t, n = [], i = e.labels, r = e.duration(); for (t in i) n.push(i[t] / r); return n }, Ms = function (e) { var t = ur.utils.snap(e), n = Array.isArray(e) && e.slice(0).sort((function (e, t) { return e - t })); return n ? function (e, i, r) { var s; if (void 0 === r && (r = .001), !i) return t(e); if (i > 0) { for (e -= r, s = 0; s < n.length; s++)if (n[s] >= e) return n[s]; return n[s - 1] } for (s = n.length, e += r; s--;)if (n[s] <= e) return n[s]; return n[0] } : function (n, i, r) { void 0 === r && (r = .001); var s = t(n); return !i || Math.abs(s - n) < r || s - n < 0 == i < 0 ? s : t(i < 0 ? n - e : n + e) } }, Ts = function (e, t, n, i) { return n.split(",").forEach((function (n) { return e(t, n, i) })) }, Cs = function (e, t, n, i, r) { return e.addEventListener(t, n, { passive: !i, capture: !!r }) }, Ds = function (e, t, n) { return e.removeEventListener(t, n) }, Ls = function (e, t, n) { return n && n.wheelHandler && e(t, "wheel", n) }, As = { startColor: "green", endColor: "red", indent: 0, fontSize: "16px", fontWeight: "normal" }, Ps = { toggleActions: "play", anticipatePin: 0 }, Rs = { top: 0, left: 0, center: .5, bottom: 1, right: 1 }, Os = function (e, t) { if (is(e)) { var n = e.indexOf("="), i = ~n ? +(e.charAt(n - 1) + 1) * parseFloat(e.substr(n + 1)) : 0; ~n && (e.indexOf("%") > n && (i *= t / 100), e = e.substr(0, n - 1)), e = i + (e in Rs ? Rs[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0) } return e }, Is = function (e, t, n, i, r, s, a, o) { var l = r.startColor, c = r.endColor, u = r.fontSize, h = r.indent, d = r.fontWeight, p = pr.createElement("div"), f = Qr(n) || "fixed" === Xi(n, "pinType"), m = -1 !== e.indexOf("scroller"), g = f ? mr : n, v = -1 !== e.indexOf("start"), y = v ? l : c, x = "border-color:" + y + ";font-size:" + u + ";color:" + y + ";font-weight:" + d + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;"; return x += "position:" + ((m || o) && f ? "fixed;" : "absolute;"), (m || o || !f) && (x += (i === tr ? ds : ps) + ":" + (s + parseFloat(h)) + "px;"), a && (x += "box-sizing:border-box;text-align:left;width:" + a.offsetWidth + "px;"), p._isStart = v, p.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")), p.style.cssText = x, p.innerText = t || 0 === t ? e + "-" + t : e, g.children[0] ? g.insertBefore(p, g.children[0]) : g.appendChild(p), p._offset = p["offset" + i.op.d2], Fs(p, 0, i, v), p }, Fs = function (e, t, n, i) { var r = { display: "block" }, s = n[i ? "os2" : "p2"], a = n[i ? "p2" : "os2"]; e._isFlipped = i, r[n.a + "Percent"] = i ? -100 : 0, r[n.a] = i ? "1px" : 0, r["border" + s + ys] = 1, r["border" + a + ys] = 0, r[n.p] = t + "px", ur.set(e, r) }, zs = [], ks = {}, Ns = function () { return Gr() - Wr > 34 && na() }, Bs = function () { Rr && Rr.isPressed || (ji.cache++, kr || (kr = requestAnimationFrame(na)), Wr || $s("scrollStart"), Wr = Gr()) }, Hs = function () { Fr = dr.innerWidth, Ir = dr.innerHeight }, Us = function () { ji.cache++, !br && !Pr && !pr.fullscreenElement && (!Or || Fr !== dr.innerWidth || Math.abs(dr.innerHeight - Ir) > .25 * dr.innerHeight) && vr.restart(!0) }, Vs = {}, Gs = [], js = [], Ws = function (e) { var t, n = ur.ticker.frame, i = [], r = 0; if (Br !== n || Vr) { for (Zs(); r < js.length; r += 4)(t = dr.matchMedia(js[r]).matches) !== js[r + 3] && (js[r + 3] = t, t ? i.push(r) : Zs(1, js[r]) || rs(js[r + 2]) && js[r + 2]()); for (Ys(), r = 0; r < i.length; r++)t = i[r], Nr = js[t], js[t + 2] = js[t + 1](e); Nr = 0, hr && Qs(0, 1), Br = n, $s("matchMedia") } }, qs = function e() { return Ds(fa, "scrollEnd", e) || Qs(!0) }, $s = function (e) { return Vs[e] && Vs[e].map((function (e) { return e() })) || Gs }, Xs = [], Ys = function (e) { for (var t = 0; t < Xs.length; t += 5)e && Xs[t + 4] !== e || (Xs[t].style.cssText = Xs[t + 1], Xs[t].getBBox && Xs[t].setAttribute("transform", Xs[t + 2] || ""), Xs[t + 3].uncache = 1) }, Zs = function (e, t) { var n; for (Mr = 0; Mr < zs.length; Mr++)n = zs[Mr], t && n.media !== t || (e ? n.kill(1) : n.revert()); t && Ys(t), t || $s("revert") }, Ks = function () { return ji.cache++ && ji.forEach((function (e) { return "function" == typeof e && (e.rec = 0) })) }, Js = 0, Qs = function (e, t) { if (!Wr || e) { Hr = !0; var n = $s("refreshInit"); Lr && fa.sort(), t || Zs(), zs.slice(0).forEach((function (e) { return e.refresh() })), zs.forEach((function (e) { return "max" === e.vars.end && e.setPositions(e.start, ts(e.scroller, e._dir)) })), n.forEach((function (e) { return e && e.render && e.render(-1) })), Ks(), vr.pause(), Js++, Hr = !1, $s("refresh") } else Cs(fa, "scrollEnd", qs) }, ea = 0, ta = 1, na = function () { if (!Hr) { Ur && Ur.update(0), fa.isUpdating = !0; var e = zs.length, t = Gr(), n = t - jr >= 50, i = e && zs[0].scroll(); if (ta = ea > i ? -1 : 1, ea = i, n && (Wr && !Sr && t - Wr > 200 && (Wr = 0, $s("scrollEnd")), _r = jr, jr = t), ta < 0) { for (Mr = e; Mr-- > 0;)zs[Mr] && zs[Mr].update(0, n); ta = 1 } else for (Mr = 0; Mr < e; Mr++)zs[Mr] && zs[Mr].update(0, n); fa.isUpdating = !1 } kr = 0 }, ia = ["left", "top", ps, ds, "marginBottom", "marginRight", "marginTop", "marginLeft", "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], ra = ia.concat([fs, ms, "boxSizing", "maxWidth", "maxHeight", "position", vs, gs, "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"]), sa = function (e, t, n, i) { if (e.parentNode !== t) { for (var r, s = ia.length, a = t.style, o = e.style; s--;)a[r = ia[s]] = n[r]; a.position = "absolute" === n.position ? "absolute" : "relative", "inline" === n.display && (a.display = "inline-block"), o.bottom = o.right = a.flexBasis = "auto", a.overflow = "visible", a.boxSizing = "border-box", a.width = Ss(e, er) + xs, a.height = Ss(e, tr) + xs, a.padding = o.margin = o.top = o.left = "0", oa(i), o.width = o.maxWidth = n.width, o.height = o.maxHeight = n.height, o.padding = n.padding, e.parentNode.insertBefore(t, e), t.appendChild(e) } }, aa = /([A-Z])/g, oa = function (e) { if (e) { var t, n, i = e.t.style, r = e.length, s = 0; for ((e.t._gsap || ur.core.getCache(e.t)).uncache = 1; s < r; s += 2)n = e[s + 1], t = e[s], n ? i[t] = n : i[t] && i.removeProperty(t.replace(aa, "-$1").toLowerCase()) } }, la = function (e) { for (var t = ra.length, n = e.style, i = [], r = 0; r < t; r++)i.push(ra[r], n[ra[r]]); return i.t = e, i }, ca = { left: 0, top: 0 }, ua = function (e, t, n, i, r, s, a, o, l, c, u, h, d) { rs(e) && (e = e(o)), is(e) && "max" === e.substr(0, 3) && (e = h + ("=" === e.charAt(4) ? Os("0" + e.substr(3), n) : 0)); var p, f, m, g = d ? d.time() : 0; if (d && d.seek(0), ss(e)) a && Fs(a, n, i, !0); else { rs(t) && (t = t(o)); var v, y, x, _, w = e.split(" "); m = nr(t) || mr, (v = bs(m) || {}) && (v.left || v.top) || "none" !== _s(m).display || (_ = m.style.display, m.style.display = "block", v = bs(m), _ ? m.style.display = _ : m.style.removeProperty("display")), y = Os(w[0], v[i.d]), x = Os(w[1] || "0", n), e = v[i.p] - l[i.p] - c + y + r - x, a && Fs(a, x, i, n - x < 20 || a._isStart && x > 20), n -= n - x } if (s) { var b = e + n, S = s._isStart; p = "scroll" + i.d2, Fs(s, b, i, S && b > 20 || !S && (u ? Math.max(mr[p], fr[p]) : s.parentNode[p]) <= b + 1), u && (l = bs(a), u && (s.style[i.op.p] = l[i.op.p] - i.op.m - s._offset + xs)) } return d && m && (p = bs(m), d.seek(h), f = bs(m), d._caScrollDist = p[i.p] - f[i.p], e = e / d._caScrollDist * h), d && d.seek(g), d ? e : Math.round(e) }, ha = /(webkit|moz|length|cssText|inset)/i, da = function (e, t, n, i) { if (e.parentNode !== t) { var r, s, a = e.style; if (t === mr) { for (r in e._stOrig = a.cssText, s = _s(e)) +r || ha.test(r) || !s[r] || "string" != typeof a[r] || "0" === r || (a[r] = s[r]); a.top = n, a.left = i } else a.cssText = e._stOrig; ur.core.getCache(e).uncache = 1, t.appendChild(e) } }, pa = function (e, t) { var n, i, r = ir(e, t), s = "_scroll" + t.p2, a = function t(a, o, l, c, u) { var h = t.tween, d = o.onComplete, p = {}; return l = l || r(), u = c && u || 0, c = c || a - l, h && h.kill(), n = Math.round(l), o[s] = a, o.modifiers = p, p[s] = function (e) { return (e = Zr(r())) !== n && e !== i && Math.abs(e - n) > 2 && Math.abs(e - i) > 2 ? (h.kill(), t.tween = 0) : e = l + c * h.ratio + u * h.ratio * h.ratio, i = n, n = Zr(e) }, o.onComplete = function () { t.tween = 0, d && d.call(h) }, h = t.tween = ur.to(e, o) }; return e[s] = r, r.wheelHandler = function () { return a.tween && a.tween.kill() && (a.tween = 0) }, Cs(e, "wheel", r.wheelHandler), a }, fa = function () { function e(t, n) { hr || e.register(ur) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), this.init(t, n) } return e.prototype.init = function (t, n) { if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), qr) { var i, r, s, a, o, l, c, u, h, d, p, f, m, g, v, y, x, _, w, b, S, E, M, T, C, D, L, A, P, R, O, I, F, z, k, N, B, H, U, V, G, j = t = ws(is(t) || ss(t) || t.nodeType ? { trigger: t } : t, Ps), W = j.onUpdate, q = j.toggleClass, $ = j.id, X = j.onToggle, Y = j.onRefresh, Z = j.scrub, K = j.trigger, J = j.pin, Q = j.pinSpacing, ee = j.invalidateOnRefresh, te = j.anticipatePin, ne = j.onScrubComplete, ie = j.onSnapComplete, re = j.once, se = j.snap, ae = j.pinReparent, oe = j.pinSpacer, le = j.containerAnimation, ce = j.fastScrollEnd, ue = j.preventOverlaps, he = t.horizontal || t.containerAnimation && !1 !== t.horizontal ? er : tr, de = !Z && 0 !== Z, pe = nr(t.scroller || dr), fe = ur.core.getCache(pe), me = Qr(pe), ge = "fixed" === ("pinType" in t ? t.pinType : Xi(pe, "pinType") || me && "fixed"), ve = [t.onEnter, t.onLeave, t.onEnterBack, t.onLeaveBack], ye = de && t.toggleActions.split(" "), xe = "markers" in t ? t.markers : Ps.markers, _e = me ? 0 : parseFloat(_s(pe)["border" + he.p2 + ys]) || 0, we = this, be = t.onRefreshInit && function () { return t.onRefreshInit(we) }, Se = function (e, t, n) { var i = n.d, r = n.d2, s = n.a; return (s = Xi(e, "getBoundingClientRect")) ? function () { return s()[i] } : function () { return (t ? dr["inner" + r] : e["client" + r]) || 0 } }(pe, me, he), Ee = function (e, t) { return !t || ~Wi.indexOf(e) ? es(e) : function () { return ca } }(pe, me), Me = 0, Te = 0, Ce = ir(pe, he); if (we.media = Nr, we._dir = he, te *= 45, we.scroller = pe, we.scroll = le ? le.time.bind(le) : Ce, a = Ce(), we.vars = t, n = n || t.animation, "refreshPriority" in t && (Lr = 1, -9999 === t.refreshPriority && (Ur = we)), fe.tweenScroll = fe.tweenScroll || { top: pa(pe, tr), left: pa(pe, er) }, we.tweenTo = i = fe.tweenScroll[he.p], we.scrubDuration = function (e) { (O = ss(e) && e) ? R ? R.duration(e) : R = ur.to(n, { ease: "expo", totalProgress: "+=0.001", duration: O, paused: !0, onComplete: function () { return ne && ne(we) } }) : (R && R.progress(1).kill(), R = 0) }, n && (n.vars.lazy = !1, n._initted || !1 !== n.vars.immediateRender && !1 !== t.immediateRender && n.render(0, !0, !0), we.animation = n.pause(), n.scrollTrigger = we, we.scrubDuration(Z), A = 0, $ || ($ = n.vars.id)), zs.push(we), se && (as(se) && !se.push || (se = { snapTo: se }), "scrollBehavior" in mr.style && ur.set(me ? [mr, fr] : pe, { scrollBehavior: "auto" }), s = rs(se.snapTo) ? se.snapTo : "labels" === se.snapTo ? function (e) { return function (t) { return ur.utils.snap(Es(e), t) } }(n) : "labelsDirectional" === se.snapTo ? (U = n, function (e, t) { return Ms(Es(U))(e, t.direction) }) : !1 !== se.directional ? function (e, t) { return Ms(se.snapTo)(e, Gr() - Te < 500 ? 0 : t.direction) } : ur.utils.snap(se.snapTo), I = se.duration || { min: .1, max: 2 }, I = as(I) ? xr(I.min, I.max) : xr(I, I), F = ur.delayedCall(se.delay || O / 2 || .1, (function () { var e = Ce(), t = Gr() - Te < 500, r = i.tween; if (!(t || Math.abs(we.getVelocity()) < 10) || r || Sr || Me === e) we.isActive && Me !== e && F.restart(!0); else { var a = (e - l) / m, o = n && !de ? n.totalProgress() : a, u = t ? 0 : (o - P) / (Gr() - _r) * 1e3 || 0, h = ur.utils.clamp(-a, 1 - a, hs(u / 2) * u / .185), d = a + (!1 === se.inertia ? 0 : h), p = xr(0, 1, s(d, we)), f = Math.round(l + p * m), g = se, v = g.onStart, y = g.onInterrupt, x = g.onComplete; if (e <= c && e >= l && f !== e) { if (r && !r._initted && r.data <= hs(f - e)) return; !1 === se.inertia && (h = p - a), i(f, { duration: I(hs(.185 * Math.max(hs(d - o), hs(p - o)) / u / .05 || 0)), ease: se.ease || "power3", data: hs(f - e), onInterrupt: function () { return F.restart(!0) && y && y(we) }, onComplete: function () { we.update(), Me = Ce(), A = P = n && !de ? n.totalProgress() : we.progress, ie && ie(we), x && x(we) } }, e, h * m, f - e - h * m), v && v(we, i.tween) } } })).pause()), $ && (ks[$] = we), (H = (K = we.trigger = nr(K || J)) && K._gsap && K._gsap.stRevert) && (H = H(we)), J = !0 === J ? K : nr(J), is(q) && (q = { targets: K, className: q }), J && (!1 === Q || Q === vs || (Q = !(!Q && "flex" === _s(J.parentNode).display) && gs), we.pin = J, !1 !== t.force3D && ur.set(J, { force3D: !0 }), (r = ur.core.getCache(J)).spacer ? g = r.pinState : (oe && ((oe = nr(oe)) && !oe.nodeType && (oe = oe.current || oe.nativeElement), r.spacerIsNative = !!oe, oe && (r.spacerState = la(oe))), r.spacer = x = oe || pr.createElement("div"), x.classList.add("pin-spacer"), $ && x.classList.add("pin-spacer-" + $), r.pinState = g = la(J)), we.spacer = x = r.spacer, L = _s(J), M = L[Q + he.os2], w = ur.getProperty(J), b = ur.quickSetter(J, he.a, xs), sa(J, x, L), y = la(J)), xe) { f = as(xe) ? ws(xe, As) : As, d = Is("scroller-start", $, pe, he, f, 0), p = Is("scroller-end", $, pe, he, f, 0, d), _ = d["offset" + he.op.d2]; var De = nr(Xi(pe, "content") || pe); u = this.markerStart = Is("start", $, De, he, f, _, 0, le), h = this.markerEnd = Is("end", $, De, he, f, _, 0, le), le && (B = ur.quickSetter([u, h], he.a, xs)), ge || Wi.length && !0 === Xi(pe, "fixedMarkers") || (G = _s(V = me ? mr : pe).position, V.style.position = "absolute" === G || "fixed" === G ? G : "relative", ur.set([d, p], { force3D: !0 }), C = ur.quickSetter(d, he.a, xs), D = ur.quickSetter(p, he.a, xs)) } if (le) { var Le = le.vars.onUpdate, Ae = le.vars.onUpdateParams; le.eventCallback("onUpdate", (function () { we.update(0, 0, 1), Le && Le.apply(Ae || []) })) } we.previous = function () { return zs[zs.indexOf(we) - 1] }, we.next = function () { return zs[zs.indexOf(we) + 1] }, we.revert = function (e) { var t = !1 !== e || !we.enabled, i = br; t !== we.isReverted && (t && (we.scroll.rec || !br || !Hr || (we.scroll.rec = Ce()), k = Math.max(Ce(), we.scroll.rec || 0), z = we.progress, N = n && n.progress()), u && [u, h, d, p].forEach((function (e) { return e.style.display = t ? "none" : "block" })), t && (br = 1), we.update(t), br = i, J && (t ? function (e, t, n) { oa(n); var i = e._gsap; if (i.spacerIsNative) oa(i.spacerState); else if (e.parentNode === t) { var r = t.parentNode; r && (r.insertBefore(e, t), r.removeChild(t)) } }(J, x, g) : (!ae || !we.isActive) && sa(J, x, _s(J), T)), we.isReverted = t) }, we.refresh = function (r, s) { if (!br && we.enabled || s) if (J && r && Wr) Cs(e, "scrollEnd", qs); else { !Hr && be && be(we), br = 1, Te = Gr(), i.tween && (i.tween.kill(), i.tween = 0), R && R.pause(), ee && n && n.time(-.01, !0).invalidate(), we.isReverted || we.revert(); for (var f, _, b, M, C, D, L, A, P, O, I = Se(), B = Ee(), H = le ? le.duration() : ts(pe, he), U = 0, V = 0, G = t.end, j = t.endTrigger || K, W = t.start || (0 !== t.start && K ? J ? "0 0" : "0 100%" : 0), q = we.pinnedContainer = t.pinnedContainer && nr(t.pinnedContainer), $ = K && Math.max(0, zs.indexOf(we)) || 0, X = $; X--;)(D = zs[X]).end || D.refresh(0, 1) || (br = 1), !(L = D.pin) || L !== K && L !== J || D.isReverted || (O || (O = []), O.unshift(D), D.revert()), D !== zs[X] && ($--, X--); for (rs(W) && (W = W(we)), l = ua(W, K, I, he, Ce(), u, d, we, B, _e, ge, H, le) || (J ? -.001 : 0), rs(G) && (G = G(we)), is(G) && !G.indexOf("+=") && (~G.indexOf(" ") ? G = (is(W) ? W.split(" ")[0] : "") + G : (U = Os(G.substr(2), I), G = is(W) ? W : l + U, j = K)), c = Math.max(l, ua(G || (j ? "100% 0" : H), j, I, he, Ce() + U, h, p, we, B, _e, ge, H, le)) || -.001, m = c - l || (l -= .01) && .001, U = 0, X = $; X--;)(L = (D = zs[X]).pin) && D.start - D._pinPush < l && !le && D.end > 0 && (f = D.end - D.start, L !== K && L !== q || ss(W) || (U += f * (1 - D.progress)), L === J && (V += f)); if (l += U, c += U, we._pinPush = V, u && U && ((f = {})[he.a] = "+=" + U, q && (f[he.p] = "-=" + Ce()), ur.set([u, h], f)), J) f = _s(J), M = he === tr, b = Ce(), S = parseFloat(w(he.a)) + V, !H && c > 1 && ((me ? mr : pe).style["overflow-" + he.a] = "scroll"), sa(J, x, f), y = la(J), _ = bs(J, !0), A = ge && ir(pe, M ? er : tr)(), Q && ((T = [Q + he.os2, m + V + xs]).t = x, (X = Q === gs ? Ss(J, he) + m + V : 0) && T.push(he.d, X + xs), oa(T), ge && Ce(k)), ge && ((C = { top: _.top + (M ? b - l : A) + xs, left: _.left + (M ? A : b - l) + xs, boxSizing: "border-box", position: "fixed" }).width = C.maxWidth = Math.ceil(_.width) + xs, C.height = C.maxHeight = Math.ceil(_.height) + xs, C.margin = C.marginTop = C.marginRight = C.marginBottom = C.marginLeft = "0", C.padding = f.padding, C.paddingTop = f.paddingTop, C.paddingRight = f.paddingRight, C.paddingBottom = f.paddingBottom, C.paddingLeft = f.paddingLeft, v = function (e, t, n) { for (var i, r = [], s = e.length, a = n ? 8 : 0; a < s; a += 2)i = e[a], r.push(i, i in t ? t[i] : e[a + 1]); return r.t = e.t, r }(g, C, ae)), n ? (P = n._initted, Ar(1), n.render(n.duration(), !0, !0), E = w(he.a) - S + m + V, m !== E && v.splice(v.length - 2, 2), n.render(0, !0, !0), P || n.invalidate(), Ar(0)) : E = m; else if (K && Ce() && !le) for (_ = K.parentNode; _ && _ !== mr;)_._pinOffset && (l -= _._pinOffset, c -= _._pinOffset), _ = _.parentNode; O && O.forEach((function (e) { return e.revert(!1) })), we.start = l, we.end = c, a = o = Ce(), le || (a < k && Ce(k), we.scroll.rec = 0), we.revert(!1), F && (Me = -1, we.isActive && Ce(l + m * z), F.restart(!0)), br = 0, n && de && (n._initted || N) && n.progress() !== N && n.progress(N, !0).render(n.time(), !0, !0), (z !== we.progress || le) && (n && !de && n.totalProgress(z, !0), we.progress = z, we.update(0, 0, 1)), J && Q && (x._pinOffset = Math.round(we.progress * E)), Y && Y(we) } }, we.getVelocity = function () { return (Ce() - o) / (Gr() - _r) * 1e3 || 0 }, we.endAnimation = function () { cs(we.callbackAnimation), n && (R ? R.progress(1) : n.paused() ? de || cs(n, we.direction < 0, 1) : cs(n, n.reversed())) }, we.labelToScroll = function (e) { return n && n.labels && (l || we.refresh() || l) + n.labels[e] / n.duration() * m || 0 }, we.getTrailing = function (e) { var t = zs.indexOf(we), n = we.direction > 0 ? zs.slice(0, t).reverse() : zs.slice(t + 1); return (is(e) ? n.filter((function (t) { return t.vars.preventOverlaps === e })) : n).filter((function (e) { return we.direction > 0 ? e.end <= l : e.start >= c })) }, we.update = function (e, t, r) { if (!le || r || e) { var s, u, h, p, f, g, _, w = we.scroll(), T = e ? 0 : (w - l) / m, L = T < 0 ? 0 : T > 1 ? 1 : T || 0, O = we.progress; if (t && (o = a, a = le ? Ce() : w, se && (P = A, A = n && !de ? n.totalProgress() : L)), te && !L && J && !br && !Vr && Wr && l < w + (w - o) / (Gr() - _r) * te && (L = 1e-4), L !== O && we.enabled) { if (p = (f = (s = we.isActive = !!L && L < 1) != (!!O && O < 1)) || !!L != !!O, we.direction = L > O ? 1 : -1, we.progress = L, p && !br && (u = L && !O ? 0 : 1 === L ? 1 : 1 === O ? 2 : 3, de && (h = !f && "none" !== ye[u + 1] && ye[u + 1] || ye[u], _ = n && ("complete" === h || "reset" === h || h in n))), ue && (f || _) && (_ || Z || !n) && (rs(ue) ? ue(we) : we.getTrailing(ue).forEach((function (e) { return e.endAnimation() }))), de || (!R || br || Vr ? n && n.totalProgress(L, !!br) : ((le || Ur && Ur !== we) && R.render(R._dp._time - R._start), R.resetTo ? R.resetTo("totalProgress", L, n._tTime / n._tDur) : (R.vars.totalProgress = L, R.invalidate().restart()))), J) if (e && Q && (x.style[Q + he.os2] = M), ge) { if (p) { if (g = !e && L > O && c + 1 > w && w + 1 >= ts(pe, he), ae) if (e || !s && !g) da(J, x); else { var I = bs(J, !0), z = w - l; da(J, mr, I.top + (he === tr ? z : 0) + xs, I.left + (he === tr ? 0 : z) + xs) } oa(s || g ? v : y), E !== m && L < 1 && s || b(S + (1 !== L || g ? 0 : E)) } } else b(Zr(S + E * L)); se && !i.tween && !br && !Vr && F.restart(!0), q && (f || re && L && (L < 1 || !zr)) && yr(q.targets).forEach((function (e) { return e.classList[s || re ? "add" : "remove"](q.className) })), W && !de && !e && W(we), p && !br ? (de && (_ && ("complete" === h ? n.pause().totalProgress(1) : "reset" === h ? n.restart(!0).pause() : "restart" === h ? n.restart(!0) : n[h]()), W && W(we)), !f && zr || (X && f && us(we, X), ve[u] && us(we, ve[u]), re && (1 === L ? we.kill(!1, 1) : ve[u] = 0), f || ve[u = 1 === L ? 1 : 3] && us(we, ve[u])), ce && !s && Math.abs(we.getVelocity()) > (ss(ce) ? ce : 2500) && (cs(we.callbackAnimation), R ? R.progress(1) : cs(n, !L, 1))) : de && W && !br && W(we) } if (D) { var k = le ? w / le.duration() * (le._caScrollDist || 0) : w; C(k + (d._isFlipped ? 1 : 0)), D(k) } B && B(-w / le.duration() * (le._caScrollDist || 0)) } }, we.enable = function (t, n) { we.enabled || (we.enabled = !0, Cs(pe, "resize", Us), Cs(me ? pr : pe, "scroll", Bs), be && Cs(e, "refreshInit", be), !1 !== t && (we.progress = z = 0, a = o = Me = Ce()), !1 !== n && we.refresh()) }, we.getTween = function (e) { return e && i ? i.tween : R }, we.setPositions = function (e, t) { J && (S += e - l, E += t - e - m), we.start = l = e, we.end = c = t, m = t - e, we.update() }, we.disable = function (t, n) { if (we.enabled && (!1 !== t && we.revert(), we.enabled = we.isActive = !1, n || R && R.pause(), k = 0, r && (r.uncache = 1), be && Ds(e, "refreshInit", be), F && (F.pause(), i.tween && i.tween.kill() && (i.tween = 0)), !me)) { for (var s = zs.length; s--;)if (zs[s].scroller === pe && zs[s] !== we) return; Ds(pe, "resize", Us), Ds(pe, "scroll", Bs) } }, we.kill = function (e, i) { we.disable(e, i), R && !i && R.kill(), $ && delete ks[$]; var s = zs.indexOf(we); s >= 0 && zs.splice(s, 1), s === Mr && ta > 0 && Mr--, s = 0, zs.forEach((function (e) { return e.scroller === we.scroller && (s = 1) })), s || (we.scroll.rec = 0), n && (n.scrollTrigger = null, e && n.render(-1), i || n.kill()), u && [u, h, d, p].forEach((function (e) { return e.parentNode && e.parentNode.removeChild(e) })), Ur === we && (Ur = 0), J && (r && (r.uncache = 1), s = 0, zs.forEach((function (e) { return e.pin === J && s++ })), s || (r.spacer = 0)), t.onKill && t.onKill(we) }, we.enable(!1, !1), H && H(we), n && n.add && !m ? ur.delayedCall(.01, (function () { return l || c || we.refresh() })) && (m = .01) && (l = c = 0) : we.refresh() } else this.update = this.refresh = this.kill = Yr }, e.register = function (t) { return hr || (ur = t || Jr(), Kr() && window.document && e.enable(), hr = qr), hr }, e.defaults = function (e) { if (e) for (var t in e) Ps[t] = e[t]; return Ps }, e.disable = function (e, t) { qr = 0, zs.forEach((function (n) { return n[t ? "kill" : "disable"](e) })), Ds(dr, "wheel", Bs), Ds(pr, "scroll", Bs), clearInterval(wr), Ds(pr, "touchcancel", Yr), Ds(mr, "touchstart", Yr), Ts(Ds, pr, "pointerdown,touchstart,mousedown", $r), Ts(Ds, pr, "pointerup,touchend,mouseup", Xr), vr.kill(), ns(Ds); for (var n = 0; n < ji.length; n += 3)Ls(Ds, ji[n], ji[n + 1]), Ls(Ds, ji[n], ji[n + 2]) }, e.enable = function () { if (dr = window, pr = document, fr = pr.documentElement, mr = pr.body, ur && (yr = ur.utils.toArray, xr = ur.utils.clamp, Ar = ur.core.suppressOverwrites || Yr, ur.core.globals("ScrollTrigger", e), mr)) { qr = 1, cr.register(ur), e.isTouch = cr.isTouch, Cs(dr, "wheel", Bs), gr = [dr, pr, fr, mr], e.matchMedia({ "(orientation: portrait)": function () { return Hs(), Hs } }), Cs(pr, "scroll", Bs); var t, n, i = mr.style, r = i.borderTopStyle; for (i.borderTopStyle = "solid", t = bs(mr), tr.m = Math.round(t.top + tr.sc()) || 0, er.m = Math.round(t.left + er.sc()) || 0, r ? i.borderTopStyle = r : i.removeProperty("border-top-style"), wr = setInterval(Ns, 250), ur.delayedCall(.5, (function () { return Vr = 0 })), Cs(pr, "touchcancel", Yr), Cs(mr, "touchstart", Yr), Ts(Cs, pr, "pointerdown,touchstart,mousedown", $r), Ts(Cs, pr, "pointerup,touchend,mouseup", Xr), Er = ur.utils.checkPrefix("transform"), ra.push(Er), hr = Gr(), vr = ur.delayedCall(.2, Qs).pause(), Dr = [pr, "visibilitychange", function () { var e = dr.innerWidth, t = dr.innerHeight; pr.hidden ? (Tr = e, Cr = t) : Tr === e && Cr === t || Us() }, pr, "DOMContentLoaded", Qs, dr, "load", Qs, dr, "resize", Us], ns(Cs), zs.forEach((function (e) { return e.enable(0, 1) })), n = 0; n < ji.length; n += 3)Ls(Ds, ji[n], ji[n + 1]), Ls(Ds, ji[n], ji[n + 2]) } }, e.config = function (t) { "limitCallbacks" in t && (zr = !!t.limitCallbacks); var n = t.syncInterval; n && clearInterval(wr) || (wr = n) && setInterval(Ns, n), "ignoreMobileResize" in t && (Or = 1 === e.isTouch && t.ignoreMobileResize), "autoRefreshEvents" in t && (ns(Ds) || ns(Cs, t.autoRefreshEvents || "none"), Pr = -1 === (t.autoRefreshEvents + "").indexOf("resize")) }, e.scrollerProxy = function (e, t) { var n = nr(e), i = ji.indexOf(n), r = Qr(n); ~i && ji.splice(i, r ? 6 : 2), t && (r ? Wi.unshift(dr, t, mr, t, fr, t) : Wi.unshift(n, t)) }, e.matchMedia = function (e) { var t, n, i, r, s; for (n in e) i = js.indexOf(n), r = e[n], Nr = n, "all" === n ? r() : (t = dr.matchMedia(n)) && (t.matches && (s = r()), ~i ? (js[i + 1] = ls(js[i + 1], r), js[i + 2] = ls(js[i + 2], s)) : (i = js.length, js.push(n, r, s), t.addListener ? t.addListener(Ws) : t.addEventListener("change", Ws)), js[i + 3] = t.matches), Nr = 0; return js }, e.clearMatchMedia = function (e) { e || (js.length = 0), (e = js.indexOf(e)) >= 0 && js.splice(e, 4) }, e.isInViewport = function (e, t, n) { var i = (is(e) ? nr(e) : e).getBoundingClientRect(), r = i[n ? fs : ms] * t || 0; return n ? i.right - r > 0 && i.left + r < dr.innerWidth : i.bottom - r > 0 && i.top + r < dr.innerHeight }, e.positionInViewport = function (e, t, n) { is(e) && (e = nr(e)); var i = e.getBoundingClientRect(), r = i[n ? fs : ms], s = null == t ? r / 2 : t in Rs ? Rs[t] * r : ~t.indexOf("%") ? parseFloat(t) * r / 100 : parseFloat(t) || 0; return n ? (i.left + s) / dr.innerWidth : (i.top + s) / dr.innerHeight }, e }(); fa.version = "3.10.3", fa.saveStyles = function (e) { return e ? yr(e).forEach((function (e) { if (e && e.style) { var t = Xs.indexOf(e); t >= 0 && Xs.splice(t, 5), Xs.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), ur.core.getCache(e), Nr) } })) : Xs }, fa.revert = function (e, t) { return Zs(!e, t) }, fa.create = function (e, t) { return new fa(e, t) }, fa.refresh = function (e) { return e ? Us() : (hr || fa.register()) && Qs(!0) }, fa.update = na, fa.clearScrollMemory = Ks, fa.maxScroll = function (e, t) { return ts(e, t ? er : tr) }, fa.getScrollFunc = function (e, t) { return ir(nr(e), t ? er : tr) }, fa.getById = function (e) { return ks[e] }, fa.getAll = function () { return zs.filter((function (e) { return "ScrollSmoother" !== e.vars.id })) }, fa.isScrolling = function () { return !!Wr }, fa.snapDirectional = Ms, fa.addEventListener = function (e, t) { var n = Vs[e] || (Vs[e] = []); ~n.indexOf(t) || n.push(t) }, fa.removeEventListener = function (e, t) { var n = Vs[e], i = n && n.indexOf(t); i >= 0 && n.splice(i, 1) }, fa.batch = function (e, t) { var n, i = [], r = {}, s = t.interval || .016, a = t.batchMax || 1e9, o = function (e, t) { var n = [], i = [], r = ur.delayedCall(s, (function () { t(n, i), n = [], i = [] })).pause(); return function (e) { n.length || r.restart(!0), n.push(e.trigger), i.push(e), a <= n.length && r.progress(1) } }; for (n in t) r[n] = "on" === n.substr(0, 2) && rs(t[n]) && "onRefreshInit" !== n ? o(0, t[n]) : t[n]; return rs(a) && (a = a(), Cs(fa, "refresh", (function () { return a = t.batchMax() }))), yr(e).forEach((function (e) { var t = {}; for (n in r) t[n] = r[n]; t.trigger = e, i.push(fa.create(t)) })), i }; var ma, ga = function (e, t, n, i) { return t > i ? e(i) : t < 0 && e(0), n > i ? (i - t) / (n - t) : n < 0 ? t / (t - n) : 1 }, va = function e(t, n) { !0 === n ? t.style.removeProperty("touch-action") : t.style.touchAction = n ? "pan-" + n : "none", t === fr && e(mr) }, ya = { auto: 1, scroll: 1 }, xa = function (e) { var t, n = e.event, i = e.target, r = e.axis, s = (n.changedTouches ? n.changedTouches[0] : n).target, a = s._gsap || ur.core.getCache(s), o = Gr(); if (!a._isScrollT || o - a._isScrollT > 2e3) { for (; s && s.scrollHeight <= s.clientHeight;)s = s.parentNode; a._isScroll = s && !Qr(s) && s !== i && (ya[(t = _s(s)).overflowY] || ya[t.overflowX]), a._isScrollT = o } (a._isScroll || "x" === r) && (n._gsapAllow = !0) }, _a = function (e, t, n, i) { return cr.create({ target: e, capture: !0, debounce: !1, lockAxis: !0, type: t, onWheel: i = i && xa, onPress: i, onDrag: i, onScroll: i, onEnable: function () { return n && Cs(pr, cr.eventTypes[0], ba, !1, !0) }, onDisable: function () { return Ds(pr, cr.eventTypes[0], ba) } }) }, wa = /(input|label|select|textarea)/i, ba = function (e) { var t = wa.test(e.target.tagName); (t || ma) && (e._gsapAllow = !0, ma = t) }; fa.sort = function (e) { return zs.sort(e || function (e, t) { return -1e6 * (e.vars.refreshPriority || 0) + e.start - (t.start + -1e6 * (t.vars.refreshPriority || 0)) }) }, fa.observe = function (e) { return new cr(e) }, fa.normalizeScroll = function (e) { if (void 0 === e) return Rr; if (!0 === e && Rr) return Rr.enable(); if (!1 === e) return Rr && Rr.kill(); var t = e instanceof cr ? e : function (e) { as(e) || (e = {}), e.preventDefault = e.isNormalizer = e.allowClicks = !0, e.type || (e.type = "wheel,touch"), e.debounce = !!e.debounce, e.id = e.id || "normalizer"; var t, n, i, r, s, a, o, l, c = e, u = c.normalizeScrollX, h = c.momentum, d = c.allowNestedScroll, p = nr(e.target) || fr, f = ir(p, tr), m = ir(p, er), g = 1, v = 0, y = rs(h) ? function () { return h(t) } : function () { return h || 2.8 }, x = _a(p, e.type, !0, d), _ = function () { return i = !1 }, w = Yr, b = Yr, S = function () { n = ts(p, tr), b = xr(0, n), u && (w = xr(0, ts(p, er))), r = Js }, E = fa.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), M = function () { S(), s.isActive() && s.vars.scrollY > n && s.resetTo("scrollY", ts(p, tr)) }; return e.ignoreCheck = function (e) { return E && "touchmove" === e.type && function () { if (i) return requestAnimationFrame(_), !0; i = !0 }() || g > 1 || t.isGesturing || e.touches && e.touches.length > 1 }, e.onPress = function () { var e = g; g = dr.visualViewport && dr.visualViewport.scale || 1, s.pause(), e !== g && va(p, g > 1 || !u && "x"), i = !1, a = m(), o = f(), S(), r = Js }, e.onRelease = e.onGestureStart = function (e, t) { if (t) { var n, i, r = y(); u && (i = (n = m()) + .05 * r * -e.velocityX / .227 / g, r *= ga(m, n, i, ts(p, er)), s.vars.scrollX = w(i)), i = (n = f()) + .05 * r * -e.velocityY / .227 / g, r *= ga(f, n, i, ts(p, tr)), s.vars.scrollY = b(i), s.invalidate().duration(r).play(.01) } else l.restart(!0) }, e.onWheel = function () { s._ts && s.pause(), Gr() - v > 1e3 && (r = 0, v = Gr()) }, e.onChange = function (e, t, n, i, s) { Js !== r && S(), t && u && m(w(i[2] === t ? a + (e.startX - e.x) / g : m() + t - i[1])), n && f(b(s[2] === n ? o + (e.startY - e.y) / g : f() + n - s[1])), na() }, e.onEnable = function () { va(p, !u && "x"), Cs(dr, "resize", M), x.enable() }, e.onDisable = function () { va(p, !0), Ds(dr, "resize", M), x.kill() }, t = new cr(e), l = t._dc, s = ur.to(t, { ease: "power4", paused: !0, scrollX: u ? "+=0.1" : "+=0", scrollY: "+=0.1", onComplete: l.vars.onComplete }), t }(e); return Rr && Rr.target === t.target && Rr.kill(), Qr(t.target) && (Rr = t), t }, fa.core = { _getVelocityProp: rr, _inputObserver: _a, _scrollers: ji, _proxies: Wi, bridge: { ss: function () { Wr || $s("scrollStart"), Wr = Gr() }, ref: function () { return br } } }, Jr() && ur.registerPlugin(fa); var Sa = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi, Ea = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/gi, Ma = Math.PI / 180, Ta = (Math.PI, Math.sin), Ca = Math.cos, Da = Math.abs, La = Math.sqrt, Aa = (Math.atan2, function (e) { return "number" == typeof e }), Pa = 1e5, Ra = function (e) { return Math.round(e * Pa) / Pa || 0 }; function Oa(e, t, n, i, r, s, a, o, l) { if (e !== o || t !== l) { n = Da(n), i = Da(i); var c = r % 360 * Ma, u = Ca(c), h = Ta(c), d = Math.PI, p = 2 * d, f = (e - o) / 2, m = (t - l) / 2, g = u * f + h * m, v = -h * f + u * m, y = g * g, x = v * v, _ = y / (n * n) + x / (i * i); _ > 1 && (n = La(_) * n, i = La(_) * i); var w = n * n, b = i * i, S = (w * b - w * x - b * y) / (w * x + b * y); S < 0 && (S = 0); var E = (s === a ? -1 : 1) * La(S), M = E * (n * v / i), T = E * (-i * g / n), C = (e + o) / 2 + (u * M - h * T), D = (t + l) / 2 + (h * M + u * T), L = (g - M) / n, A = (v - T) / i, P = (-g - M) / n, R = (-v - T) / i, O = L * L + A * A, I = (A < 0 ? -1 : 1) * Math.acos(L / La(O)), F = (L * R - A * P < 0 ? -1 : 1) * Math.acos((L * P + A * R) / La(O * (P * P + R * R))); isNaN(F) && (F = d), !a && F > 0 ? F -= p : a && F < 0 && (F += p), I %= p, F %= p; var z, k = Math.ceil(Da(F) / (p / 4)), N = [], B = F / k, H = 4 / 3 * Ta(B / 2) / (1 + Ca(B / 2)), U = u * n, V = h * n, G = h * -i, j = u * i; for (z = 0; z < k; z++)g = Ca(r = I + z * B), v = Ta(r), L = Ca(r += B), A = Ta(r), N.push(g - H * v, v + H * g, L + H * A, A - H * L, L, A); for (z = 0; z < N.length; z += 2)g = N[z], v = N[z + 1], N[z] = g * U + v * G + C, N[z + 1] = g * V + v * j + D; return N[z - 2] = o, N[z - 1] = l, N } } var Ia, Fa, za = function () { return Ia || "undefined" != typeof window && (Ia = window.gsap) && Ia.registerPlugin && Ia }, ka = function () { (Ia = za()) ? (Ia.registerEase("_CE", Va.create), Fa = 1) : console.warn("Please gsap.registerPlugin(CustomEase)") }, Na = function (e) { return ~~(1e3 * e + (e < 0 ? -.5 : .5)) / 1e3 }, Ba = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi, Ha = /[cLlsSaAhHvVtTqQ]/g, Ua = function e(t, n, i, r, s, a, o, l, c, u, h) { var d, p = (t + i) / 2, f = (n + r) / 2, m = (i + s) / 2, g = (r + a) / 2, v = (s + o) / 2, y = (a + l) / 2, x = (p + m) / 2, _ = (f + g) / 2, w = (m + v) / 2, b = (g + y) / 2, S = (x + w) / 2, E = (_ + b) / 2, M = o - t, T = l - n, C = Math.abs((i - o) * T - (r - l) * M), D = Math.abs((s - o) * T - (a - l) * M); return u || (u = [{ x: t, y: n }, { x: o, y: l }], h = 1), u.splice(h || u.length - 1, 0, { x: S, y: E }), (C + D) * (C + D) > c * (M * M + T * T) && (d = u.length, e(t, n, p, f, x, _, S, E, c, u, h), e(S, E, w, b, v, y, o, l, c, u, h + 1 + (u.length - d))), u }, Va = function () { function e(e, t, n) { Fa || ka(), this.id = e, this.setData(t, n) } var t = e.prototype; return t.setData = function (e, t) { t = t || {}; var n, i, r, s, a, o, l, c, u, h = (e = e || "0,0,1,1").match(Ba), d = 1, p = [], f = [], m = t.precision || 1, g = m <= 1; if (this.data = e, (Ha.test(e) || ~e.indexOf("M") && e.indexOf("C") < 0) && (h = function (e) { var t, n, i, r, s, a, o, l, c, u, h, d, p, f, m, g = (e + "").replace(Ea, (function (e) { var t = +e; return t < 1e-4 && t > -1e-4 ? 0 : t })).match(Sa) || [], v = [], y = 0, x = 0, _ = 2 / 3, w = g.length, b = 0, S = "ERROR: malformed path: " + e, E = function (e, t, n, i) { u = (n - e) / 3, h = (i - t) / 3, o.push(e + u, t + h, n - u, i - h, n, i) }; if (!e || !isNaN(g[0]) || isNaN(g[1])) return console.log(S), v; for (t = 0; t < w; t++)if (p = s, isNaN(g[t]) ? a = (s = g[t].toUpperCase()) !== g[t] : t--, i = +g[t + 1], r = +g[t + 2], a && (i += y, r += x), t || (l = i, c = r), "M" === s) o && (o.length < 8 ? v.length -= 1 : b += o.length), y = l = i, x = c = r, o = [i, r], v.push(o), t += 2, s = "L"; else if ("C" === s) o || (o = [0, 0]), a || (y = x = 0), o.push(i, r, y + 1 * g[t + 3], x + 1 * g[t + 4], y += 1 * g[t + 5], x += 1 * g[t + 6]), t += 6; else if ("S" === s) u = y, h = x, "C" !== p && "S" !== p || (u += y - o[o.length - 4], h += x - o[o.length - 3]), a || (y = x = 0), o.push(u, h, i, r, y += 1 * g[t + 3], x += 1 * g[t + 4]), t += 4; else if ("Q" === s) u = y + (i - y) * _, h = x + (r - x) * _, a || (y = x = 0), y += 1 * g[t + 3], x += 1 * g[t + 4], o.push(u, h, y + (i - y) * _, x + (r - x) * _, y, x), t += 4; else if ("T" === s) u = y - o[o.length - 4], h = x - o[o.length - 3], o.push(y + u, x + h, i + (y + 1.5 * u - i) * _, r + (x + 1.5 * h - r) * _, y = i, x = r), t += 2; else if ("H" === s) E(y, x, y = i, x), t += 1; else if ("V" === s) E(y, x, y, x = i + (a ? x - y : 0)), t += 1; else if ("L" === s || "Z" === s) "Z" === s && (i = l, r = c, o.closed = !0), ("L" === s || Da(y - i) > .5 || Da(x - r) > .5) && (E(y, x, i, r), "L" === s && (t += 2)), y = i, x = r; else if ("A" === s) { if (f = g[t + 4], m = g[t + 5], u = g[t + 6], h = g[t + 7], n = 7, f.length > 1 && (f.length < 3 ? (h = u, u = m, n--) : (h = m, u = f.substr(2), n -= 2), m = f.charAt(1), f = f.charAt(0)), d = Oa(y, x, +g[t + 1], +g[t + 2], +g[t + 3], +f, +m, (a ? y : 0) + 1 * u, (a ? x : 0) + 1 * h), t += n, d) for (n = 0; n < d.length; n++)o.push(d[n]); y = o[o.length - 2], x = o[o.length - 1] } else console.log(S); return (t = o.length) < 6 ? (v.pop(), t = 0) : o[0] === o[t - 2] && o[1] === o[t - 1] && (o.closed = !0), v.totalPoints = b + t, v }(e)[0]), 4 === (n = h.length)) h.unshift(0, 0), h.push(1, 1), n = 8; else if ((n - 2) % 6) throw "Invalid CustomEase"; for (0 == +h[0] && 1 == +h[n - 2] || function (e, t, n) { n || 0 === n || (n = Math.max(+e[e.length - 1], +e[1])); var i, r = -1 * +e[0], s = -n, a = e.length, o = 1 / (+e[a - 2] + r), l = -t || (Math.abs(+e[a - 1] - +e[1]) < .01 * (+e[a - 2] - +e[0]) ? function (e) { var t, n = e.length, i = 1e20; for (t = 1; t < n; t += 6)+e[t] < i && (i = +e[t]); return i }(e) + s : +e[a - 1] + s); for (l = l ? 1 / l : -o, i = 0; i < a; i += 2)e[i] = (+e[i] + r) * o, e[i + 1] = (+e[i + 1] + s) * l }(h, t.height, t.originY), this.segment = h, s = 2; s < n; s += 6)i = { x: +h[s - 2], y: +h[s - 1] }, r = { x: +h[s + 4], y: +h[s + 5] }, p.push(i, r), Ua(i.x, i.y, +h[s], +h[s + 1], +h[s + 2], +h[s + 3], r.x, r.y, 1 / (2e5 * m), p, p.length - 1); for (n = p.length, s = 0; s < n; s++)l = p[s], c = p[s - 1] || l, (l.x > c.x || c.y !== l.y && c.x === l.x || l === c) && l.x <= 1 ? (c.cx = l.x - c.x, c.cy = l.y - c.y, c.n = l, c.nx = l.x, g && s > 1 && Math.abs(c.cy / c.cx - p[s - 2].cy / p[s - 2].cx) > 2 && (g = 0), c.cx < d && (c.cx ? d = c.cx : (c.cx = .001, s === n - 1 && (c.x -= .001, d = Math.min(d, .001), g = 0)))) : (p.splice(s--, 1), n--); if (a = 1 / (n = 1 / d + 1 | 0), o = 0, l = p[0], g) { for (s = 0; s < n; s++)u = s * a, l.nx < u && (l = p[++o]), i = l.y + (u - l.x) / l.cx * l.cy, f[s] = { x: u, cx: a, y: i, cy: 0, nx: 9 }, s && (f[s - 1].cy = i - f[s - 1].y); f[n - 1].cy = p[p.length - 1].y - i } else { for (s = 0; s < n; s++)l.nx < s * a && (l = p[++o]), f[s] = l; o < p.length - 1 && (f[s - 1] = p[p.length - 2]) } return this.ease = function (e) { var t = f[e * n | 0] || f[n - 1]; return t.nx < e && (t = t.n), t.y + (e - t.x) / t.cx * t.cy }, this.ease.custom = this, this.id && Ia && Ia.registerEase(this.id, this.ease), this }, t.getSVGData = function (t) { return e.getSVGData(this, t) }, e.create = function (t, n, i) { return new e(t, n, i).ease }, e.register = function (e) { Ia = e, ka() }, e.get = function (e) { return Ia.parseEase(e) }, e.getSVGData = function (t, n) { var i, r, s, a, o, l, c, u, h, d, p = (n = n || {}).width || 100, f = n.height || 100, m = n.x || 0, g = (n.y || 0) + f, v = Ia.utils.toArray(n.path)[0]; if (n.invert && (f = -f, g = 0), "string" == typeof t && (t = Ia.parseEase(t)), t.custom && (t = t.custom), t instanceof e) i = function (e) { Aa(e[0]) && (e = [e]); var t, n, i, r, s = "", a = e.length; for (n = 0; n < a; n++) { for (r = e[n], s += "M" + Ra(r[0]) + "," + Ra(r[1]) + " C", t = r.length, i = 2; i < t; i++)s += Ra(r[i++]) + "," + Ra(r[i++]) + " " + Ra(r[i++]) + "," + Ra(r[i++]) + " " + Ra(r[i++]) + "," + Ra(r[i]) + " "; r.closed && (s += "z") } return s }(function (e, t, n, i, r, s, a) { for (var o, l, c, u, h, d = e.length; --d > -1;)for (l = (o = e[d]).length, c = 0; c < l; c += 2)u = o[c], h = o[c + 1], o[c] = u * t + 0 * h + s, o[c + 1] = 0 * u + h * r + a; return e._dirty = 1, e }([t.segment], p, 0, 0, -f, m, g)); else { for (i = [m, g], a = 1 / (c = Math.max(5, 200 * (n.precision || 1))), u = 5 / (c += 2), h = Na(m + a * p), r = ((d = Na(g + t(a) * -f)) - g) / (h - m), s = 2; s < c; s++)o = Na(m + s * a * p), l = Na(g + t(s * a) * -f), (Math.abs((l - d) / (o - h) - r) > u || s === c - 1) && (i.push(h, d), r = (l - d) / (o - h)), h = o, d = l; i = "M" + i.join(",") } return v && v.setAttribute("d", i), i }, e }(); za() && Ia.registerPlugin(Va), Va.version = "3.10.3"; var Ga = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/; function ja(e) { var t = e.nodeType, n = ""; if (1 === t || 9 === t || 11 === t) { if ("string" == typeof e.textContent) return e.textContent; for (e = e.firstChild; e; e = e.nextSibling)n += ja(e) } else if (3 === t || 4 === t) return e.nodeValue; return n } var Wa, qa, $a, Xa = /(?:\r|\n|\t\t)/g, Ya = /(?:\s\s+)/g, Za = function (e) { return qa.getComputedStyle(e) }, Ka = Array.isArray, Ja = [].slice, Qa = function (e, t) { var n; return Ka(e) ? e : "string" == (n = typeof e) && !t && e ? Ja.call(Wa.querySelectorAll(e), 0) : e && "object" === n && "length" in e ? Ja.call(e, 0) : e ? [e] : [] }, eo = function (e) { return "absolute" === e.position || !0 === e.absolute }, to = function (e, t) { for (var n, i = t.length; --i > -1;)if (n = t[i], e.substr(0, n.length) === n) return n.length }, no = function (e, t) { void 0 === e && (e = ""); var n = ~e.indexOf("++"), i = 1; return n && (e = e.split("++").join("")), function () { return "<" + t + " style='position:relative;display:inline-block;'" + (e ? " class='" + e + (n ? i++ : "") + "'>" : ">") } }, io = function e(t, n, i) { var r = t.nodeType; if (1 === r || 9 === r || 11 === r) for (t = t.firstChild; t; t = t.nextSibling)e(t, n, i); else 3 !== r && 4 !== r || (t.nodeValue = t.nodeValue.split(n).join(i)) }, ro = function (e, t) { for (var n = t.length; --n > -1;)e.push(t[n]) }, so = function (e, t, n) { for (var i; e && e !== t;) { if (i = e._next || e.nextSibling) return i.textContent.charAt(0) === n; e = e.parentNode || e._parent } }, ao = function e(t) { var n, i, r = Qa(t.childNodes), s = r.length; for (n = 0; n < s; n++)(i = r[n])._isSplit ? e(i) : n && i.previousSibling && 3 === i.previousSibling.nodeType ? (i.previousSibling.nodeValue += 3 === i.nodeType ? i.nodeValue : i.firstChild.nodeValue, t.removeChild(i)) : 3 !== i.nodeType && (t.insertBefore(i.firstChild, i), t.removeChild(i)) }, oo = function (e, t) { return parseFloat(t[e]) || 0 }, lo = function (e, t, n, i, r, s, a) { var o, l, c, u, h, d, p, f, m, g, v, y, x = Za(e), _ = oo("paddingLeft", x), w = -999, b = oo("borderBottomWidth", x) + oo("borderTopWidth", x), S = oo("borderLeftWidth", x) + oo("borderRightWidth", x), E = oo("paddingTop", x) + oo("paddingBottom", x), M = oo("paddingLeft", x) + oo("paddingRight", x), T = oo("fontSize", x) * (t.lineThreshold || .2), C = x.textAlign, D = [], L = [], A = [], P = t.wordDelimiter || " ", R = t.tag ? t.tag : t.span ? "span" : "div", O = t.type || t.split || "chars,words,lines", I = r && ~O.indexOf("lines") ? [] : null, F = ~O.indexOf("words"), z = ~O.indexOf("chars"), k = eo(t), N = t.linesClass, B = ~(N || "").indexOf("++"), H = [], U = "flex" === x.display, V = e.style.display; for (B && (N = N.split("++").join("")), U && (e.style.display = "block"), c = (l = e.getElementsByTagName("*")).length, h = [], o = 0; o < c; o++)h[o] = l[o]; if (I || k) for (o = 0; o < c; o++)((d = (u = h[o]).parentNode === e) || k || z && !F) && (y = u.offsetTop, I && d && Math.abs(y - w) > T && ("BR" !== u.nodeName || 0 === o) && (p = [], I.push(p), w = y), k && (u._x = u.offsetLeft, u._y = y, u._w = u.offsetWidth, u._h = u.offsetHeight), I && ((u._isSplit && d || !z && d || F && d || !F && u.parentNode.parentNode === e && !u.parentNode._isSplit) && (p.push(u), u._x -= _, so(u, e, P) && (u._wordEnd = !0)), "BR" === u.nodeName && (u.nextSibling && "BR" === u.nextSibling.nodeName || 0 === o) && I.push([]))); for (o = 0; o < c; o++)if (d = (u = h[o]).parentNode === e, "BR" !== u.nodeName) if (k && (m = u.style, F || d || (u._x += u.parentNode._x, u._y += u.parentNode._y), m.left = u._x + "px", m.top = u._y + "px", m.position = "absolute", m.display = "block", m.width = u._w + 1 + "px", m.height = u._h + "px"), !F && z) if (u._isSplit) for (u._next = l = u.nextSibling, u.parentNode.appendChild(u); l && 3 === l.nodeType && " " === l.textContent;)u._next = l.nextSibling, u.parentNode.appendChild(l), l = l.nextSibling; else u.parentNode._isSplit ? (u._parent = u.parentNode, !u.previousSibling && u.firstChild && (u.firstChild._isFirst = !0), u.nextSibling && " " === u.nextSibling.textContent && !u.nextSibling.nextSibling && H.push(u.nextSibling), u._next = u.nextSibling && u.nextSibling._isFirst ? null : u.nextSibling, u.parentNode.removeChild(u), h.splice(o--, 1), c--) : d || (y = !u.nextSibling && so(u.parentNode, e, P), u.parentNode._parent && u.parentNode._parent.appendChild(u), y && u.parentNode.appendChild(Wa.createTextNode(" ")), "span" === R && (u.style.display = "inline"), D.push(u)); else u.parentNode._isSplit && !u._isSplit && "" !== u.innerHTML ? L.push(u) : z && !u._isSplit && ("span" === R && (u.style.display = "inline"), D.push(u)); else I || k ? (u.parentNode && u.parentNode.removeChild(u), h.splice(o--, 1), c--) : F || e.appendChild(u); for (o = H.length; --o > -1;)H[o].parentNode.removeChild(H[o]); if (I) { for (k && (g = Wa.createElement(R), e.appendChild(g), v = g.offsetWidth + "px", y = g.offsetParent === e ? 0 : e.offsetLeft, e.removeChild(g)), m = e.style.cssText, e.style.cssText = "display:none;"; e.firstChild;)e.removeChild(e.firstChild); for (f = " " === P && (!k || !F && !z), o = 0; o < I.length; o++) { for (p = I[o], (g = Wa.createElement(R)).style.cssText = "display:block;text-align:" + C + ";position:" + (k ? "absolute;" : "relative;"), N && (g.className = N + (B ? o + 1 : "")), A.push(g), c = p.length, l = 0; l < c; l++)"BR" !== p[l].nodeName && (u = p[l], g.appendChild(u), f && u._wordEnd && g.appendChild(Wa.createTextNode(" ")), k && (0 === l && (g.style.top = u._y + "px", g.style.left = _ + y + "px"), u.style.top = "0px", y && (u.style.left = u._x - y + "px"))); 0 === c ? g.innerHTML = "&nbsp;" : F || z || (ao(g), io(g, String.fromCharCode(160), " ")), k && (g.style.width = v, g.style.height = u._h + "px"), e.appendChild(g) } e.style.cssText = m } k && (a > e.clientHeight && (e.style.height = a - E + "px", e.clientHeight < a && (e.style.height = a + b + "px")), s > e.clientWidth && (e.style.width = s - M + "px", e.clientWidth < s && (e.style.width = s + S + "px"))), U && (V ? e.style.display = V : e.style.removeProperty("display")), ro(n, D), F && ro(i, L), ro(r, A) }, co = function (e, t, n, i) { var r, s, a, o, l, c, u, h, d = t.tag ? t.tag : t.span ? "span" : "div", p = ~(t.type || t.split || "chars,words,lines").indexOf("chars"), f = eo(t), m = t.wordDelimiter || " ", g = " " !== m ? "" : f ? "&#173; " : " ", v = "</" + d + ">", y = 1, x = t.specialChars ? "function" == typeof t.specialChars ? t.specialChars : to : null, _ = Wa.createElement("div"), w = e.parentNode; for (w.insertBefore(_, e), _.textContent = e.nodeValue, w.removeChild(e), u = -1 !== (r = ja(e = _)).indexOf("<"), !1 !== t.reduceWhiteSpace && (r = r.replace(Ya, " ").replace(Xa, "")), u && (r = r.split("<").join("{{LT}}")), l = r.length, s = (" " === r.charAt(0) ? g : "") + n(), a = 0; a < l; a++)if (c = r.charAt(a), x && (h = x(r.substr(a), t.specialChars))) c = r.substr(a, h || 1), s += p && " " !== c ? i() + c + "</" + d + ">" : c, a += h - 1; else if (c === m && r.charAt(a - 1) !== m && a) { for (s += y ? v : "", y = 0; r.charAt(a + 1) === m;)s += g, a++; a === l - 1 ? s += g : ")" !== r.charAt(a + 1) && (s += g + n(), y = 1) } else "{" === c && "{{LT}}" === r.substr(a, 6) ? (s += p ? i() + "{{LT}}</" + d + ">" : "{{LT}}", a += 5) : c.charCodeAt(0) >= 55296 && c.charCodeAt(0) <= 56319 || r.charCodeAt(a + 1) >= 65024 && r.charCodeAt(a + 1) <= 65039 ? (o = ((r.substr(a, 12).split(Ga) || [])[1] || "").length || 2, s += p && " " !== c ? i() + r.substr(a, o) + "</" + d + ">" : r.substr(a, o), a += o - 1) : s += p && " " !== c ? i() + c + "</" + d + ">" : c; e.outerHTML = s + (y ? v : ""), u && io(w, "{{LT}}", "<") }, uo = function e(t, n, i, r) { var s, a, o = Qa(t.childNodes), l = o.length, c = eo(n); if (3 !== t.nodeType || l > 1) { for (n.absolute = !1, s = 0; s < l; s++)(a = o[s])._next = a._isFirst = a._parent = a._wordEnd = null, (3 !== a.nodeType || /\S+/.test(a.nodeValue)) && (c && 3 !== a.nodeType && "inline" === Za(a).display && (a.style.display = "inline-block", a.style.position = "relative"), a._isSplit = !0, e(a, n, i, r)); return n.absolute = c, void (t._isSplit = !0) } co(t, n, i, r) }, ho = function () { function e(e, t) { $a || (Wa = document, qa = window, $a = 1), this.elements = Qa(e), this.chars = [], this.words = [], this.lines = [], this._originals = [], this.vars = t || {}, this.split(t) } var t = e.prototype; return t.split = function (e) { this.isSplit && this.revert(), this.vars = e = e || this.vars, this._originals.length = this.chars.length = this.words.length = this.lines.length = 0; for (var t, n, i, r = this.elements.length, s = e.tag ? e.tag : e.span ? "span" : "div", a = no(e.wordsClass, s), o = no(e.charsClass, s); --r > -1;)i = this.elements[r], this._originals[r] = i.innerHTML, t = i.clientHeight, n = i.clientWidth, uo(i, e, a, o), lo(i, e, this.chars, this.words, this.lines, n, t); return this.chars.reverse(), this.words.reverse(), this.lines.reverse(), this.isSplit = !0, this }, t.revert = function () { var e = this._originals; if (!e) throw "revert() call wasn't scoped properly."; return this.elements.forEach((function (t, n) { return t.innerHTML = e[n] })), this.chars = [], this.words = [], this.lines = [], this.isSplit = !1, this }, e.create = function (t, n) { return new e(t, n) }, e }(); ho.version = "3.9.1"; const po = 100, fo = 301, mo = 302, go = 306, vo = 1e3, yo = 1001, xo = 1002, _o = 1003, wo = 1004, bo = 1005, So = 1006, Eo = 1008, Mo = 1009, To = 1012, Co = 1014, Do = 1015, Lo = 1016, Ao = 1020, Po = 1023, Ro = 1026, Oo = 1027, Io = 33776, Fo = 33777, zo = 33778, ko = 33779, No = 2300, Bo = 2301, Ho = 2302, Uo = 2400, Vo = 2401, Go = 2402, jo = 3e3, Wo = 3001, qo = 7680, $o = 35044, Xo = 35048, Yo = "300 es", Zo = 1035; class Ko { addEventListener(e, t) { void 0 === this._listeners && (this._listeners = {}); const n = this._listeners; void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t) } hasEventListener(e, t) { if (void 0 === this._listeners) return !1; const n = this._listeners; return void 0 !== n[e] && -1 !== n[e].indexOf(t) } removeEventListener(e, t) { if (void 0 === this._listeners) return; const n = this._listeners[e]; if (void 0 !== n) { const e = n.indexOf(t); -1 !== e && n.splice(e, 1) } } dispatchEvent(e) { if (void 0 === this._listeners) return; const t = this._listeners[e.type]; if (void 0 !== t) { e.target = this; const n = t.slice(0); for (let t = 0, i = n.length; t < i; t++)n[t].call(this, e); e.target = null } } } const Jo = []; for (let e = 0; e < 256; e++)Jo[e] = (e < 16 ? "0" : "") + e.toString(16); let Qo = 1234567; const el = Math.PI / 180, tl = 180 / Math.PI; function nl() { const e = 4294967295 * Math.random() | 0, t = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0, i = 4294967295 * Math.random() | 0; return (Jo[255 & e] + Jo[e >> 8 & 255] + Jo[e >> 16 & 255] + Jo[e >> 24 & 255] + "-" + Jo[255 & t] + Jo[t >> 8 & 255] + "-" + Jo[t >> 16 & 15 | 64] + Jo[t >> 24 & 255] + "-" + Jo[63 & n | 128] + Jo[n >> 8 & 255] + "-" + Jo[n >> 16 & 255] + Jo[n >> 24 & 255] + Jo[255 & i] + Jo[i >> 8 & 255] + Jo[i >> 16 & 255] + Jo[i >> 24 & 255]).toUpperCase() } function il(e, t, n) { return Math.max(t, Math.min(n, e)) } function rl(e, t) { return (e % t + t) % t } function sl(e, t, n) { return (1 - n) * e + n * t } function al(e) { return 0 == (e & e - 1) && 0 !== e } function ol(e) { return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2)) } function ll(e) { return Math.pow(2, Math.floor(Math.log(e) / Math.LN2)) } var cl = Object.freeze({ __proto__: null, DEG2RAD: el, RAD2DEG: tl, generateUUID: nl, clamp: il, euclideanModulo: rl, mapLinear: function (e, t, n, i, r) { return i + (e - t) * (r - i) / (n - t) }, inverseLerp: function (e, t, n) { return e !== t ? (n - e) / (t - e) : 0 }, lerp: sl, damp: function (e, t, n, i) { return sl(e, t, 1 - Math.exp(-n * i)) }, pingpong: function (e, t = 1) { return t - Math.abs(rl(e, 2 * t) - t) }, smoothstep: function (e, t, n) { return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e) }, smootherstep: function (e, t, n) { return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10) }, randInt: function (e, t) { return e + Math.floor(Math.random() * (t - e + 1)) }, randFloat: function (e, t) { return e + Math.random() * (t - e) }, randFloatSpread: function (e) { return e * (.5 - Math.random()) }, seededRandom: function (e) { return void 0 !== e && (Qo = e % 2147483647), Qo = 16807 * Qo % 2147483647, (Qo - 1) / 2147483646 }, degToRad: function (e) { return e * el }, radToDeg: function (e) { return e * tl }, isPowerOfTwo: al, ceilPowerOfTwo: ol, floorPowerOfTwo: ll, setQuaternionFromProperEuler: function (e, t, n, i, r) { const s = Math.cos, a = Math.sin, o = s(n / 2), l = a(n / 2), c = s((t + i) / 2), u = a((t + i) / 2), h = s((t - i) / 2), d = a((t - i) / 2), p = s((i - t) / 2), f = a((i - t) / 2); switch (r) { case "XYX": e.set(o * u, l * h, l * d, o * c); break; case "YZY": e.set(l * d, o * u, l * h, o * c); break; case "ZXZ": e.set(l * h, l * d, o * u, o * c); break; case "XZX": e.set(o * u, l * f, l * p, o * c); break; case "YXY": e.set(l * p, o * u, l * f, o * c); break; case "ZYZ": e.set(l * f, l * p, o * u, o * c); break; default: console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r) } } }); class ul { constructor(e = 0, t = 0) { this.x = e, this.y = t } get width() { return this.x } set width(e) { this.x = e } get height() { return this.y } set height(e) { this.y = e } set(e, t) { return this.x = e, this.y = t, this } setScalar(e) { return this.x = e, this.y = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y) } copy(e) { return this.x = e.x, this.y = e.y, this } add(e, t) { return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this) } addScalar(e) { return this.x += e, this.y += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this } sub(e, t) { return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this) } subScalar(e) { return this.x -= e, this.y -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this } divide(e) { return this.x /= e.x, this.y /= e.y, this } divideScalar(e) { return this.multiplyScalar(1 / e) } applyMatrix3(e) { const t = this.x, n = this.y, i = e.elements; return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this } clampLength(e, t) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this } negate() { return this.x = -this.x, this.y = -this.y, this } dot(e) { return this.x * e.x + this.y * e.y } cross(e) { return this.x * e.y - this.y * e.x } lengthSq() { return this.x * this.x + this.y * this.y } length() { return Math.sqrt(this.x * this.x + this.y * this.y) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) } normalize() { return this.divideScalar(this.length() || 1) } angle() { return Math.atan2(-this.y, -this.x) + Math.PI } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const t = this.x - e.x, n = this.y - e.y; return t * t + n * n } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this } lerpVectors(e, t, n) { return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this } equals(e) { return e.x === this.x && e.y === this.y } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e } fromBufferAttribute(e, t, n) { return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this } rotateAround(e, t) { const n = Math.cos(t), i = Math.sin(t), r = this.x - e.x, s = this.y - e.y; return this.x = r * n - s * i + e.x, this.y = r * i + s * n + e.y, this } random() { return this.x = Math.random(), this.y = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y } } ul.prototype.isVector2 = !0; class hl { constructor() { this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.") } set(e, t, n, i, r, s, a, o, l) { const c = this.elements; return c[0] = e, c[1] = i, c[2] = a, c[3] = t, c[4] = r, c[5] = o, c[6] = n, c[7] = s, c[8] = l, this } identity() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this } copy(e) { const t = this.elements, n = e.elements; return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this } extractBasis(e, t, n) { return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this } setFromMatrix4(e) { const t = e.elements; return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { const n = e.elements, i = t.elements, r = this.elements, s = n[0], a = n[3], o = n[6], l = n[1], c = n[4], u = n[7], h = n[2], d = n[5], p = n[8], f = i[0], m = i[3], g = i[6], v = i[1], y = i[4], x = i[7], _ = i[2], w = i[5], b = i[8]; return r[0] = s * f + a * v + o * _, r[3] = s * m + a * y + o * w, r[6] = s * g + a * x + o * b, r[1] = l * f + c * v + u * _, r[4] = l * m + c * y + u * w, r[7] = l * g + c * x + u * b, r[2] = h * f + d * v + p * _, r[5] = h * m + d * y + p * w, r[8] = h * g + d * x + p * b, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this } determinant() { const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], s = e[4], a = e[5], o = e[6], l = e[7], c = e[8]; return t * s * c - t * a * l - n * r * c + n * a * o + i * r * l - i * s * o } invert() { const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], s = e[4], a = e[5], o = e[6], l = e[7], c = e[8], u = c * s - a * l, h = a * o - c * r, d = l * r - s * o, p = t * u + n * h + i * d; if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0); const f = 1 / p; return e[0] = u * f, e[1] = (i * l - c * n) * f, e[2] = (a * n - i * s) * f, e[3] = h * f, e[4] = (c * t - i * o) * f, e[5] = (i * r - a * t) * f, e[6] = d * f, e[7] = (n * o - l * t) * f, e[8] = (s * t - n * r) * f, this } transpose() { let e; const t = this.elements; return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this } getNormalMatrix(e) { return this.setFromMatrix4(e).invert().transpose() } transposeIntoArray(e) { const t = this.elements; return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this } setUvTransform(e, t, n, i, r, s, a) { const o = Math.cos(r), l = Math.sin(r); return this.set(n * o, n * l, -n * (o * s + l * a) + s + e, -i * l, i * o, -i * (-l * s + o * a) + a + t, 0, 0, 1), this } scale(e, t) { const n = this.elements; return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this } rotate(e) { const t = Math.cos(e), n = Math.sin(e), i = this.elements, r = i[0], s = i[3], a = i[6], o = i[1], l = i[4], c = i[7]; return i[0] = t * r + n * o, i[3] = t * s + n * l, i[6] = t * a + n * c, i[1] = -n * r + t * o, i[4] = -n * s + t * l, i[7] = -n * a + t * c, this } translate(e, t) { const n = this.elements; return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this } equals(e) { const t = this.elements, n = e.elements; for (let e = 0; e < 9; e++)if (t[e] !== n[e]) return !1; return !0 } fromArray(e, t = 0) { for (let n = 0; n < 9; n++)this.elements[n] = e[n + t]; return this } toArray(e = [], t = 0) { const n = this.elements; return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e } clone() { return (new this.constructor).fromArray(this.elements) } } function dl(e) { for (let t = e.length - 1; t >= 0; --t)if (e[t] > 65535) return !0; return !1 } function pl(e) { return document.createElementNS("http://www.w3.org/1999/xhtml", e) } hl.prototype.isMatrix3 = !0, Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array; const fl = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, ml = { h: 0, s: 0, l: 0 }, gl = { h: 0, s: 0, l: 0 }; function vl(e, t, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e } function yl(e) { return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4) } function xl(e) { return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055 } class _l { constructor(e, t, n) { return void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n) } set(e) { return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this } setScalar(e) { return this.r = e, this.g = e, this.b = e, this } setHex(e) { return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this } setRGB(e, t, n) { return this.r = e, this.g = t, this.b = n, this } setHSL(e, t, n) { if (e = rl(e, 1), t = il(t, 0, 1), n = il(n, 0, 1), 0 === t) this.r = this.g = this.b = n; else { const i = n <= .5 ? n * (1 + t) : n + t - n * t, r = 2 * n - i; this.r = vl(r, i, e + 1 / 3), this.g = vl(r, i, e), this.b = vl(r, i, e - 1 / 3) } return this } setStyle(e) { function t(t) { void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.") } let n; if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) { let e; const i = n[1], r = n[2]; switch (i) { case "rgb": case "rgba": if (e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(255, parseInt(e[1], 10)) / 255, this.g = Math.min(255, parseInt(e[2], 10)) / 255, this.b = Math.min(255, parseInt(e[3], 10)) / 255, t(e[4]), this; if (e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(100, parseInt(e[1], 10)) / 100, this.g = Math.min(100, parseInt(e[2], 10)) / 100, this.b = Math.min(100, parseInt(e[3], 10)) / 100, t(e[4]), this; break; case "hsl": case "hsla": if (e = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) { const n = parseFloat(e[1]) / 360, i = parseInt(e[2], 10) / 100, r = parseInt(e[3], 10) / 100; return t(e[4]), this.setHSL(n, i, r) } } } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) { const e = n[1], t = e.length; if (3 === t) return this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255, this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255, this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255, this; if (6 === t) return this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255, this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255, this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255, this } return e && e.length > 0 ? this.setColorName(e) : this } setColorName(e) { const t = fl[e.toLowerCase()]; return void 0 !== t ? this.setHex(t) : console.warn("THREE.Color: Unknown color " + e), this } clone() { return new this.constructor(this.r, this.g, this.b) } copy(e) { return this.r = e.r, this.g = e.g, this.b = e.b, this } copySRGBToLinear(e) { return this.r = yl(e.r), this.g = yl(e.g), this.b = yl(e.b), this } copyLinearToSRGB(e) { return this.r = xl(e.r), this.g = xl(e.g), this.b = xl(e.b), this } convertSRGBToLinear() { return this.copySRGBToLinear(this), this } convertLinearToSRGB() { return this.copyLinearToSRGB(this), this } getHex() { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0 } getHexString() { return ("000000" + this.getHex().toString(16)).slice(-6) } getHSL(e) { const t = this.r, n = this.g, i = this.b, r = Math.max(t, n, i), s = Math.min(t, n, i); let a, o; const l = (s + r) / 2; if (s === r) a = 0, o = 0; else { const e = r - s; switch (o = l <= .5 ? e / (r + s) : e / (2 - r - s), r) { case t: a = (n - i) / e + (n < i ? 6 : 0); break; case n: a = (i - t) / e + 2; break; case i: a = (t - n) / e + 4 }a /= 6 } return e.h = a, e.s = o, e.l = l, e } getStyle() { return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")" } offsetHSL(e, t, n) { return this.getHSL(ml), ml.h += e, ml.s += t, ml.l += n, this.setHSL(ml.h, ml.s, ml.l), this } add(e) { return this.r += e.r, this.g += e.g, this.b += e.b, this } addColors(e, t) { return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this } addScalar(e) { return this.r += e, this.g += e, this.b += e, this } sub(e) { return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this } multiply(e) { return this.r *= e.r, this.g *= e.g, this.b *= e.b, this } multiplyScalar(e) { return this.r *= e, this.g *= e, this.b *= e, this } lerp(e, t) { return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this } lerpColors(e, t, n) { return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this } lerpHSL(e, t) { this.getHSL(ml), e.getHSL(gl); const n = sl(ml.h, gl.h, t), i = sl(ml.s, gl.s, t), r = sl(ml.l, gl.l, t); return this.setHSL(n, i, r), this } equals(e) { return e.r === this.r && e.g === this.g && e.b === this.b } fromArray(e, t = 0) { return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e } fromBufferAttribute(e, t) { return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), !0 === e.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this } toJSON() { return this.getHex() } } let wl; _l.NAMES = fl, _l.prototype.isColor = !0, _l.prototype.r = 1, _l.prototype.g = 1, _l.prototype.b = 1; class bl { static getDataURL(e) { if (/^data:/i.test(e.src)) return e.src; if ("undefined" == typeof HTMLCanvasElement) return e.src; let t; if (e instanceof HTMLCanvasElement) t = e; else { void 0 === wl && (wl = pl("canvas")), wl.width = e.width, wl.height = e.height; const n = wl.getContext("2d"); e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = wl } return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png") } static sRGBToLinear(e) { if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) { const t = pl("canvas"); t.width = e.width, t.height = e.height; const n = t.getContext("2d"); n.drawImage(e, 0, 0, e.width, e.height); const i = n.getImageData(0, 0, e.width, e.height), r = i.data; for (let e = 0; e < r.length; e++)r[e] = 255 * yl(r[e] / 255); return n.putImageData(i, 0, 0), t } if (e.data) { const t = e.data.slice(0); for (let e = 0; e < t.length; e++)t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * yl(t[e] / 255)) : t[e] = yl(t[e]); return { data: t, width: e.width, height: e.height } } return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e } } class Sl { constructor(e = null) { this.uuid = nl(), this.data = e, this.version = 0 } set needsUpdate(e) { !0 === e && this.version++ } toJSON(e) { const t = void 0 === e || "string" == typeof e; if (!t && void 0 !== e.images[this.uuid]) return e.images[this.uuid]; const n = { uuid: this.uuid, url: "" }, i = this.data; if (null !== i) { let e; if (Array.isArray(i)) { e = []; for (let t = 0, n = i.length; t < n; t++)i[t].isDataTexture ? e.push(El(i[t].image)) : e.push(El(i[t])) } else e = El(i); n.url = e } return t || (e.images[this.uuid] = n), n } } function El(e) { return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? bl.getDataURL(e) : e.data ? { data: Array.prototype.slice.call(e.data), width: e.width, height: e.height, type: e.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {}) } Sl.prototype.isSource = !0; let Ml = 0; class Tl extends Ko { constructor(e = Tl.DEFAULT_IMAGE, t = Tl.DEFAULT_MAPPING, n = 1001, i = 1001, r = 1006, s = 1008, a = 1023, o = 1009, l = 1, c = 3e3) { super(), Object.defineProperty(this, "id", { value: Ml++ }), this.uuid = nl(), this.name = "", this.source = new Sl(e), this.mipmaps = [], this.mapping = t, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = s, this.anisotropy = l, this.format = a, this.internalFormat = null, this.type = o, this.offset = new ul(0, 0), this.repeat = new ul(1, 1), this.center = new ul(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new hl, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1 } get image() { return this.source.data } set image(e) { this.source.data = e } updateMatrix() { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) } clone() { return (new this.constructor).copy(this) } copy(e) { return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this } toJSON(e) { const t = void 0 === e || "string" == typeof e; if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid]; const n = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(e).uuid, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; return "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n } dispose() { this.dispatchEvent({ type: "dispose" }) } transformUv(e) { if (300 !== this.mapping) return e; if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) { case vo: e.x = e.x - Math.floor(e.x); break; case yo: e.x = e.x < 0 ? 0 : 1; break; case xo: 1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x) }if (e.y < 0 || e.y > 1) switch (this.wrapT) { case vo: e.y = e.y - Math.floor(e.y); break; case yo: e.y = e.y < 0 ? 0 : 1; break; case xo: 1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y) }return this.flipY && (e.y = 1 - e.y), e } set needsUpdate(e) { !0 === e && (this.version++, this.source.needsUpdate = !0) } } Tl.DEFAULT_IMAGE = null, Tl.DEFAULT_MAPPING = 300, Tl.prototype.isTexture = !0; class Cl { constructor(e = 0, t = 0, n = 0, i = 1) { this.x = e, this.y = t, this.z = n, this.w = i } get width() { return this.z } set width(e) { this.z = e } get height() { return this.w } set height(e) { this.w = e } set(e, t, n, i) { return this.x = e, this.y = t, this.z = n, this.w = i, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this.w = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setW(e) { return this.w = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; case 3: this.w = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z, this.w) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this } add(e, t) { return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this) } addScalar(e) { return this.x += e, this.y += e, this.z += e, this.w += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this } sub(e, t) { return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this) } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this } applyMatrix4(e) { const t = this.x, n = this.y, i = this.z, r = this.w, s = e.elements; return this.x = s[0] * t + s[4] * n + s[8] * i + s[12] * r, this.y = s[1] * t + s[5] * n + s[9] * i + s[13] * r, this.z = s[2] * t + s[6] * n + s[10] * i + s[14] * r, this.w = s[3] * t + s[7] * n + s[11] * i + s[15] * r, this } divideScalar(e) { return this.multiplyScalar(1 / e) } setAxisAngleFromQuaternion(e) { this.w = 2 * Math.acos(e.w); const t = Math.sqrt(1 - e.w * e.w); return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this } setAxisAngleFromRotationMatrix(e) { let t, n, i, r; const s = .01, a = .1, o = e.elements, l = o[0], c = o[4], u = o[8], h = o[1], d = o[5], p = o[9], f = o[2], m = o[6], g = o[10]; if (Math.abs(c - h) < s && Math.abs(u - f) < s && Math.abs(p - m) < s) { if (Math.abs(c + h) < a && Math.abs(u + f) < a && Math.abs(p + m) < a && Math.abs(l + d + g - 3) < a) return this.set(1, 0, 0, 0), this; t = Math.PI; const e = (l + 1) / 2, o = (d + 1) / 2, v = (g + 1) / 2, y = (c + h) / 4, x = (u + f) / 4, _ = (p + m) / 4; return e > o && e > v ? e < s ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(e), i = y / n, r = x / n) : o > v ? o < s ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(o), n = y / i, r = _ / i) : v < s ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(v), n = x / r, i = _ / r), this.set(n, i, r, t), this } let v = Math.sqrt((m - p) * (m - p) + (u - f) * (u - f) + (h - c) * (h - c)); return Math.abs(v) < .001 && (v = 1), this.x = (m - p) / v, this.y = (u - f) / v, this.z = (h - c) / v, this.w = Math.acos((l + d + g - 1) / 2), this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this } clampLength(e, t) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this } lerpVectors(e, t, n) { return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e } fromBufferAttribute(e, t, n) { return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z, yield this.w } } Cl.prototype.isVector4 = !0; class Dl extends Ko { constructor(e, t, n = {}) { super(), this.width = e, this.height = t, this.depth = 1, this.scissor = new Cl(0, 0, e, t), this.scissorTest = !1, this.viewport = new Cl(0, 0, e, t); const i = { width: e, height: t, depth: 1 }; this.texture = new Tl(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : So, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null, this.samples = void 0 !== n.samples ? n.samples : 0 } setSize(e, t, n = 1) { this.width === e && this.height === t && this.depth === n || (this.width = e, this.height = t, this.depth = n, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t) } clone() { return (new this.constructor).copy(this) } copy(e) { return this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.image = Object.assign({}, e.texture.image), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } Dl.prototype.isWebGLRenderTarget = !0; class Ll extends Tl { constructor(e = null, t = 1, n = 1, i = 1) { super(null), this.image = { data: e, width: t, height: n, depth: i }, this.magFilter = _o, this.minFilter = _o, this.wrapR = yo, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } Ll.prototype.isDataArrayTexture = !0, class extends Dl { constructor(e, t, n) { super(e, t), this.depth = n, this.texture = new Ll(null, e, t, n), this.texture.isRenderTargetTexture = !0 } }.prototype.isWebGLArrayRenderTarget = !0; class Al extends Tl { constructor(e = null, t = 1, n = 1, i = 1) { super(null), this.image = { data: e, width: t, height: n, depth: i }, this.magFilter = _o, this.minFilter = _o, this.wrapR = yo, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } Al.prototype.isData3DTexture = !0, class extends Dl { constructor(e, t, n) { super(e, t), this.depth = n, this.texture = new Al(null, e, t, n), this.texture.isRenderTargetTexture = !0 } }.prototype.isWebGL3DRenderTarget = !0, class extends Dl { constructor(e, t, n, i = {}) { super(e, t, i); const r = this.texture; this.texture = []; for (let e = 0; e < n; e++)this.texture[e] = r.clone(), this.texture[e].isRenderTargetTexture = !0 } setSize(e, t, n = 1) { if (this.width !== e || this.height !== t || this.depth !== n) { this.width = e, this.height = t, this.depth = n; for (let i = 0, r = this.texture.length; i < r; i++)this.texture[i].image.width = e, this.texture[i].image.height = t, this.texture[i].image.depth = n; this.dispose() } return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this } copy(e) { this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this.texture.length = 0; for (let t = 0, n = e.texture.length; t < n; t++)this.texture[t] = e.texture[t].clone(); return this } }.prototype.isWebGLMultipleRenderTargets = !0; class Pl { constructor(e = 0, t = 0, n = 0, i = 1) { this._x = e, this._y = t, this._z = n, this._w = i } static slerp(e, t, n, i) { return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(e, t, i) } static slerpFlat(e, t, n, i, r, s, a) { let o = n[i + 0], l = n[i + 1], c = n[i + 2], u = n[i + 3]; const h = r[s + 0], d = r[s + 1], p = r[s + 2], f = r[s + 3]; if (0 === a) return e[t + 0] = o, e[t + 1] = l, e[t + 2] = c, void (e[t + 3] = u); if (1 === a) return e[t + 0] = h, e[t + 1] = d, e[t + 2] = p, void (e[t + 3] = f); if (u !== f || o !== h || l !== d || c !== p) { let e = 1 - a; const t = o * h + l * d + c * p + u * f, n = t >= 0 ? 1 : -1, i = 1 - t * t; if (i > Number.EPSILON) { const r = Math.sqrt(i), s = Math.atan2(r, t * n); e = Math.sin(e * s) / r, a = Math.sin(a * s) / r } const r = a * n; if (o = o * e + h * r, l = l * e + d * r, c = c * e + p * r, u = u * e + f * r, e === 1 - a) { const e = 1 / Math.sqrt(o * o + l * l + c * c + u * u); o *= e, l *= e, c *= e, u *= e } } e[t] = o, e[t + 1] = l, e[t + 2] = c, e[t + 3] = u } static multiplyQuaternionsFlat(e, t, n, i, r, s) { const a = n[i], o = n[i + 1], l = n[i + 2], c = n[i + 3], u = r[s], h = r[s + 1], d = r[s + 2], p = r[s + 3]; return e[t] = a * p + c * u + o * d - l * h, e[t + 1] = o * p + c * h + l * u - a * d, e[t + 2] = l * p + c * d + a * h - o * u, e[t + 3] = c * p - a * u - o * h - l * d, e } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get w() { return this._w } set w(e) { this._w = e, this._onChangeCallback() } set(e, t, n, i) { return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._w) } copy(e) { return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this } setFromEuler(e, t) { if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."); const n = e._x, i = e._y, r = e._z, s = e._order, a = Math.cos, o = Math.sin, l = a(n / 2), c = a(i / 2), u = a(r / 2), h = o(n / 2), d = o(i / 2), p = o(r / 2); switch (s) { case "XYZ": this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p; break; case "YXZ": this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p; break; case "ZXY": this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p; break; case "ZYX": this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p; break; case "YZX": this._x = h * c * u + l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u - h * d * p; break; case "XZY": this._x = h * c * u - l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u + h * d * p; break; default: console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s) }return !1 !== t && this._onChangeCallback(), this } setFromAxisAngle(e, t) { const n = t / 2, i = Math.sin(n); return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this } setFromRotationMatrix(e) { const t = e.elements, n = t[0], i = t[4], r = t[8], s = t[1], a = t[5], o = t[9], l = t[2], c = t[6], u = t[10], h = n + a + u; if (h > 0) { const e = .5 / Math.sqrt(h + 1); this._w = .25 / e, this._x = (c - o) * e, this._y = (r - l) * e, this._z = (s - i) * e } else if (n > a && n > u) { const e = 2 * Math.sqrt(1 + n - a - u); this._w = (c - o) / e, this._x = .25 * e, this._y = (i + s) / e, this._z = (r + l) / e } else if (a > u) { const e = 2 * Math.sqrt(1 + a - n - u); this._w = (r - l) / e, this._x = (i + s) / e, this._y = .25 * e, this._z = (o + c) / e } else { const e = 2 * Math.sqrt(1 + u - n - a); this._w = (s - i) / e, this._x = (r + l) / e, this._y = (o + c) / e, this._z = .25 * e } return this._onChangeCallback(), this } setFromUnitVectors(e, t) { let n = e.dot(t) + 1; return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize() } angleTo(e) { return 2 * Math.acos(Math.abs(il(this.dot(e), -1, 1))) } rotateTowards(e, t) { const n = this.angleTo(e); if (0 === n) return this; const i = Math.min(1, t / n); return this.slerp(e, i), this } identity() { return this.set(0, 0, 0, 1) } invert() { return this.conjugate() } conjugate() { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this } dot(e) { return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w } lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w } length() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) } normalize() { let e = this.length(); return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this } multiply(e, t) { return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e) } premultiply(e) { return this.multiplyQuaternions(e, this) } multiplyQuaternions(e, t) { const n = e._x, i = e._y, r = e._z, s = e._w, a = t._x, o = t._y, l = t._z, c = t._w; return this._x = n * c + s * a + i * l - r * o, this._y = i * c + s * o + r * a - n * l, this._z = r * c + s * l + n * o - i * a, this._w = s * c - n * a - i * o - r * l, this._onChangeCallback(), this } slerp(e, t) { if (0 === t) return this; if (1 === t) return this.copy(e); const n = this._x, i = this._y, r = this._z, s = this._w; let a = s * e._w + n * e._x + i * e._y + r * e._z; if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = s, this._x = n, this._y = i, this._z = r, this; const o = 1 - a * a; if (o <= Number.EPSILON) { const e = 1 - t; return this._w = e * s + t * this._w, this._x = e * n + t * this._x, this._y = e * i + t * this._y, this._z = e * r + t * this._z, this.normalize(), this._onChangeCallback(), this } const l = Math.sqrt(o), c = Math.atan2(l, a), u = Math.sin((1 - t) * c) / l, h = Math.sin(t * c) / l; return this._w = s * u + this._w * h, this._x = n * u + this._x * h, this._y = i * u + this._y * h, this._z = r * u + this._z * h, this._onChangeCallback(), this } slerpQuaternions(e, t, n) { return this.copy(e).slerp(t, n) } random() { const e = Math.random(), t = Math.sqrt(1 - e), n = Math.sqrt(e), i = 2 * Math.PI * Math.random(), r = 2 * Math.PI * Math.random(); return this.set(t * Math.cos(i), n * Math.sin(r), n * Math.cos(r), t * Math.sin(i)) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w } fromArray(e, t = 0) { return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e } fromBufferAttribute(e, t) { return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } } Pl.prototype.isQuaternion = !0; class Rl { constructor(e = 0, t = 0, n = 0) { this.x = e, this.y = t, this.z = n } set(e, t, n) { return void 0 === n && (n = this.z), this.x = e, this.y = t, this.z = n, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this } add(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this) } addScalar(e) { return this.x += e, this.y += e, this.z += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this } sub(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this) } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this } multiply(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this) } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this } multiplyVectors(e, t) { return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this } applyEuler(e) { return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Il.setFromEuler(e)) } applyAxisAngle(e, t) { return this.applyQuaternion(Il.setFromAxisAngle(e, t)) } applyMatrix3(e) { const t = this.x, n = this.y, i = this.z, r = e.elements; return this.x = r[0] * t + r[3] * n + r[6] * i, this.y = r[1] * t + r[4] * n + r[7] * i, this.z = r[2] * t + r[5] * n + r[8] * i, this } applyNormalMatrix(e) { return this.applyMatrix3(e).normalize() } applyMatrix4(e) { const t = this.x, n = this.y, i = this.z, r = e.elements, s = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]); return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * s, this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * s, this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * s, this } applyQuaternion(e) { const t = this.x, n = this.y, i = this.z, r = e.x, s = e.y, a = e.z, o = e.w, l = o * t + s * i - a * n, c = o * n + a * t - r * i, u = o * i + r * n - s * t, h = -r * t - s * n - a * i; return this.x = l * o + h * -r + c * -a - u * -s, this.y = c * o + h * -s + u * -r - l * -a, this.z = u * o + h * -a + l * -s - c * -r, this } project(e) { return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix) } unproject(e) { return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld) } transformDirection(e) { const t = this.x, n = this.y, i = this.z, r = e.elements; return this.x = r[0] * t + r[4] * n + r[8] * i, this.y = r[1] * t + r[5] * n + r[9] * i, this.z = r[2] * t + r[6] * n + r[10] * i, this.normalize() } divide(e) { return this.x /= e.x, this.y /= e.y, this.z /= e.z, this } divideScalar(e) { return this.multiplyScalar(1 / e) } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this } clampLength(e, t) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this } lerpVectors(e, t, n) { return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this } cross(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e) } crossVectors(e, t) { const n = e.x, i = e.y, r = e.z, s = t.x, a = t.y, o = t.z; return this.x = i * o - r * a, this.y = r * s - n * o, this.z = n * a - i * s, this } projectOnVector(e) { const t = e.lengthSq(); if (0 === t) return this.set(0, 0, 0); const n = e.dot(this) / t; return this.copy(e).multiplyScalar(n) } projectOnPlane(e) { return Ol.copy(this).projectOnVector(e), this.sub(Ol) } reflect(e) { return this.sub(Ol.copy(e).multiplyScalar(2 * this.dot(e))) } angleTo(e) { const t = Math.sqrt(this.lengthSq() * e.lengthSq()); if (0 === t) return Math.PI / 2; const n = this.dot(e) / t; return Math.acos(il(n, -1, 1)) } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const t = this.x - e.x, n = this.y - e.y, i = this.z - e.z; return t * t + n * n + i * i } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z) } setFromSpherical(e) { return this.setFromSphericalCoords(e.radius, e.phi, e.theta) } setFromSphericalCoords(e, t, n) { const i = Math.sin(t) * e; return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this } setFromCylindrical(e) { return this.setFromCylindricalCoords(e.radius, e.theta, e.y) } setFromCylindricalCoords(e, t, n) { return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this } setFromMatrixPosition(e) { const t = e.elements; return this.x = t[12], this.y = t[13], this.z = t[14], this } setFromMatrixScale(e) { const t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), i = this.setFromMatrixColumn(e, 2).length(); return this.x = t, this.y = n, this.z = i, this } setFromMatrixColumn(e, t) { return this.fromArray(e.elements, 4 * t) } setFromMatrix3Column(e, t) { return this.fromArray(e.elements, 3 * t) } setFromEuler(e) { return this.x = e._x, this.y = e._y, this.z = e._z, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e } fromBufferAttribute(e, t, n) { return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this } randomDirection() { const e = 2 * (Math.random() - .5), t = Math.random() * Math.PI * 2, n = Math.sqrt(1 - e ** 2); return this.x = n * Math.cos(t), this.y = n * Math.sin(t), this.z = e, this } *[Symbol.iterator]() { yield this.x, yield this.y, yield this.z } } Rl.prototype.isVector3 = !0; const Ol = new Rl, Il = new Pl; class Fl { constructor(e = new Rl(1 / 0, 1 / 0, 1 / 0), t = new Rl(-1 / 0, -1 / 0, -1 / 0)) { this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromArray(e) { let t = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, s = -1 / 0, a = -1 / 0; for (let o = 0, l = e.length; o < l; o += 3) { const l = e[o], c = e[o + 1], u = e[o + 2]; l < t && (t = l), c < n && (n = c), u < i && (i = u), l > r && (r = l), c > s && (s = c), u > a && (a = u) } return this.min.set(t, n, i), this.max.set(r, s, a), this } setFromBufferAttribute(e) { let t = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, s = -1 / 0, a = -1 / 0; for (let o = 0, l = e.count; o < l; o++) { const l = e.getX(o), c = e.getY(o), u = e.getZ(o); l < t && (t = l), c < n && (n = c), u < i && (i = u), l > r && (r = l), c > s && (s = c), u > a && (a = u) } return this.min.set(t, n, i), this.max.set(r, s, a), this } setFromPoints(e) { this.makeEmpty(); for (let t = 0, n = e.length; t < n; t++)this.expandByPoint(e[t]); return this } setFromCenterAndSize(e, t) { const n = kl.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(n), this.max.copy(e).add(n), this } setFromObject(e, t = !1) { return this.makeEmpty(), this.expandByObject(e, t) } clone() { return (new this.constructor).copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z } getCenter(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } expandByObject(e, t = !1) { e.updateWorldMatrix(!1, !1); const n = e.geometry; if (void 0 !== n) if (t && null != n.attributes && void 0 !== n.attributes.position) { const t = n.attributes.position; for (let n = 0, i = t.count; n < i; n++)kl.fromBufferAttribute(t, n).applyMatrix4(e.matrixWorld), this.expandByPoint(kl) } else null === n.boundingBox && n.computeBoundingBox(), Nl.copy(n.boundingBox), Nl.applyMatrix4(e.matrixWorld), this.union(Nl); const i = e.children; for (let e = 0, n = i.length; e < n; e++)this.expandByObject(i[e], t); return this } containsPoint(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z) } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z } getParameter(e, t) { return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z)) } intersectsBox(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z) } intersectsSphere(e) { return this.clampPoint(e.center, kl), kl.distanceToSquared(e.center) <= e.radius * e.radius } intersectsPlane(e) { let t, n; return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant } intersectsTriangle(e) { if (this.isEmpty()) return !1; this.getCenter(Wl), ql.subVectors(this.max, Wl), Bl.subVectors(e.a, Wl), Hl.subVectors(e.b, Wl), Ul.subVectors(e.c, Wl), Vl.subVectors(Hl, Bl), Gl.subVectors(Ul, Hl), jl.subVectors(Bl, Ul); let t = [0, -Vl.z, Vl.y, 0, -Gl.z, Gl.y, 0, -jl.z, jl.y, Vl.z, 0, -Vl.x, Gl.z, 0, -Gl.x, jl.z, 0, -jl.x, -Vl.y, Vl.x, 0, -Gl.y, Gl.x, 0, -jl.y, jl.x, 0]; return !!Yl(t, Bl, Hl, Ul, ql) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Yl(t, Bl, Hl, Ul, ql) && ($l.crossVectors(Vl, Gl), t = [$l.x, $l.y, $l.z], Yl(t, Bl, Hl, Ul, ql))) } clampPoint(e, t) { return t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return kl.copy(e).clamp(this.min, this.max).sub(e).length() } getBoundingSphere(e) { return this.getCenter(e.center), e.radius = .5 * this.getSize(kl).length(), e } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } applyMatrix4(e) { return this.isEmpty() || (zl[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), zl[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), zl[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), zl[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), zl[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), zl[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), zl[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), zl[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(zl)), this } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } Fl.prototype.isBox3 = !0; const zl = [new Rl, new Rl, new Rl, new Rl, new Rl, new Rl, new Rl, new Rl], kl = new Rl, Nl = new Fl, Bl = new Rl, Hl = new Rl, Ul = new Rl, Vl = new Rl, Gl = new Rl, jl = new Rl, Wl = new Rl, ql = new Rl, $l = new Rl, Xl = new Rl; function Yl(e, t, n, i, r) { for (let s = 0, a = e.length - 3; s <= a; s += 3) { Xl.fromArray(e, s); const a = r.x * Math.abs(Xl.x) + r.y * Math.abs(Xl.y) + r.z * Math.abs(Xl.z), o = t.dot(Xl), l = n.dot(Xl), c = i.dot(Xl); if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a) return !1 } return !0 } const Zl = new Fl, Kl = new Rl, Jl = new Rl, Ql = new Rl; class ec { constructor(e = new Rl, t = -1) { this.center = e, this.radius = t } set(e, t) { return this.center.copy(e), this.radius = t, this } setFromPoints(e, t) { const n = this.center; void 0 !== t ? n.copy(t) : Zl.setFromPoints(e).getCenter(n); let i = 0; for (let t = 0, r = e.length; t < r; t++)i = Math.max(i, n.distanceToSquared(e[t])); return this.radius = Math.sqrt(i), this } copy(e) { return this.center.copy(e.center), this.radius = e.radius, this } isEmpty() { return this.radius < 0 } makeEmpty() { return this.center.set(0, 0, 0), this.radius = -1, this } containsPoint(e) { return e.distanceToSquared(this.center) <= this.radius * this.radius } distanceToPoint(e) { return e.distanceTo(this.center) - this.radius } intersectsSphere(e) { const t = this.radius + e.radius; return e.center.distanceToSquared(this.center) <= t * t } intersectsBox(e) { return e.intersectsSphere(this) } intersectsPlane(e) { return Math.abs(e.distanceToPoint(this.center)) <= this.radius } clampPoint(e, t) { const n = this.center.distanceToSquared(e); return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t } getBoundingBox(e) { return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e) } applyMatrix4(e) { return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this } translate(e) { return this.center.add(e), this } expandByPoint(e) { Ql.subVectors(e, this.center); const t = Ql.lengthSq(); if (t > this.radius * this.radius) { const e = Math.sqrt(t), n = .5 * (e - this.radius); this.center.add(Ql.multiplyScalar(n / e)), this.radius += n } return this } union(e) { return !0 === this.center.equals(e.center) ? Jl.set(0, 0, 1).multiplyScalar(e.radius) : Jl.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius), this.expandByPoint(Kl.copy(e.center).add(Jl)), this.expandByPoint(Kl.copy(e.center).sub(Jl)), this } equals(e) { return e.center.equals(this.center) && e.radius === this.radius } clone() { return (new this.constructor).copy(this) } } const tc = new Rl, nc = new Rl, ic = new Rl, rc = new Rl, sc = new Rl, ac = new Rl, oc = new Rl; class lc { constructor(e = new Rl, t = new Rl(0, 0, -1)) { this.origin = e, this.direction = t } set(e, t) { return this.origin.copy(e), this.direction.copy(t), this } copy(e) { return this.origin.copy(e.origin), this.direction.copy(e.direction), this } at(e, t) { return t.copy(this.direction).multiplyScalar(e).add(this.origin) } lookAt(e) { return this.direction.copy(e).sub(this.origin).normalize(), this } recast(e) { return this.origin.copy(this.at(e, tc)), this } closestPointToPoint(e, t) { t.subVectors(e, this.origin); const n = t.dot(this.direction); return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin) } distanceToPoint(e) { return Math.sqrt(this.distanceSqToPoint(e)) } distanceSqToPoint(e) { const t = tc.subVectors(e, this.origin).dot(this.direction); return t < 0 ? this.origin.distanceToSquared(e) : (tc.copy(this.direction).multiplyScalar(t).add(this.origin), tc.distanceToSquared(e)) } distanceSqToSegment(e, t, n, i) { nc.copy(e).add(t).multiplyScalar(.5), ic.copy(t).sub(e).normalize(), rc.copy(this.origin).sub(nc); const r = .5 * e.distanceTo(t), s = -this.direction.dot(ic), a = rc.dot(this.direction), o = -rc.dot(ic), l = rc.lengthSq(), c = Math.abs(1 - s * s); let u, h, d, p; if (c > 0) if (u = s * o - a, h = s * a - o, p = r * c, u >= 0) if (h >= -p) if (h <= p) { const e = 1 / c; u *= e, h *= e, d = u * (u + s * h + 2 * a) + h * (s * u + h + 2 * o) + l } else h = r, u = Math.max(0, -(s * h + a)), d = -u * u + h * (h + 2 * o) + l; else h = -r, u = Math.max(0, -(s * h + a)), d = -u * u + h * (h + 2 * o) + l; else h <= -p ? (u = Math.max(0, -(-s * r + a)), h = u > 0 ? -r : Math.min(Math.max(-r, -o), r), d = -u * u + h * (h + 2 * o) + l) : h <= p ? (u = 0, h = Math.min(Math.max(-r, -o), r), d = h * (h + 2 * o) + l) : (u = Math.max(0, -(s * r + a)), h = u > 0 ? r : Math.min(Math.max(-r, -o), r), d = -u * u + h * (h + 2 * o) + l); else h = s > 0 ? -r : r, u = Math.max(0, -(s * h + a)), d = -u * u + h * (h + 2 * o) + l; return n && n.copy(this.direction).multiplyScalar(u).add(this.origin), i && i.copy(ic).multiplyScalar(h).add(nc), d } intersectSphere(e, t) { tc.subVectors(e.center, this.origin); const n = tc.dot(this.direction), i = tc.dot(tc) - n * n, r = e.radius * e.radius; if (i > r) return null; const s = Math.sqrt(r - i), a = n - s, o = n + s; return a < 0 && o < 0 ? null : a < 0 ? this.at(o, t) : this.at(a, t) } intersectsSphere(e) { return this.distanceSqToPoint(e.center) <= e.radius * e.radius } distanceToPlane(e) { const t = e.normal.dot(this.direction); if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null; const n = -(this.origin.dot(e.normal) + e.constant) / t; return n >= 0 ? n : null } intersectPlane(e, t) { const n = this.distanceToPlane(e); return null === n ? null : this.at(n, t) } intersectsPlane(e) { const t = e.distanceToPoint(this.origin); return 0 === t || e.normal.dot(this.direction) * t < 0 } intersectBox(e, t) { let n, i, r, s, a, o; const l = 1 / this.direction.x, c = 1 / this.direction.y, u = 1 / this.direction.z, h = this.origin; return l >= 0 ? (n = (e.min.x - h.x) * l, i = (e.max.x - h.x) * l) : (n = (e.max.x - h.x) * l, i = (e.min.x - h.x) * l), c >= 0 ? (r = (e.min.y - h.y) * c, s = (e.max.y - h.y) * c) : (r = (e.max.y - h.y) * c, s = (e.min.y - h.y) * c), n > s || r > i ? null : ((r > n || n != n) && (n = r), (s < i || i != i) && (i = s), u >= 0 ? (a = (e.min.z - h.z) * u, o = (e.max.z - h.z) * u) : (a = (e.max.z - h.z) * u, o = (e.min.z - h.z) * u), n > o || a > i ? null : ((a > n || n != n) && (n = a), (o < i || i != i) && (i = o), i < 0 ? null : this.at(n >= 0 ? n : i, t))) } intersectsBox(e) { return null !== this.intersectBox(e, tc) } intersectTriangle(e, t, n, i, r) { sc.subVectors(t, e), ac.subVectors(n, e), oc.crossVectors(sc, ac); let s, a = this.direction.dot(oc); if (a > 0) { if (i) return null; s = 1 } else { if (!(a < 0)) return null; s = -1, a = -a } rc.subVectors(this.origin, e); const o = s * this.direction.dot(ac.crossVectors(rc, ac)); if (o < 0) return null; const l = s * this.direction.dot(sc.cross(rc)); if (l < 0) return null; if (o + l > a) return null; const c = -s * rc.dot(oc); return c < 0 ? null : this.at(c / a, r) } applyMatrix4(e) { return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this } equals(e) { return e.origin.equals(this.origin) && e.direction.equals(this.direction) } clone() { return (new this.constructor).copy(this) } } class cc { constructor() { this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.") } set(e, t, n, i, r, s, a, o, l, c, u, h, d, p, f, m) { const g = this.elements; return g[0] = e, g[4] = t, g[8] = n, g[12] = i, g[1] = r, g[5] = s, g[9] = a, g[13] = o, g[2] = l, g[6] = c, g[10] = u, g[14] = h, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this } identity() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } clone() { return (new cc).fromArray(this.elements) } copy(e) { const t = this.elements, n = e.elements; return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this } copyPosition(e) { const t = this.elements, n = e.elements; return t[12] = n[12], t[13] = n[13], t[14] = n[14], this } setFromMatrix3(e) { const t = e.elements; return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this } extractBasis(e, t, n) { return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this } makeBasis(e, t, n) { return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this } extractRotation(e) { const t = this.elements, n = e.elements, i = 1 / uc.setFromMatrixColumn(e, 0).length(), r = 1 / uc.setFromMatrixColumn(e, 1).length(), s = 1 / uc.setFromMatrixColumn(e, 2).length(); return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = 0, t[8] = n[8] * s, t[9] = n[9] * s, t[10] = n[10] * s, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromEuler(e) { e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."); const t = this.elements, n = e.x, i = e.y, r = e.z, s = Math.cos(n), a = Math.sin(n), o = Math.cos(i), l = Math.sin(i), c = Math.cos(r), u = Math.sin(r); if ("XYZ" === e.order) { const e = s * c, n = s * u, i = a * c, r = a * u; t[0] = o * c, t[4] = -o * u, t[8] = l, t[1] = n + i * l, t[5] = e - r * l, t[9] = -a * o, t[2] = r - e * l, t[6] = i + n * l, t[10] = s * o } else if ("YXZ" === e.order) { const e = o * c, n = o * u, i = l * c, r = l * u; t[0] = e + r * a, t[4] = i * a - n, t[8] = s * l, t[1] = s * u, t[5] = s * c, t[9] = -a, t[2] = n * a - i, t[6] = r + e * a, t[10] = s * o } else if ("ZXY" === e.order) { const e = o * c, n = o * u, i = l * c, r = l * u; t[0] = e - r * a, t[4] = -s * u, t[8] = i + n * a, t[1] = n + i * a, t[5] = s * c, t[9] = r - e * a, t[2] = -s * l, t[6] = a, t[10] = s * o } else if ("ZYX" === e.order) { const e = s * c, n = s * u, i = a * c, r = a * u; t[0] = o * c, t[4] = i * l - n, t[8] = e * l + r, t[1] = o * u, t[5] = r * l + e, t[9] = n * l - i, t[2] = -l, t[6] = a * o, t[10] = s * o } else if ("YZX" === e.order) { const e = s * o, n = s * l, i = a * o, r = a * l; t[0] = o * c, t[4] = r - e * u, t[8] = i * u + n, t[1] = u, t[5] = s * c, t[9] = -a * c, t[2] = -l * c, t[6] = n * u + i, t[10] = e - r * u } else if ("XZY" === e.order) { const e = s * o, n = s * l, i = a * o, r = a * l; t[0] = o * c, t[4] = -u, t[8] = l * c, t[1] = e * u + r, t[5] = s * c, t[9] = n * u - i, t[2] = i * u - n, t[6] = a * c, t[10] = r * u + e } return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromQuaternion(e) { return this.compose(dc, e, pc) } lookAt(e, t, n) { const i = this.elements; return gc.subVectors(e, t), 0 === gc.lengthSq() && (gc.z = 1), gc.normalize(), fc.crossVectors(n, gc), 0 === fc.lengthSq() && (1 === Math.abs(n.z) ? gc.x += 1e-4 : gc.z += 1e-4, gc.normalize(), fc.crossVectors(n, gc)), fc.normalize(), mc.crossVectors(gc, fc), i[0] = fc.x, i[4] = mc.x, i[8] = gc.x, i[1] = fc.y, i[5] = mc.y, i[9] = gc.y, i[2] = fc.z, i[6] = mc.z, i[10] = gc.z, this } multiply(e, t) { return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { const n = e.elements, i = t.elements, r = this.elements, s = n[0], a = n[4], o = n[8], l = n[12], c = n[1], u = n[5], h = n[9], d = n[13], p = n[2], f = n[6], m = n[10], g = n[14], v = n[3], y = n[7], x = n[11], _ = n[15], w = i[0], b = i[4], S = i[8], E = i[12], M = i[1], T = i[5], C = i[9], D = i[13], L = i[2], A = i[6], P = i[10], R = i[14], O = i[3], I = i[7], F = i[11], z = i[15]; return r[0] = s * w + a * M + o * L + l * O, r[4] = s * b + a * T + o * A + l * I, r[8] = s * S + a * C + o * P + l * F, r[12] = s * E + a * D + o * R + l * z, r[1] = c * w + u * M + h * L + d * O, r[5] = c * b + u * T + h * A + d * I, r[9] = c * S + u * C + h * P + d * F, r[13] = c * E + u * D + h * R + d * z, r[2] = p * w + f * M + m * L + g * O, r[6] = p * b + f * T + m * A + g * I, r[10] = p * S + f * C + m * P + g * F, r[14] = p * E + f * D + m * R + g * z, r[3] = v * w + y * M + x * L + _ * O, r[7] = v * b + y * T + x * A + _ * I, r[11] = v * S + y * C + x * P + _ * F, r[15] = v * E + y * D + x * R + _ * z, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this } determinant() { const e = this.elements, t = e[0], n = e[4], i = e[8], r = e[12], s = e[1], a = e[5], o = e[9], l = e[13], c = e[2], u = e[6], h = e[10], d = e[14]; return e[3] * (+r * o * u - i * l * u - r * a * h + n * l * h + i * a * d - n * o * d) + e[7] * (+t * o * d - t * l * h + r * s * h - i * s * d + i * l * c - r * o * c) + e[11] * (+t * l * u - t * a * d - r * s * u + n * s * d + r * a * c - n * l * c) + e[15] * (-i * a * c - t * o * u + t * a * h + i * s * u - n * s * h + n * o * c) } transpose() { const e = this.elements; let t; return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this } setPosition(e, t, n) { const i = this.elements; return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this } invert() { const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], s = e[4], a = e[5], o = e[6], l = e[7], c = e[8], u = e[9], h = e[10], d = e[11], p = e[12], f = e[13], m = e[14], g = e[15], v = u * m * l - f * h * l + f * o * d - a * m * d - u * o * g + a * h * g, y = p * h * l - c * m * l - p * o * d + s * m * d + c * o * g - s * h * g, x = c * f * l - p * u * l + p * a * d - s * f * d - c * a * g + s * u * g, _ = p * u * o - c * f * o - p * a * h + s * f * h + c * a * m - s * u * m, w = t * v + n * y + i * x + r * _; if (0 === w) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); const b = 1 / w; return e[0] = v * b, e[1] = (f * h * r - u * m * r - f * i * d + n * m * d + u * i * g - n * h * g) * b, e[2] = (a * m * r - f * o * r + f * i * l - n * m * l - a * i * g + n * o * g) * b, e[3] = (u * o * r - a * h * r - u * i * l + n * h * l + a * i * d - n * o * d) * b, e[4] = y * b, e[5] = (c * m * r - p * h * r + p * i * d - t * m * d - c * i * g + t * h * g) * b, e[6] = (p * o * r - s * m * r - p * i * l + t * m * l + s * i * g - t * o * g) * b, e[7] = (s * h * r - c * o * r + c * i * l - t * h * l - s * i * d + t * o * d) * b, e[8] = x * b, e[9] = (p * u * r - c * f * r - p * n * d + t * f * d + c * n * g - t * u * g) * b, e[10] = (s * f * r - p * a * r + p * n * l - t * f * l - s * n * g + t * a * g) * b, e[11] = (c * a * r - s * u * r - c * n * l + t * u * l + s * n * d - t * a * d) * b, e[12] = _ * b, e[13] = (c * f * i - p * u * i + p * n * h - t * f * h - c * n * m + t * u * m) * b, e[14] = (p * a * i - s * f * i - p * n * o + t * f * o + s * n * m - t * a * m) * b, e[15] = (s * u * i - c * a * i + c * n * o - t * u * o - s * n * h + t * a * h) * b, this } scale(e) { const t = this.elements, n = e.x, i = e.y, r = e.z; return t[0] *= n, t[4] *= i, t[8] *= r, t[1] *= n, t[5] *= i, t[9] *= r, t[2] *= n, t[6] *= i, t[10] *= r, t[3] *= n, t[7] *= i, t[11] *= r, this } getMaxScaleOnAxis() { const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10]; return Math.sqrt(Math.max(t, n, i)) } makeTranslation(e, t, n) { return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this } makeRotationX(e) { const t = Math.cos(e), n = Math.sin(e); return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this } makeRotationY(e) { const t = Math.cos(e), n = Math.sin(e); return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this } makeRotationZ(e) { const t = Math.cos(e), n = Math.sin(e); return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } makeRotationAxis(e, t) { const n = Math.cos(t), i = Math.sin(t), r = 1 - n, s = e.x, a = e.y, o = e.z, l = r * s, c = r * a; return this.set(l * s + n, l * a - i * o, l * o + i * a, 0, l * a + i * o, c * a + n, c * o - i * s, 0, l * o - i * a, c * o + i * s, r * o * o + n, 0, 0, 0, 0, 1), this } makeScale(e, t, n) { return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this } makeShear(e, t, n, i, r, s) { return this.set(1, n, r, 0, e, 1, s, 0, t, i, 1, 0, 0, 0, 0, 1), this } compose(e, t, n) { const i = this.elements, r = t._x, s = t._y, a = t._z, o = t._w, l = r + r, c = s + s, u = a + a, h = r * l, d = r * c, p = r * u, f = s * c, m = s * u, g = a * u, v = o * l, y = o * c, x = o * u, _ = n.x, w = n.y, b = n.z; return i[0] = (1 - (f + g)) * _, i[1] = (d + x) * _, i[2] = (p - y) * _, i[3] = 0, i[4] = (d - x) * w, i[5] = (1 - (h + g)) * w, i[6] = (m + v) * w, i[7] = 0, i[8] = (p + y) * b, i[9] = (m - v) * b, i[10] = (1 - (h + f)) * b, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this } decompose(e, t, n) { const i = this.elements; let r = uc.set(i[0], i[1], i[2]).length(); const s = uc.set(i[4], i[5], i[6]).length(), a = uc.set(i[8], i[9], i[10]).length(); this.determinant() < 0 && (r = -r), e.x = i[12], e.y = i[13], e.z = i[14], hc.copy(this); const o = 1 / r, l = 1 / s, c = 1 / a; return hc.elements[0] *= o, hc.elements[1] *= o, hc.elements[2] *= o, hc.elements[4] *= l, hc.elements[5] *= l, hc.elements[6] *= l, hc.elements[8] *= c, hc.elements[9] *= c, hc.elements[10] *= c, t.setFromRotationMatrix(hc), n.x = r, n.y = s, n.z = a, this } makePerspective(e, t, n, i, r, s) { void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."); const a = this.elements, o = 2 * r / (t - e), l = 2 * r / (n - i), c = (t + e) / (t - e), u = (n + i) / (n - i), h = -(s + r) / (s - r), d = -2 * s * r / (s - r); return a[0] = o, a[4] = 0, a[8] = c, a[12] = 0, a[1] = 0, a[5] = l, a[9] = u, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = h, a[14] = d, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this } makeOrthographic(e, t, n, i, r, s) { const a = this.elements, o = 1 / (t - e), l = 1 / (n - i), c = 1 / (s - r), u = (t + e) * o, h = (n + i) * l, d = (s + r) * c; return a[0] = 2 * o, a[4] = 0, a[8] = 0, a[12] = -u, a[1] = 0, a[5] = 2 * l, a[9] = 0, a[13] = -h, a[2] = 0, a[6] = 0, a[10] = -2 * c, a[14] = -d, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this } equals(e) { const t = this.elements, n = e.elements; for (let e = 0; e < 16; e++)if (t[e] !== n[e]) return !1; return !0 } fromArray(e, t = 0) { for (let n = 0; n < 16; n++)this.elements[n] = e[n + t]; return this } toArray(e = [], t = 0) { const n = this.elements; return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e } } cc.prototype.isMatrix4 = !0; const uc = new Rl, hc = new cc, dc = new Rl(0, 0, 0), pc = new Rl(1, 1, 1), fc = new Rl, mc = new Rl, gc = new Rl, vc = new cc, yc = new Pl; class xc { constructor(e = 0, t = 0, n = 0, i = xc.DefaultOrder) { this._x = e, this._y = t, this._z = n, this._order = i } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get order() { return this._order } set order(e) { this._order = e, this._onChangeCallback() } set(e, t, n, i = this._order) { return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._order) } copy(e) { return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this } setFromRotationMatrix(e, t = this._order, n = !0) { const i = e.elements, r = i[0], s = i[4], a = i[8], o = i[1], l = i[5], c = i[9], u = i[2], h = i[6], d = i[10]; switch (t) { case "XYZ": this._y = Math.asin(il(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(h, l), this._z = 0); break; case "YXZ": this._x = Math.asin(-il(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-u, r), this._z = 0); break; case "ZXY": this._x = Math.asin(il(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(-u, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(o, r)); break; case "ZYX": this._y = Math.asin(-il(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(h, d), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-s, l)); break; case "YZX": this._z = Math.asin(il(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-u, r)) : (this._x = 0, this._y = Math.atan2(a, d)); break; case "XZY": this._z = Math.asin(-il(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(h, l), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-c, d), this._y = 0); break; default: console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t) }return this._order = t, !0 === n && this._onChangeCallback(), this } setFromQuaternion(e, t, n) { return vc.makeRotationFromQuaternion(e), this.setFromRotationMatrix(vc, t, n) } setFromVector3(e, t = this._order) { return this.set(e.x, e.y, e.z, t) } reorder(e) { return yc.setFromEuler(this), this.setFromQuaternion(yc, e) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order } fromArray(e) { return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } } xc.prototype.isEuler = !0, xc.DefaultOrder = "XYZ", xc.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]; class _c { constructor() { this.mask = 1 } set(e) { this.mask = (1 << e | 0) >>> 0 } enable(e) { this.mask |= 1 << e | 0 } enableAll() { this.mask = -1 } toggle(e) { this.mask ^= 1 << e | 0 } disable(e) { this.mask &= ~(1 << e | 0) } disableAll() { this.mask = 0 } test(e) { return 0 != (this.mask & e.mask) } isEnabled(e) { return 0 != (this.mask & (1 << e | 0)) } } let wc = 0; const bc = new Rl, Sc = new Pl, Ec = new cc, Mc = new Rl, Tc = new Rl, Cc = new Rl, Dc = new Pl, Lc = new Rl(1, 0, 0), Ac = new Rl(0, 1, 0), Pc = new Rl(0, 0, 1), Rc = { type: "added" }, Oc = { type: "removed" }; class Ic extends Ko { constructor() { super(), Object.defineProperty(this, "id", { value: wc++ }), this.uuid = nl(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Ic.DefaultUp.clone(); const e = new Rl, t = new xc, n = new Pl, i = new Rl(1, 1, 1); t._onChange((function () { n.setFromEuler(t, !1) })), n._onChange((function () { t.setFromQuaternion(n, void 0, !1) })), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: e }, rotation: { configurable: !0, enumerable: !0, value: t }, quaternion: { configurable: !0, enumerable: !0, value: n }, scale: { configurable: !0, enumerable: !0, value: i }, modelViewMatrix: { value: new cc }, normalMatrix: { value: new hl } }), this.matrix = new cc, this.matrixWorld = new cc, this.matrixAutoUpdate = Ic.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new _c, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {} } onBeforeRender() { } onAfterRender() { } applyMatrix4(e) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale) } applyQuaternion(e) { return this.quaternion.premultiply(e), this } setRotationFromAxisAngle(e, t) { this.quaternion.setFromAxisAngle(e, t) } setRotationFromEuler(e) { this.quaternion.setFromEuler(e, !0) } setRotationFromMatrix(e) { this.quaternion.setFromRotationMatrix(e) } setRotationFromQuaternion(e) { this.quaternion.copy(e) } rotateOnAxis(e, t) { return Sc.setFromAxisAngle(e, t), this.quaternion.multiply(Sc), this } rotateOnWorldAxis(e, t) { return Sc.setFromAxisAngle(e, t), this.quaternion.premultiply(Sc), this } rotateX(e) { return this.rotateOnAxis(Lc, e) } rotateY(e) { return this.rotateOnAxis(Ac, e) } rotateZ(e) { return this.rotateOnAxis(Pc, e) } translateOnAxis(e, t) { return bc.copy(e).applyQuaternion(this.quaternion), this.position.add(bc.multiplyScalar(t)), this } translateX(e) { return this.translateOnAxis(Lc, e) } translateY(e) { return this.translateOnAxis(Ac, e) } translateZ(e) { return this.translateOnAxis(Pc, e) } localToWorld(e) { return e.applyMatrix4(this.matrixWorld) } worldToLocal(e) { return e.applyMatrix4(Ec.copy(this.matrixWorld).invert()) } lookAt(e, t, n) { e.isVector3 ? Mc.copy(e) : Mc.set(e, t, n); const i = this.parent; this.updateWorldMatrix(!0, !1), Tc.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Ec.lookAt(Tc, Mc, this.up) : Ec.lookAt(Mc, Tc, this.up), this.quaternion.setFromRotationMatrix(Ec), i && (Ec.extractRotation(i.matrixWorld), Sc.setFromRotationMatrix(Ec), this.quaternion.premultiply(Sc.invert())) } add(e) { if (arguments.length > 1) { for (let e = 0; e < arguments.length; e++)this.add(arguments[e]); return this } return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(Rc)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this) } remove(e) { if (arguments.length > 1) { for (let e = 0; e < arguments.length; e++)this.remove(arguments[e]); return this } const t = this.children.indexOf(e); return -1 !== t && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(Oc)), this } removeFromParent() { const e = this.parent; return null !== e && e.remove(this), this } clear() { for (let e = 0; e < this.children.length; e++) { const t = this.children[e]; t.parent = null, t.dispatchEvent(Oc) } return this.children.length = 0, this } attach(e) { return this.updateWorldMatrix(!0, !1), Ec.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), Ec.multiply(e.parent.matrixWorld)), e.applyMatrix4(Ec), this.add(e), e.updateWorldMatrix(!1, !0), this } getObjectById(e) { return this.getObjectByProperty("id", e) } getObjectByName(e) { return this.getObjectByProperty("name", e) } getObjectByProperty(e, t) { if (this[e] === t) return this; for (let n = 0, i = this.children.length; n < i; n++) { const i = this.children[n].getObjectByProperty(e, t); if (void 0 !== i) return i } } getWorldPosition(e) { return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld) } getWorldQuaternion(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Tc, e, Cc), e } getWorldScale(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Tc, Dc, e), e } getWorldDirection(e) { this.updateWorldMatrix(!0, !1); const t = this.matrixWorld.elements; return e.set(t[8], t[9], t[10]).normalize() } raycast() { } traverse(e) { e(this); const t = this.children; for (let n = 0, i = t.length; n < i; n++)t[n].traverse(e) } traverseVisible(e) { if (!1 === this.visible) return; e(this); const t = this.children; for (let n = 0, i = t.length; n < i; n++)t[n].traverseVisible(e) } traverseAncestors(e) { const t = this.parent; null !== t && (e(t), t.traverseAncestors(e)) } updateMatrix() { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 } updateMatrixWorld(e) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0); const t = this.children; for (let n = 0, i = t.length; n < i; n++)t[n].updateMatrixWorld(e) } updateWorldMatrix(e, t) { const n = this.parent; if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t) { const e = this.children; for (let t = 0, n = e.length; t < n; t++)e[t].updateWorldMatrix(!1, !0) } } toJSON(e) { const t = void 0 === e || "string" == typeof e, n = {}; t && (e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, n.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }); const i = {}; function r(t, n) { return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid } if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && (i.environment = this.environment.toJSON(e).uuid); else if (this.isMesh || this.isLine || this.isPoints) { i.geometry = r(e.geometries, this.geometry); const t = this.geometry.parameters; if (void 0 !== t && void 0 !== t.shapes) { const n = t.shapes; if (Array.isArray(n)) for (let t = 0, i = n.length; t < i; t++) { const i = n[t]; r(e.shapes, i) } else r(e.shapes, n) } } if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), void 0 !== this.material) if (Array.isArray(this.material)) { const t = []; for (let n = 0, i = this.material.length; n < i; n++)t.push(r(e.materials, this.material[n])); i.material = t } else i.material = r(e.materials, this.material); if (this.children.length > 0) { i.children = []; for (let t = 0; t < this.children.length; t++)i.children.push(this.children[t].toJSON(e).object) } if (this.animations.length > 0) { i.animations = []; for (let t = 0; t < this.animations.length; t++) { const n = this.animations[t]; i.animations.push(r(e.animations, n)) } } if (t) { const t = s(e.geometries), i = s(e.materials), r = s(e.textures), a = s(e.images), o = s(e.shapes), l = s(e.skeletons), c = s(e.animations), u = s(e.nodes); t.length > 0 && (n.geometries = t), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), a.length > 0 && (n.images = a), o.length > 0 && (n.shapes = o), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c), u.length > 0 && (n.nodes = u) } return n.object = i, n; function s(e) { const t = []; for (const n in e) { const i = e[n]; delete i.metadata, t.push(i) } return t } } clone(e) { return (new this.constructor).copy(this, e) } copy(e, t = !0) { if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t) for (let t = 0; t < e.children.length; t++) { const n = e.children[t]; this.add(n.clone()) } return this } } Ic.DefaultUp = new Rl(0, 1, 0), Ic.DefaultMatrixAutoUpdate = !0, Ic.prototype.isObject3D = !0; const Fc = new Rl, zc = new Rl, kc = new Rl, Nc = new Rl, Bc = new Rl, Hc = new Rl, Uc = new Rl, Vc = new Rl, Gc = new Rl, jc = new Rl; class Wc { constructor(e = new Rl, t = new Rl, n = new Rl) { this.a = e, this.b = t, this.c = n } static getNormal(e, t, n, i) { i.subVectors(n, t), Fc.subVectors(e, t), i.cross(Fc); const r = i.lengthSq(); return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0) } static getBarycoord(e, t, n, i, r) { Fc.subVectors(i, t), zc.subVectors(n, t), kc.subVectors(e, t); const s = Fc.dot(Fc), a = Fc.dot(zc), o = Fc.dot(kc), l = zc.dot(zc), c = zc.dot(kc), u = s * l - a * a; if (0 === u) return r.set(-2, -1, -1); const h = 1 / u, d = (l * o - a * c) * h, p = (s * c - a * o) * h; return r.set(1 - d - p, p, d) } static containsPoint(e, t, n, i) { return this.getBarycoord(e, t, n, i, Nc), Nc.x >= 0 && Nc.y >= 0 && Nc.x + Nc.y <= 1 } static getUV(e, t, n, i, r, s, a, o) { return this.getBarycoord(e, t, n, i, Nc), o.set(0, 0), o.addScaledVector(r, Nc.x), o.addScaledVector(s, Nc.y), o.addScaledVector(a, Nc.z), o } static isFrontFacing(e, t, n, i) { return Fc.subVectors(n, t), zc.subVectors(e, t), Fc.cross(zc).dot(i) < 0 } set(e, t, n) { return this.a.copy(e), this.b.copy(t), this.c.copy(n), this } setFromPointsAndIndices(e, t, n, i) { return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this } setFromAttributeAndIndices(e, t, n, i) { return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this } clone() { return (new this.constructor).copy(this) } copy(e) { return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this } getArea() { return Fc.subVectors(this.c, this.b), zc.subVectors(this.a, this.b), .5 * Fc.cross(zc).length() } getMidpoint(e) { return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) } getNormal(e) { return Wc.getNormal(this.a, this.b, this.c, e) } getPlane(e) { return e.setFromCoplanarPoints(this.a, this.b, this.c) } getBarycoord(e, t) { return Wc.getBarycoord(e, this.a, this.b, this.c, t) } getUV(e, t, n, i, r) { return Wc.getUV(e, this.a, this.b, this.c, t, n, i, r) } containsPoint(e) { return Wc.containsPoint(e, this.a, this.b, this.c) } isFrontFacing(e) { return Wc.isFrontFacing(this.a, this.b, this.c, e) } intersectsBox(e) { return e.intersectsTriangle(this) } closestPointToPoint(e, t) { const n = this.a, i = this.b, r = this.c; let s, a; Bc.subVectors(i, n), Hc.subVectors(r, n), Vc.subVectors(e, n); const o = Bc.dot(Vc), l = Hc.dot(Vc); if (o <= 0 && l <= 0) return t.copy(n); Gc.subVectors(e, i); const c = Bc.dot(Gc), u = Hc.dot(Gc); if (c >= 0 && u <= c) return t.copy(i); const h = o * u - c * l; if (h <= 0 && o >= 0 && c <= 0) return s = o / (o - c), t.copy(n).addScaledVector(Bc, s); jc.subVectors(e, r); const d = Bc.dot(jc), p = Hc.dot(jc); if (p >= 0 && d <= p) return t.copy(r); const f = d * l - o * p; if (f <= 0 && l >= 0 && p <= 0) return a = l / (l - p), t.copy(n).addScaledVector(Hc, a); const m = c * p - d * u; if (m <= 0 && u - c >= 0 && d - p >= 0) return Uc.subVectors(r, i), a = (u - c) / (u - c + (d - p)), t.copy(i).addScaledVector(Uc, a); const g = 1 / (m + f + h); return s = f * g, a = h * g, t.copy(n).addScaledVector(Bc, s).addScaledVector(Hc, a) } equals(e) { return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c) } } let qc = 0; class $c extends Ko { constructor() { super(), Object.defineProperty(this, "id", { value: qc++ }), this.uuid = nl(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = po, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = qo, this.stencilZFail = qo, this.stencilZPass = qo, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0 } get alphaTest() { return this._alphaTest } set alphaTest(e) { this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e } onBuild() { } onBeforeRender() { } onBeforeCompile() { } customProgramCacheKey() { return this.onBeforeCompile.toString() } setValues(e) { if (void 0 !== e) for (const t in e) { const n = e[t]; if (void 0 === n) { console.warn("THREE.Material: '" + t + "' parameter is undefined."); continue } if ("shading" === t) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n; continue } const i = this[t]; void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.") } } toJSON(e) { const t = void 0 === e || "string" == typeof e; t && (e = { textures: {}, images: {} }); const n = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } }; function i(e) { const t = []; for (const n in e) { const i = e[n]; delete i.metadata, t.push(i) } return t } if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t) { const t = i(e.textures), r = i(e.images); t.length > 0 && (n.textures = t), r.length > 0 && (n.images = r) } return n } clone() { return (new this.constructor).copy(this) } copy(e) { this.name = e.name, this.fog = e.fog, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite; const t = e.clippingPlanes; let n = null; if (null !== t) { const e = t.length; n = new Array(e); for (let i = 0; i !== e; ++i)n[i] = t[i].clone() } return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this } dispose() { this.dispatchEvent({ type: "dispose" }) } set needsUpdate(e) { !0 === e && this.version++ } } $c.prototype.isMaterial = !0, $c.fromType = function () { return null }; class Xc extends $c { constructor(e) { super(), this.type = "MeshBasicMaterial", this.color = new _l(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this } } Xc.prototype.isMeshBasicMaterial = !0; const Yc = new Rl, Zc = new ul; class Kc { constructor(e, t, n) { if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === n, this.usage = $o, this.updateRange = { offset: 0, count: -1 }, this.version = 0 } onUploadCallback() { } set needsUpdate(e) { !0 === e && this.version++ } setUsage(e) { return this.usage = e, this } copy(e) { return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this } copyAt(e, t, n) { e *= this.itemSize, n *= t.itemSize; for (let i = 0, r = this.itemSize; i < r; i++)this.array[e + i] = t.array[n + i]; return this } copyArray(e) { return this.array.set(e), this } copyColorsArray(e) { const t = this.array; let n = 0; for (let i = 0, r = e.length; i < r; i++) { let r = e[i]; void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), r = new _l), t[n++] = r.r, t[n++] = r.g, t[n++] = r.b } return this } copyVector2sArray(e) { const t = this.array; let n = 0; for (let i = 0, r = e.length; i < r; i++) { let r = e[i]; void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), r = new ul), t[n++] = r.x, t[n++] = r.y } return this } copyVector3sArray(e) { const t = this.array; let n = 0; for (let i = 0, r = e.length; i < r; i++) { let r = e[i]; void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), r = new Rl), t[n++] = r.x, t[n++] = r.y, t[n++] = r.z } return this } copyVector4sArray(e) { const t = this.array; let n = 0; for (let i = 0, r = e.length; i < r; i++) { let r = e[i]; void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), r = new Cl), t[n++] = r.x, t[n++] = r.y, t[n++] = r.z, t[n++] = r.w } return this } applyMatrix3(e) { if (2 === this.itemSize) for (let t = 0, n = this.count; t < n; t++)Zc.fromBufferAttribute(this, t), Zc.applyMatrix3(e), this.setXY(t, Zc.x, Zc.y); else if (3 === this.itemSize) for (let t = 0, n = this.count; t < n; t++)Yc.fromBufferAttribute(this, t), Yc.applyMatrix3(e), this.setXYZ(t, Yc.x, Yc.y, Yc.z); return this } applyMatrix4(e) { for (let t = 0, n = this.count; t < n; t++)Yc.x = this.getX(t), Yc.y = this.getY(t), Yc.z = this.getZ(t), Yc.applyMatrix4(e), this.setXYZ(t, Yc.x, Yc.y, Yc.z); return this } applyNormalMatrix(e) { for (let t = 0, n = this.count; t < n; t++)Yc.x = this.getX(t), Yc.y = this.getY(t), Yc.z = this.getZ(t), Yc.applyNormalMatrix(e), this.setXYZ(t, Yc.x, Yc.y, Yc.z); return this } transformDirection(e) { for (let t = 0, n = this.count; t < n; t++)Yc.x = this.getX(t), Yc.y = this.getY(t), Yc.z = this.getZ(t), Yc.transformDirection(e), this.setXYZ(t, Yc.x, Yc.y, Yc.z); return this } set(e, t = 0) { return this.array.set(e, t), this } getX(e) { return this.array[e * this.itemSize] } setX(e, t) { return this.array[e * this.itemSize] = t, this } getY(e) { return this.array[e * this.itemSize + 1] } setY(e, t) { return this.array[e * this.itemSize + 1] = t, this } getZ(e) { return this.array[e * this.itemSize + 2] } setZ(e, t) { return this.array[e * this.itemSize + 2] = t, this } getW(e) { return this.array[e * this.itemSize + 3] } setW(e, t) { return this.array[e * this.itemSize + 3] = t, this } setXY(e, t, n) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this } setXYZ(e, t, n, i) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this } setXYZW(e, t, n, i, r) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = r, this } onUpload(e) { return this.onUploadCallback = e, this } clone() { return new this.constructor(this.array, this.itemSize).copy(this) } toJSON() { const e = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized }; return "" !== this.name && (e.name = this.name), this.usage !== $o && (e.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (e.updateRange = this.updateRange), e } } Kc.prototype.isBufferAttribute = !0; class Jc extends Kc { constructor(e, t, n) { super(new Uint16Array(e), t, n) } } class Qc extends Kc { constructor(e, t, n) { super(new Uint32Array(e), t, n) } } (class extends Kc { constructor(e, t, n) { super(new Uint16Array(e), t, n) } }).prototype.isFloat16BufferAttribute = !0; class eu extends Kc { constructor(e, t, n) { super(new Float32Array(e), t, n) } } let tu = 0; const nu = new cc, iu = new Ic, ru = new Rl, su = new Fl, au = new Fl, ou = new Rl; class lu extends Ko { constructor() { super(), Object.defineProperty(this, "id", { value: tu++ }), this.uuid = nl(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } getIndex() { return this.index } setIndex(e) { return Array.isArray(e) ? this.index = new (dl(e) ? Qc : Jc)(e, 1) : this.index = e, this } getAttribute(e) { return this.attributes[e] } setAttribute(e, t) { return this.attributes[e] = t, this } deleteAttribute(e) { return delete this.attributes[e], this } hasAttribute(e) { return void 0 !== this.attributes[e] } addGroup(e, t, n = 0) { this.groups.push({ start: e, count: t, materialIndex: n }) } clearGroups() { this.groups = [] } setDrawRange(e, t) { this.drawRange.start = e, this.drawRange.count = t } applyMatrix4(e) { const t = this.attributes.position; void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0); const n = this.attributes.normal; if (void 0 !== n) { const t = (new hl).getNormalMatrix(e); n.applyNormalMatrix(t), n.needsUpdate = !0 } const i = this.attributes.tangent; return void 0 !== i && (i.transformDirection(e), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this } applyQuaternion(e) { return nu.makeRotationFromQuaternion(e), this.applyMatrix4(nu), this } rotateX(e) { return nu.makeRotationX(e), this.applyMatrix4(nu), this } rotateY(e) { return nu.makeRotationY(e), this.applyMatrix4(nu), this } rotateZ(e) { return nu.makeRotationZ(e), this.applyMatrix4(nu), this } translate(e, t, n) { return nu.makeTranslation(e, t, n), this.applyMatrix4(nu), this } scale(e, t, n) { return nu.makeScale(e, t, n), this.applyMatrix4(nu), this } lookAt(e) { return iu.lookAt(e), iu.updateMatrix(), this.applyMatrix4(iu.matrix), this } center() { return this.computeBoundingBox(), this.boundingBox.getCenter(ru).negate(), this.translate(ru.x, ru.y, ru.z), this } setFromPoints(e) { const t = []; for (let n = 0, i = e.length; n < i; n++) { const i = e[n]; t.push(i.x, i.y, i.z || 0) } return this.setAttribute("position", new eu(t, 3)), this } computeBoundingBox() { null === this.boundingBox && (this.boundingBox = new Fl); const e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new Rl(-1 / 0, -1 / 0, -1 / 0), new Rl(1 / 0, 1 / 0, 1 / 0)); if (void 0 !== e) { if (this.boundingBox.setFromBufferAttribute(e), t) for (let e = 0, n = t.length; e < n; e++) { const n = t[e]; su.setFromBufferAttribute(n), this.morphTargetsRelative ? (ou.addVectors(this.boundingBox.min, su.min), this.boundingBox.expandByPoint(ou), ou.addVectors(this.boundingBox.max, su.max), this.boundingBox.expandByPoint(ou)) : (this.boundingBox.expandByPoint(su.min), this.boundingBox.expandByPoint(su.max)) } } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) } computeBoundingSphere() { null === this.boundingSphere && (this.boundingSphere = new ec); const e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new Rl, 1 / 0); if (e) { const n = this.boundingSphere.center; if (su.setFromBufferAttribute(e), t) for (let e = 0, n = t.length; e < n; e++) { const n = t[e]; au.setFromBufferAttribute(n), this.morphTargetsRelative ? (ou.addVectors(su.min, au.min), su.expandByPoint(ou), ou.addVectors(su.max, au.max), su.expandByPoint(ou)) : (su.expandByPoint(au.min), su.expandByPoint(au.max)) } su.getCenter(n); let i = 0; for (let t = 0, r = e.count; t < r; t++)ou.fromBufferAttribute(e, t), i = Math.max(i, n.distanceToSquared(ou)); if (t) for (let r = 0, s = t.length; r < s; r++) { const s = t[r], a = this.morphTargetsRelative; for (let t = 0, r = s.count; t < r; t++)ou.fromBufferAttribute(s, t), a && (ru.fromBufferAttribute(e, t), ou.add(ru)), i = Math.max(i, n.distanceToSquared(ou)) } this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } } computeTangents() { const e = this.index, t = this.attributes; if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"); const n = e.array, i = t.position.array, r = t.normal.array, s = t.uv.array, a = i.length / 3; !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Kc(new Float32Array(4 * a), 4)); const o = this.getAttribute("tangent").array, l = [], c = []; for (let e = 0; e < a; e++)l[e] = new Rl, c[e] = new Rl; const u = new Rl, h = new Rl, d = new Rl, p = new ul, f = new ul, m = new ul, g = new Rl, v = new Rl; function y(e, t, n) { u.fromArray(i, 3 * e), h.fromArray(i, 3 * t), d.fromArray(i, 3 * n), p.fromArray(s, 2 * e), f.fromArray(s, 2 * t), m.fromArray(s, 2 * n), h.sub(u), d.sub(u), f.sub(p), m.sub(p); const r = 1 / (f.x * m.y - m.x * f.y); isFinite(r) && (g.copy(h).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(r), v.copy(d).multiplyScalar(f.x).addScaledVector(h, -m.x).multiplyScalar(r), l[e].add(g), l[t].add(g), l[n].add(g), c[e].add(v), c[t].add(v), c[n].add(v)) } let x = this.groups; 0 === x.length && (x = [{ start: 0, count: n.length }]); for (let e = 0, t = x.length; e < t; ++e) { const t = x[e], i = t.start; for (let e = i, r = i + t.count; e < r; e += 3)y(n[e + 0], n[e + 1], n[e + 2]) } const _ = new Rl, w = new Rl, b = new Rl, S = new Rl; function E(e) { b.fromArray(r, 3 * e), S.copy(b); const t = l[e]; _.copy(t), _.sub(b.multiplyScalar(b.dot(t))).normalize(), w.crossVectors(S, t); const n = w.dot(c[e]) < 0 ? -1 : 1; o[4 * e] = _.x, o[4 * e + 1] = _.y, o[4 * e + 2] = _.z, o[4 * e + 3] = n } for (let e = 0, t = x.length; e < t; ++e) { const t = x[e], i = t.start; for (let e = i, r = i + t.count; e < r; e += 3)E(n[e + 0]), E(n[e + 1]), E(n[e + 2]) } } computeVertexNormals() { const e = this.index, t = this.getAttribute("position"); if (void 0 !== t) { let n = this.getAttribute("normal"); if (void 0 === n) n = new Kc(new Float32Array(3 * t.count), 3), this.setAttribute("normal", n); else for (let e = 0, t = n.count; e < t; e++)n.setXYZ(e, 0, 0, 0); const i = new Rl, r = new Rl, s = new Rl, a = new Rl, o = new Rl, l = new Rl, c = new Rl, u = new Rl; if (e) for (let h = 0, d = e.count; h < d; h += 3) { const d = e.getX(h + 0), p = e.getX(h + 1), f = e.getX(h + 2); i.fromBufferAttribute(t, d), r.fromBufferAttribute(t, p), s.fromBufferAttribute(t, f), c.subVectors(s, r), u.subVectors(i, r), c.cross(u), a.fromBufferAttribute(n, d), o.fromBufferAttribute(n, p), l.fromBufferAttribute(n, f), a.add(c), o.add(c), l.add(c), n.setXYZ(d, a.x, a.y, a.z), n.setXYZ(p, o.x, o.y, o.z), n.setXYZ(f, l.x, l.y, l.z) } else for (let e = 0, a = t.count; e < a; e += 3)i.fromBufferAttribute(t, e + 0), r.fromBufferAttribute(t, e + 1), s.fromBufferAttribute(t, e + 2), c.subVectors(s, r), u.subVectors(i, r), c.cross(u), n.setXYZ(e + 0, c.x, c.y, c.z), n.setXYZ(e + 1, c.x, c.y, c.z), n.setXYZ(e + 2, c.x, c.y, c.z); this.normalizeNormals(), n.needsUpdate = !0 } } merge(e, t) { if (!e || !e.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e); void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.")); const n = this.attributes; for (const i in n) { if (void 0 === e.attributes[i]) continue; const r = n[i].array, s = e.attributes[i], a = s.array, o = s.itemSize * t, l = Math.min(a.length, r.length - o); for (let e = 0, t = o; e < l; e++, t++)r[t] = a[e] } return this } normalizeNormals() { const e = this.attributes.normal; for (let t = 0, n = e.count; t < n; t++)ou.fromBufferAttribute(e, t), ou.normalize(), e.setXYZ(t, ou.x, ou.y, ou.z) } toNonIndexed() { function e(e, t) { const n = e.array, i = e.itemSize, r = e.normalized, s = new n.constructor(t.length * i); let a = 0, o = 0; for (let r = 0, l = t.length; r < l; r++) { a = e.isInterleavedBufferAttribute ? t[r] * e.data.stride + e.offset : t[r] * i; for (let e = 0; e < i; e++)s[o++] = n[a++] } return new Kc(s, i, r) } if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this; const t = new lu, n = this.index.array, i = this.attributes; for (const r in i) { const s = e(i[r], n); t.setAttribute(r, s) } const r = this.morphAttributes; for (const i in r) { const s = [], a = r[i]; for (let t = 0, i = a.length; t < i; t++) { const i = e(a[t], n); s.push(i) } t.morphAttributes[i] = s } t.morphTargetsRelative = this.morphTargetsRelative; const s = this.groups; for (let e = 0, n = s.length; e < n; e++) { const n = s[e]; t.addGroup(n.start, n.count, n.materialIndex) } return t } toJSON() { const e = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) { const t = this.parameters; for (const n in t) void 0 !== t[n] && (e[n] = t[n]); return e } e.data = { attributes: {} }; const t = this.index; null !== t && (e.data.index = { type: t.array.constructor.name, array: Array.prototype.slice.call(t.array) }); const n = this.attributes; for (const t in n) { const i = n[t]; e.data.attributes[t] = i.toJSON(e.data) } const i = {}; let r = !1; for (const t in this.morphAttributes) { const n = this.morphAttributes[t], s = []; for (let t = 0, i = n.length; t < i; t++) { const i = n[t]; s.push(i.toJSON(e.data)) } s.length > 0 && (i[t] = s, r = !0) } r && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative); const s = this.groups; s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s))); const a = this.boundingSphere; return null !== a && (e.data.boundingSphere = { center: a.center.toArray(), radius: a.radius }), e } clone() { return (new this.constructor).copy(this) } copy(e) { this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null; const t = {}; this.name = e.name; const n = e.index; null !== n && this.setIndex(n.clone(t)); const i = e.attributes; for (const e in i) { const n = i[e]; this.setAttribute(e, n.clone(t)) } const r = e.morphAttributes; for (const e in r) { const n = [], i = r[e]; for (let e = 0, r = i.length; e < r; e++)n.push(i[e].clone(t)); this.morphAttributes[e] = n } this.morphTargetsRelative = e.morphTargetsRelative; const s = e.groups; for (let e = 0, t = s.length; e < t; e++) { const t = s[e]; this.addGroup(t.start, t.count, t.materialIndex) } const a = e.boundingBox; null !== a && (this.boundingBox = a.clone()); const o = e.boundingSphere; return null !== o && (this.boundingSphere = o.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, void 0 !== e.parameters && (this.parameters = Object.assign({}, e.parameters)), this } dispose() { this.dispatchEvent({ type: "dispose" }) } } lu.prototype.isBufferGeometry = !0; const cu = new cc, uu = new lc, hu = new ec, du = new Rl, pu = new Rl, fu = new Rl, mu = new Rl, gu = new Rl, vu = new Rl, yu = new Rl, xu = new Rl, _u = new Rl, wu = new ul, bu = new ul, Su = new ul, Eu = new Rl, Mu = new Rl; class Tu extends Ic { constructor(e = new lu, t = new Xc) { super(), this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e) { return super.copy(e), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this } updateMorphTargets() { const e = this.geometry; if (e.isBufferGeometry) { const t = e.morphAttributes, n = Object.keys(t); if (n.length > 0) { const e = t[n[0]]; if (void 0 !== e) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let t = 0, n = e.length; t < n; t++) { const n = e[t].name || String(t); this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t } } } } else { const t = e.morphTargets; void 0 !== t && t.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } } raycast(e, t) { const n = this.geometry, i = this.material, r = this.matrixWorld; if (void 0 === i) return; if (null === n.boundingSphere && n.computeBoundingSphere(), hu.copy(n.boundingSphere), hu.applyMatrix4(r), !1 === e.ray.intersectsSphere(hu)) return; if (cu.copy(r).invert(), uu.copy(e.ray).applyMatrix4(cu), null !== n.boundingBox && !1 === uu.intersectsBox(n.boundingBox)) return; let s; if (n.isBufferGeometry) { const r = n.index, a = n.attributes.position, o = n.morphAttributes.position, l = n.morphTargetsRelative, c = n.attributes.uv, u = n.attributes.uv2, h = n.groups, d = n.drawRange; if (null !== r) if (Array.isArray(i)) for (let n = 0, p = h.length; n < p; n++) { const p = h[n], f = i[p.materialIndex]; for (let n = Math.max(p.start, d.start), i = Math.min(r.count, Math.min(p.start + p.count, d.start + d.count)); n < i; n += 3) { const i = r.getX(n), h = r.getX(n + 1), d = r.getX(n + 2); s = Cu(this, f, e, uu, a, o, l, c, u, i, h, d), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = p.materialIndex, t.push(s)) } } else for (let n = Math.max(0, d.start), h = Math.min(r.count, d.start + d.count); n < h; n += 3) { const h = r.getX(n), d = r.getX(n + 1), p = r.getX(n + 2); s = Cu(this, i, e, uu, a, o, l, c, u, h, d, p), s && (s.faceIndex = Math.floor(n / 3), t.push(s)) } else if (void 0 !== a) if (Array.isArray(i)) for (let n = 0, r = h.length; n < r; n++) { const r = h[n], p = i[r.materialIndex]; for (let n = Math.max(r.start, d.start), i = Math.min(a.count, Math.min(r.start + r.count, d.start + d.count)); n < i; n += 3)s = Cu(this, p, e, uu, a, o, l, c, u, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = r.materialIndex, t.push(s)) } else for (let n = Math.max(0, d.start), r = Math.min(a.count, d.start + d.count); n < r; n += 3)s = Cu(this, i, e, uu, a, o, l, c, u, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), t.push(s)) } else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } } function Cu(e, t, n, i, r, s, a, o, l, c, u, h) { du.fromBufferAttribute(r, c), pu.fromBufferAttribute(r, u), fu.fromBufferAttribute(r, h); const d = e.morphTargetInfluences; if (s && d) { yu.set(0, 0, 0), xu.set(0, 0, 0), _u.set(0, 0, 0); for (let e = 0, t = s.length; e < t; e++) { const t = d[e], n = s[e]; 0 !== t && (mu.fromBufferAttribute(n, c), gu.fromBufferAttribute(n, u), vu.fromBufferAttribute(n, h), a ? (yu.addScaledVector(mu, t), xu.addScaledVector(gu, t), _u.addScaledVector(vu, t)) : (yu.addScaledVector(mu.sub(du), t), xu.addScaledVector(gu.sub(pu), t), _u.addScaledVector(vu.sub(fu), t))) } du.add(yu), pu.add(xu), fu.add(_u) } e.isSkinnedMesh && (e.boneTransform(c, du), e.boneTransform(u, pu), e.boneTransform(h, fu)); const p = function (e, t, n, i, r, s, a, o) { let l; if (l = 1 === t.side ? i.intersectTriangle(a, s, r, !0, o) : i.intersectTriangle(r, s, a, 2 !== t.side, o), null === l) return null; Mu.copy(o), Mu.applyMatrix4(e.matrixWorld); const c = n.ray.origin.distanceTo(Mu); return c < n.near || c > n.far ? null : { distance: c, point: Mu.clone(), object: e } }(e, t, n, i, du, pu, fu, Eu); if (p) { o && (wu.fromBufferAttribute(o, c), bu.fromBufferAttribute(o, u), Su.fromBufferAttribute(o, h), p.uv = Wc.getUV(Eu, du, pu, fu, wu, bu, Su, new ul)), l && (wu.fromBufferAttribute(l, c), bu.fromBufferAttribute(l, u), Su.fromBufferAttribute(l, h), p.uv2 = Wc.getUV(Eu, du, pu, fu, wu, bu, Su, new ul)); const e = { a: c, b: u, c: h, normal: new Rl, materialIndex: 0 }; Wc.getNormal(du, pu, fu, e.normal), p.face = e } return p } Tu.prototype.isMesh = !0; class Du extends lu { constructor(e = 1, t = 1, n = 1, i = 1, r = 1, s = 1) { super(), this.type = "BoxGeometry", this.parameters = { width: e, height: t, depth: n, widthSegments: i, heightSegments: r, depthSegments: s }; const a = this; i = Math.floor(i), r = Math.floor(r), s = Math.floor(s); const o = [], l = [], c = [], u = []; let h = 0, d = 0; function p(e, t, n, i, r, s, p, f, m, g, v) { const y = s / m, x = p / g, _ = s / 2, w = p / 2, b = f / 2, S = m + 1, E = g + 1; let M = 0, T = 0; const C = new Rl; for (let s = 0; s < E; s++) { const a = s * x - w; for (let o = 0; o < S; o++) { const h = o * y - _; C[e] = h * i, C[t] = a * r, C[n] = b, l.push(C.x, C.y, C.z), C[e] = 0, C[t] = 0, C[n] = f > 0 ? 1 : -1, c.push(C.x, C.y, C.z), u.push(o / m), u.push(1 - s / g), M += 1 } } for (let e = 0; e < g; e++)for (let t = 0; t < m; t++) { const n = h + t + S * e, i = h + t + S * (e + 1), r = h + (t + 1) + S * (e + 1), s = h + (t + 1) + S * e; o.push(n, i, s), o.push(i, r, s), T += 6 } a.addGroup(d, T, v), d += T, h += M } p("z", "y", "x", -1, -1, n, t, e, s, r, 0), p("z", "y", "x", 1, -1, n, t, -e, s, r, 1), p("x", "z", "y", 1, 1, e, n, t, i, s, 2), p("x", "z", "y", 1, -1, e, n, -t, i, s, 3), p("x", "y", "z", 1, -1, e, t, n, i, r, 4), p("x", "y", "z", -1, -1, e, t, -n, i, r, 5), this.setIndex(o), this.setAttribute("position", new eu(l, 3)), this.setAttribute("normal", new eu(c, 3)), this.setAttribute("uv", new eu(u, 2)) } static fromJSON(e) { return new Du(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments) } } function Lu(e) { const t = {}; for (const n in e) { t[n] = {}; for (const i in e[n]) { const r = e[n][i]; r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? t[n][i] = r.clone() : Array.isArray(r) ? t[n][i] = r.slice() : t[n][i] = r } } return t } function Au(e) { const t = {}; for (let n = 0; n < e.length; n++) { const i = Lu(e[n]); for (const e in i) t[e] = i[e] } return t } const Pu = { clone: Lu, merge: Au }; class Ru extends $c { constructor(e) { super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e)) } copy(e) { return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Lu(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this } toJSON(e) { const t = super.toJSON(e); t.glslVersion = this.glslVersion, t.uniforms = {}; for (const n in this.uniforms) { const i = this.uniforms[n].value; i && i.isTexture ? t.uniforms[n] = { type: "t", value: i.toJSON(e).uuid } : i && i.isColor ? t.uniforms[n] = { type: "c", value: i.getHex() } : i && i.isVector2 ? t.uniforms[n] = { type: "v2", value: i.toArray() } : i && i.isVector3 ? t.uniforms[n] = { type: "v3", value: i.toArray() } : i && i.isVector4 ? t.uniforms[n] = { type: "v4", value: i.toArray() } : i && i.isMatrix3 ? t.uniforms[n] = { type: "m3", value: i.toArray() } : i && i.isMatrix4 ? t.uniforms[n] = { type: "m4", value: i.toArray() } : t.uniforms[n] = { value: i } } Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader; const n = {}; for (const e in this.extensions) !0 === this.extensions[e] && (n[e] = !0); return Object.keys(n).length > 0 && (t.extensions = n), t } } Ru.prototype.isShaderMaterial = !0; class Ou extends Ic { constructor() { super(), this.type = "Camera", this.matrixWorldInverse = new cc, this.projectionMatrix = new cc, this.projectionMatrixInverse = new cc } copy(e, t) { return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this } getWorldDirection(e) { this.updateWorldMatrix(!0, !1); const t = this.matrixWorld.elements; return e.set(-t[8], -t[9], -t[10]).normalize() } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert() } updateWorldMatrix(e, t) { super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert() } clone() { return (new this.constructor).copy(this) } } Ou.prototype.isCamera = !0; class Iu extends Ou { constructor(e = 50, t = 1, n = .1, i = 2e3) { super(), this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this } setFocalLength(e) { const t = .5 * this.getFilmHeight() / e; this.fov = 2 * tl * Math.atan(t), this.updateProjectionMatrix() } getFocalLength() { const e = Math.tan(.5 * el * this.fov); return .5 * this.getFilmHeight() / e } getEffectiveFOV() { return 2 * tl * Math.atan(Math.tan(.5 * el * this.fov) / this.zoom) } getFilmWidth() { return this.filmGauge * Math.min(this.aspect, 1) } getFilmHeight() { return this.filmGauge / Math.max(this.aspect, 1) } setViewOffset(e, t, n, i, r, s) { this.aspect = e / t, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix() } clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = this.near; let t = e * Math.tan(.5 * el * this.fov) / this.zoom, n = 2 * t, i = this.aspect * n, r = -.5 * i; const s = this.view; if (null !== this.view && this.view.enabled) { const e = s.fullWidth, a = s.fullHeight; r += s.offsetX * i / e, t -= s.offsetY * n / a, i *= s.width / e, n *= s.height / a } const a = this.filmOffset; 0 !== a && (r += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const t = super.toJSON(e); return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t } } Iu.prototype.isPerspectiveCamera = !0; const Fu = 90; class zu extends Ic { constructor(e, t, n) { if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."); this.renderTarget = n; const i = new Iu(Fu, 1, e, t); i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new Rl(1, 0, 0)), this.add(i); const r = new Iu(Fu, 1, e, t); r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new Rl(-1, 0, 0)), this.add(r); const s = new Iu(Fu, 1, e, t); s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new Rl(0, 1, 0)), this.add(s); const a = new Iu(Fu, 1, e, t); a.layers = this.layers, a.up.set(0, 0, -1), a.lookAt(new Rl(0, -1, 0)), this.add(a); const o = new Iu(Fu, 1, e, t); o.layers = this.layers, o.up.set(0, -1, 0), o.lookAt(new Rl(0, 0, 1)), this.add(o); const l = new Iu(Fu, 1, e, t); l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new Rl(0, 0, -1)), this.add(l) } update(e, t) { null === this.parent && this.updateMatrixWorld(); const n = this.renderTarget, [i, r, s, a, o, l] = this.children, c = e.xr.enabled, u = e.getRenderTarget(); e.xr.enabled = !1; const h = n.texture.generateMipmaps; n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, i), e.setRenderTarget(n, 1), e.render(t, r), e.setRenderTarget(n, 2), e.render(t, s), e.setRenderTarget(n, 3), e.render(t, a), e.setRenderTarget(n, 4), e.render(t, o), n.texture.generateMipmaps = h, e.setRenderTarget(n, 5), e.render(t, l), e.setRenderTarget(u), e.xr.enabled = c, n.texture.needsPMREMUpdate = !0 } } class ku extends Tl { constructor(e, t, n, i, r, s, a, o, l, c) { super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : fo, n, i, r, s, a, o, l, c), this.flipY = !1 } get images() { return this.image } set images(e) { this.image = e } } ku.prototype.isCubeTexture = !0; class Nu extends Dl { constructor(e, t = {}) { super(e, e, t); const n = { width: e, height: e, depth: 1 }, i = [n, n, n, n, n, n]; this.texture = new ku(i, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : So } fromEquirectangularTexture(e, t) { this.texture.type = t.type, this.texture.format = Po, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter; const n = { tEquirect: { value: null } }, i = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t", r = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t", s = new Du(5, 5, 5), a = new Ru({ name: "CubemapFromEquirect", uniforms: Lu(n), vertexShader: i, fragmentShader: r, side: 1, blending: 0 }); a.uniforms.tEquirect.value = t; const o = new Tu(s, a), l = t.minFilter; return t.minFilter === Eo && (t.minFilter = So), new zu(1, 10, this).update(e, o), t.minFilter = l, o.geometry.dispose(), o.material.dispose(), this } clear(e, t, n, i) { const r = e.getRenderTarget(); for (let r = 0; r < 6; r++)e.setRenderTarget(this, r), e.clear(t, n, i); e.setRenderTarget(r) } } Nu.prototype.isWebGLCubeRenderTarget = !0; const Bu = new Rl, Hu = new Rl, Uu = new hl; class Vu { constructor(e = new Rl(1, 0, 0), t = 0) { this.normal = e, this.constant = t } set(e, t) { return this.normal.copy(e), this.constant = t, this } setComponents(e, t, n, i) { return this.normal.set(e, t, n), this.constant = i, this } setFromNormalAndCoplanarPoint(e, t) { return this.normal.copy(e), this.constant = -t.dot(this.normal), this } setFromCoplanarPoints(e, t, n) { const i = Bu.subVectors(n, t).cross(Hu.subVectors(e, t)).normalize(); return this.setFromNormalAndCoplanarPoint(i, e), this } copy(e) { return this.normal.copy(e.normal), this.constant = e.constant, this } normalize() { const e = 1 / this.normal.length(); return this.normal.multiplyScalar(e), this.constant *= e, this } negate() { return this.constant *= -1, this.normal.negate(), this } distanceToPoint(e) { return this.normal.dot(e) + this.constant } distanceToSphere(e) { return this.distanceToPoint(e.center) - e.radius } projectPoint(e, t) { return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e) } intersectLine(e, t) { const n = e.delta(Bu), i = this.normal.dot(n); if (0 === i) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null; const r = -(e.start.dot(this.normal) + this.constant) / i; return r < 0 || r > 1 ? null : t.copy(n).multiplyScalar(r).add(e.start) } intersectsLine(e) { const t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end); return t < 0 && n > 0 || n < 0 && t > 0 } intersectsBox(e) { return e.intersectsPlane(this) } intersectsSphere(e) { return e.intersectsPlane(this) } coplanarPoint(e) { return e.copy(this.normal).multiplyScalar(-this.constant) } applyMatrix4(e, t) { const n = t || Uu.getNormalMatrix(e), i = this.coplanarPoint(Bu).applyMatrix4(e), r = this.normal.applyMatrix3(n).normalize(); return this.constant = -i.dot(r), this } translate(e) { return this.constant -= e.dot(this.normal), this } equals(e) { return e.normal.equals(this.normal) && e.constant === this.constant } clone() { return (new this.constructor).copy(this) } } Vu.prototype.isPlane = !0; const Gu = new ec, ju = new Rl; class Wu { constructor(e = new Vu, t = new Vu, n = new Vu, i = new Vu, r = new Vu, s = new Vu) { this.planes = [e, t, n, i, r, s] } set(e, t, n, i, r, s) { const a = this.planes; return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(i), a[4].copy(r), a[5].copy(s), this } copy(e) { const t = this.planes; for (let n = 0; n < 6; n++)t[n].copy(e.planes[n]); return this } setFromProjectionMatrix(e) { const t = this.planes, n = e.elements, i = n[0], r = n[1], s = n[2], a = n[3], o = n[4], l = n[5], c = n[6], u = n[7], h = n[8], d = n[9], p = n[10], f = n[11], m = n[12], g = n[13], v = n[14], y = n[15]; return t[0].setComponents(a - i, u - o, f - h, y - m).normalize(), t[1].setComponents(a + i, u + o, f + h, y + m).normalize(), t[2].setComponents(a + r, u + l, f + d, y + g).normalize(), t[3].setComponents(a - r, u - l, f - d, y - g).normalize(), t[4].setComponents(a - s, u - c, f - p, y - v).normalize(), t[5].setComponents(a + s, u + c, f + p, y + v).normalize(), this } intersectsObject(e) { const t = e.geometry; return null === t.boundingSphere && t.computeBoundingSphere(), Gu.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(Gu) } intersectsSprite(e) { return Gu.center.set(0, 0, 0), Gu.radius = .7071067811865476, Gu.applyMatrix4(e.matrixWorld), this.intersectsSphere(Gu) } intersectsSphere(e) { const t = this.planes, n = e.center, i = -e.radius; for (let e = 0; e < 6; e++)if (t[e].distanceToPoint(n) < i) return !1; return !0 } intersectsBox(e) { const t = this.planes; for (let n = 0; n < 6; n++) { const i = t[n]; if (ju.x = i.normal.x > 0 ? e.max.x : e.min.x, ju.y = i.normal.y > 0 ? e.max.y : e.min.y, ju.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(ju) < 0) return !1 } return !0 } containsPoint(e) { const t = this.planes; for (let n = 0; n < 6; n++)if (t[n].distanceToPoint(e) < 0) return !1; return !0 } clone() { return (new this.constructor).copy(this) } } function qu() { let e = null, t = !1, n = null, i = null; function r(t, s) { n(t, s), i = e.requestAnimationFrame(r) } return { start: function () { !0 !== t && null !== n && (i = e.requestAnimationFrame(r), t = !0) }, stop: function () { e.cancelAnimationFrame(i), t = !1 }, setAnimationLoop: function (e) { n = e }, setContext: function (t) { e = t } } } function $u(e, t) { const n = t.isWebGL2, i = new WeakMap; return { get: function (e) { return e.isInterleavedBufferAttribute && (e = e.data), i.get(e) }, remove: function (t) { t.isInterleavedBufferAttribute && (t = t.data); const n = i.get(t); n && (e.deleteBuffer(n.buffer), i.delete(t)) }, update: function (t, r) { if (t.isGLBufferAttribute) { const e = i.get(t); return void ((!e || e.version < t.version) && i.set(t, { buffer: t.buffer, type: t.type, bytesPerElement: t.elementSize, version: t.version })) } t.isInterleavedBufferAttribute && (t = t.data); const s = i.get(t); void 0 === s ? i.set(t, function (t, i) { const r = t.array, s = t.usage, a = e.createBuffer(); let o; if (e.bindBuffer(i, a), e.bufferData(i, r, s), t.onUploadCallback(), r instanceof Float32Array) o = 5126; else if (r instanceof Uint16Array) if (t.isFloat16BufferAttribute) { if (!n) throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."); o = 5131 } else o = 5123; else if (r instanceof Int16Array) o = 5122; else if (r instanceof Uint32Array) o = 5125; else if (r instanceof Int32Array) o = 5124; else if (r instanceof Int8Array) o = 5120; else if (r instanceof Uint8Array) o = 5121; else { if (!(r instanceof Uint8ClampedArray)) throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + r); o = 5121 } return { buffer: a, type: o, bytesPerElement: r.BYTES_PER_ELEMENT, version: t.version } }(t, r)) : s.version < t.version && (function (t, i, r) { const s = i.array, a = i.updateRange; e.bindBuffer(r, t), -1 === a.count ? e.bufferSubData(r, 0, s) : (n ? e.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s, a.offset, a.count) : e.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s.subarray(a.offset, a.offset + a.count)), a.count = -1) }(s.buffer, t, r), s.version = t.version) } } } class Xu extends lu { constructor(e = 1, t = 1, n = 1, i = 1) { super(), this.type = "PlaneGeometry", this.parameters = { width: e, height: t, widthSegments: n, heightSegments: i }; const r = e / 2, s = t / 2, a = Math.floor(n), o = Math.floor(i), l = a + 1, c = o + 1, u = e / a, h = t / o, d = [], p = [], f = [], m = []; for (let e = 0; e < c; e++) { const t = e * h - s; for (let n = 0; n < l; n++) { const i = n * u - r; p.push(i, -t, 0), f.push(0, 0, 1), m.push(n / a), m.push(1 - e / o) } } for (let e = 0; e < o; e++)for (let t = 0; t < a; t++) { const n = t + l * e, i = t + l * (e + 1), r = t + 1 + l * (e + 1), s = t + 1 + l * e; d.push(n, i, s), d.push(i, r, s) } this.setIndex(d), this.setAttribute("position", new eu(p, 3)), this.setAttribute("normal", new eu(f, 3)), this.setAttribute("uv", new eu(m, 2)) } static fromJSON(e) { return new Xu(e.width, e.height, e.widthSegments, e.heightSegments) } } const Yu = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif", alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif", map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ]\n\t\t#endif\n\t}\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tfloat texelIndex = float( vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif", normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif", normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif", normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif", clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif", output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmission_fragment: "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif", transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}", meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}" }, Zu = { common: { diffuse: { value: new _l(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new hl }, uv2Transform: { value: new hl }, alphaMap: { value: null }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: .98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new ul(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new _l(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new _l(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new hl } }, sprite: { diffuse: { value: new _l(16777215) }, opacity: { value: 1 }, center: { value: new ul(.5, .5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new hl } } }, Ku = { basic: { uniforms: Au([Zu.common, Zu.specularmap, Zu.envmap, Zu.aomap, Zu.lightmap, Zu.fog]), vertexShader: Yu.meshbasic_vert, fragmentShader: Yu.meshbasic_frag }, lambert: { uniforms: Au([Zu.common, Zu.specularmap, Zu.envmap, Zu.aomap, Zu.lightmap, Zu.emissivemap, Zu.fog, Zu.lights, { emissive: { value: new _l(0) } }]), vertexShader: Yu.meshlambert_vert, fragmentShader: Yu.meshlambert_frag }, phong: { uniforms: Au([Zu.common, Zu.specularmap, Zu.envmap, Zu.aomap, Zu.lightmap, Zu.emissivemap, Zu.bumpmap, Zu.normalmap, Zu.displacementmap, Zu.fog, Zu.lights, { emissive: { value: new _l(0) }, specular: { value: new _l(1118481) }, shininess: { value: 30 } }]), vertexShader: Yu.meshphong_vert, fragmentShader: Yu.meshphong_frag }, standard: { uniforms: Au([Zu.common, Zu.envmap, Zu.aomap, Zu.lightmap, Zu.emissivemap, Zu.bumpmap, Zu.normalmap, Zu.displacementmap, Zu.roughnessmap, Zu.metalnessmap, Zu.fog, Zu.lights, { emissive: { value: new _l(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: Yu.meshphysical_vert, fragmentShader: Yu.meshphysical_frag }, toon: { uniforms: Au([Zu.common, Zu.aomap, Zu.lightmap, Zu.emissivemap, Zu.bumpmap, Zu.normalmap, Zu.displacementmap, Zu.gradientmap, Zu.fog, Zu.lights, { emissive: { value: new _l(0) } }]), vertexShader: Yu.meshtoon_vert, fragmentShader: Yu.meshtoon_frag }, matcap: { uniforms: Au([Zu.common, Zu.bumpmap, Zu.normalmap, Zu.displacementmap, Zu.fog, { matcap: { value: null } }]), vertexShader: Yu.meshmatcap_vert, fragmentShader: Yu.meshmatcap_frag }, points: { uniforms: Au([Zu.points, Zu.fog]), vertexShader: Yu.points_vert, fragmentShader: Yu.points_frag }, dashed: { uniforms: Au([Zu.common, Zu.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: Yu.linedashed_vert, fragmentShader: Yu.linedashed_frag }, depth: { uniforms: Au([Zu.common, Zu.displacementmap]), vertexShader: Yu.depth_vert, fragmentShader: Yu.depth_frag }, normal: { uniforms: Au([Zu.common, Zu.bumpmap, Zu.normalmap, Zu.displacementmap, { opacity: { value: 1 } }]), vertexShader: Yu.meshnormal_vert, fragmentShader: Yu.meshnormal_frag }, sprite: { uniforms: Au([Zu.sprite, Zu.fog]), vertexShader: Yu.sprite_vert, fragmentShader: Yu.sprite_frag }, background: { uniforms: { uvTransform: { value: new hl }, t2D: { value: null } }, vertexShader: Yu.background_vert, fragmentShader: Yu.background_frag }, cube: { uniforms: Au([Zu.envmap, { opacity: { value: 1 } }]), vertexShader: Yu.cube_vert, fragmentShader: Yu.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: Yu.equirect_vert, fragmentShader: Yu.equirect_frag }, distanceRGBA: { uniforms: Au([Zu.common, Zu.displacementmap, { referencePosition: { value: new Rl }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: Yu.distanceRGBA_vert, fragmentShader: Yu.distanceRGBA_frag }, shadow: { uniforms: Au([Zu.lights, Zu.fog, { color: { value: new _l(0) }, opacity: { value: 1 } }]), vertexShader: Yu.shadow_vert, fragmentShader: Yu.shadow_frag } }; function Ju(e, t, n, i, r, s) { const a = new _l(0); let o, l, c = !0 === r ? 0 : 1, u = null, h = 0, d = null; function p(e, t) { n.buffers.color.setClear(e.r, e.g, e.b, t, s) } return { getClearColor: function () { return a }, setClearColor: function (e, t = 1) { a.set(e), c = t, p(a, c) }, getClearAlpha: function () { return c }, setClearAlpha: function (e) { c = e, p(a, c) }, render: function (n, r) { let s = !1, f = !0 === r.isScene ? r.background : null; f && f.isTexture && (f = t.get(f)); const m = e.xr, g = m.getSession && m.getSession(); g && "additive" === g.environmentBlendMode && (f = null), null === f ? p(a, c) : f && f.isColor && (p(f, 1), s = !0), (e.autoClear || s) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), f && (f.isCubeTexture || f.mapping === go) ? (void 0 === l && (l = new Tu(new Du(1, 1, 1), new Ru({ name: "BackgroundCubeMaterial", uniforms: Lu(Ku.cube.uniforms), vertexShader: Ku.cube.vertexShader, fragmentShader: Ku.cube.fragmentShader, side: 1, depthTest: !1, depthWrite: !1, fog: !1 })), l.geometry.deleteAttribute("normal"), l.geometry.deleteAttribute("uv"), l.onBeforeRender = function (e, t, n) { this.matrixWorld.copyPosition(n.matrixWorld) }, Object.defineProperty(l.material, "envMap", { get: function () { return this.uniforms.envMap.value } }), i.update(l)), l.material.uniforms.envMap.value = f, l.material.uniforms.flipEnvMap.value = f.isCubeTexture && !1 === f.isRenderTargetTexture ? -1 : 1, u === f && h === f.version && d === e.toneMapping || (l.material.needsUpdate = !0, u = f, h = f.version, d = e.toneMapping), n.unshift(l, l.geometry, l.material, 0, 0, null)) : f && f.isTexture && (void 0 === o && (o = new Tu(new Xu(2, 2), new Ru({ name: "BackgroundMaterial", uniforms: Lu(Ku.background.uniforms), vertexShader: Ku.background.vertexShader, fragmentShader: Ku.background.fragmentShader, side: 0, depthTest: !1, depthWrite: !1, fog: !1 })), o.geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", { get: function () { return this.uniforms.t2D.value } }), i.update(o)), o.material.uniforms.t2D.value = f, !0 === f.matrixAutoUpdate && f.updateMatrix(), o.material.uniforms.uvTransform.value.copy(f.matrix), u === f && h === f.version && d === e.toneMapping || (o.material.needsUpdate = !0, u = f, h = f.version, d = e.toneMapping), n.unshift(o, o.geometry, o.material, 0, 0, null)) } } } function Qu(e, t, n, i) { const r = e.getParameter(34921), s = i.isWebGL2 ? null : t.get("OES_vertex_array_object"), a = i.isWebGL2 || null !== s, o = {}, l = d(null); let c = l; function u(t) { return i.isWebGL2 ? e.bindVertexArray(t) : s.bindVertexArrayOES(t) } function h(t) { return i.isWebGL2 ? e.deleteVertexArray(t) : s.deleteVertexArrayOES(t) } function d(e) { const t = [], n = [], i = []; for (let e = 0; e < r; e++)t[e] = 0, n[e] = 0, i[e] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: t, enabledAttributes: n, attributeDivisors: i, object: e, attributes: {}, index: null } } function p() { const e = c.newAttributes; for (let t = 0, n = e.length; t < n; t++)e[t] = 0 } function f(e) { m(e, 0) } function m(n, r) { const s = c.newAttributes, a = c.enabledAttributes, o = c.attributeDivisors; s[n] = 1, 0 === a[n] && (e.enableVertexAttribArray(n), a[n] = 1), o[n] !== r && ((i.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), o[n] = r) } function g() { const t = c.newAttributes, n = c.enabledAttributes; for (let i = 0, r = n.length; i < r; i++)n[i] !== t[i] && (e.disableVertexAttribArray(i), n[i] = 0) } function v(t, n, r, s, a, o) { !0 !== i.isWebGL2 || 5124 !== r && 5125 !== r ? e.vertexAttribPointer(t, n, r, s, a, o) : e.vertexAttribIPointer(t, n, r, a, o) } function y() { x(), c !== l && (c = l, u(c.object)) } function x() { l.geometry = null, l.program = null, l.wireframe = !1 } return { setup: function (r, l, h, y, x) { let _ = !1; if (a) { const t = function (t, n, r) { const a = !0 === r.wireframe; let l = o[t.id]; void 0 === l && (l = {}, o[t.id] = l); let c = l[n.id]; void 0 === c && (c = {}, l[n.id] = c); let u = c[a]; return void 0 === u && (u = d(i.isWebGL2 ? e.createVertexArray() : s.createVertexArrayOES()), c[a] = u), u }(y, h, l); c !== t && (c = t, u(c.object)), _ = function (e, t) { const n = c.attributes, i = e.attributes; let r = 0; for (const e in i) { const t = n[e], s = i[e]; if (void 0 === t) return !0; if (t.attribute !== s) return !0; if (t.data !== s.data) return !0; r++ } return c.attributesNum !== r || c.index !== t }(y, x), _ && function (e, t) { const n = {}, i = e.attributes; let r = 0; for (const e in i) { const t = i[e], s = {}; s.attribute = t, t.data && (s.data = t.data), n[e] = s, r++ } c.attributes = n, c.attributesNum = r, c.index = t }(y, x) } else { const e = !0 === l.wireframe; c.geometry === y.id && c.program === h.id && c.wireframe === e || (c.geometry = y.id, c.program = h.id, c.wireframe = e, _ = !0) } !0 === r.isInstancedMesh && (_ = !0), null !== x && n.update(x, 34963), _ && (function (r, s, a, o) { if (!1 === i.isWebGL2 && (r.isInstancedMesh || o.isInstancedBufferGeometry) && null === t.get("ANGLE_instanced_arrays")) return; p(); const l = o.attributes, c = a.getAttributes(), u = s.defaultAttributeValues; for (const t in c) { const i = c[t]; if (i.location >= 0) { let s = l[t]; if (void 0 === s && ("instanceMatrix" === t && r.instanceMatrix && (s = r.instanceMatrix), "instanceColor" === t && r.instanceColor && (s = r.instanceColor)), void 0 !== s) { const t = s.normalized, a = s.itemSize, l = n.get(s); if (void 0 === l) continue; const c = l.buffer, u = l.type, h = l.bytesPerElement; if (s.isInterleavedBufferAttribute) { const n = s.data, l = n.stride, d = s.offset; if (n.isInstancedInterleavedBuffer) { for (let e = 0; e < i.locationSize; e++)m(i.location + e, n.meshPerAttribute); !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = n.meshPerAttribute * n.count) } else for (let e = 0; e < i.locationSize; e++)f(i.location + e); e.bindBuffer(34962, c); for (let e = 0; e < i.locationSize; e++)v(i.location + e, a / i.locationSize, u, t, l * h, (d + a / i.locationSize * e) * h) } else { if (s.isInstancedBufferAttribute) { for (let e = 0; e < i.locationSize; e++)m(i.location + e, s.meshPerAttribute); !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = s.meshPerAttribute * s.count) } else for (let e = 0; e < i.locationSize; e++)f(i.location + e); e.bindBuffer(34962, c); for (let e = 0; e < i.locationSize; e++)v(i.location + e, a / i.locationSize, u, t, a * h, a / i.locationSize * e * h) } } else if (void 0 !== u) { const n = u[t]; if (void 0 !== n) switch (n.length) { case 2: e.vertexAttrib2fv(i.location, n); break; case 3: e.vertexAttrib3fv(i.location, n); break; case 4: e.vertexAttrib4fv(i.location, n); break; default: e.vertexAttrib1fv(i.location, n) } } } } g() }(r, l, h, y), null !== x && e.bindBuffer(34963, n.get(x).buffer)) }, reset: y, resetDefaultState: x, dispose: function () { y(); for (const e in o) { const t = o[e]; for (const e in t) { const n = t[e]; for (const e in n) h(n[e].object), delete n[e]; delete t[e] } delete o[e] } }, releaseStatesOfGeometry: function (e) { if (void 0 === o[e.id]) return; const t = o[e.id]; for (const e in t) { const n = t[e]; for (const e in n) h(n[e].object), delete n[e]; delete t[e] } delete o[e.id] }, releaseStatesOfProgram: function (e) { for (const t in o) { const n = o[t]; if (void 0 === n[e.id]) continue; const i = n[e.id]; for (const e in i) h(i[e].object), delete i[e]; delete n[e.id] } }, initAttributes: p, enableAttribute: f, disableUnusedAttributes: g } } function eh(e, t, n, i) { const r = i.isWebGL2; let s; this.setMode = function (e) { s = e }, this.render = function (t, i) { e.drawArrays(s, t, i), n.update(i, s, 1) }, this.renderInstances = function (i, a, o) { if (0 === o) return; let l, c; if (r) l = e, c = "drawArraysInstanced"; else if (l = t.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); l[c](s, i, a, o), n.update(a, s, o) } } function th(e, t, n) { let i; function r(t) { if ("highp" === t) { if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp"; t = "mediump" } return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp" } const s = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext; let a = void 0 !== n.precision ? n.precision : "highp"; const o = r(a); o !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."), a = o); const l = s || t.has("WEBGL_draw_buffers"), c = !0 === n.logarithmicDepthBuffer, u = e.getParameter(34930), h = e.getParameter(35660), d = e.getParameter(3379), p = e.getParameter(34076), f = e.getParameter(34921), m = e.getParameter(36347), g = e.getParameter(36348), v = e.getParameter(36349), y = h > 0, x = s || t.has("OES_texture_float"); return { isWebGL2: s, drawBuffers: l, getMaxAnisotropy: function () { if (void 0 !== i) return i; if (!0 === t.has("EXT_texture_filter_anisotropic")) { const n = t.get("EXT_texture_filter_anisotropic"); i = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) } else i = 0; return i }, getMaxPrecision: r, precision: a, logarithmicDepthBuffer: c, maxTextures: u, maxVertexTextures: h, maxTextureSize: d, maxCubemapSize: p, maxAttributes: f, maxVertexUniforms: m, maxVaryings: g, maxFragmentUniforms: v, vertexTextures: y, floatFragmentTextures: x, floatVertexTextures: y && x, maxSamples: s ? e.getParameter(36183) : 0 } } function nh(e) { const t = this; let n = null, i = 0, r = !1, s = !1; const a = new Vu, o = new hl, l = { value: null, needsUpdate: !1 }; function c() { l.value !== n && (l.value = n, l.needsUpdate = i > 0), t.numPlanes = i, t.numIntersection = 0 } function u(e, n, i, r) { const s = null !== e ? e.length : 0; let c = null; if (0 !== s) { if (c = l.value, !0 !== r || null === c) { const t = i + 4 * s, r = n.matrixWorldInverse; o.getNormalMatrix(r), (null === c || c.length < t) && (c = new Float32Array(t)); for (let t = 0, n = i; t !== s; ++t, n += 4)a.copy(e[t]).applyMatrix4(r, o), a.normal.toArray(c, n), c[n + 3] = a.constant } l.value = c, l.needsUpdate = !0 } return t.numPlanes = s, t.numIntersection = 0, c } this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (e, t, s) { const a = 0 !== e.length || t || 0 !== i || r; return r = t, n = u(e, s, 0), i = e.length, a }, this.beginShadows = function () { s = !0, u(null) }, this.endShadows = function () { s = !1, c() }, this.setState = function (t, a, o) { const h = t.clippingPlanes, d = t.clipIntersection, p = t.clipShadows, f = e.get(t); if (!r || null === h || 0 === h.length || s && !p) s ? u(null) : c(); else { const e = s ? 0 : i, t = 4 * e; let r = f.clippingState || null; l.value = r, r = u(h, a, t, o); for (let e = 0; e !== t; ++e)r[e] = n[e]; f.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += e } } } function ih(e) { let t = new WeakMap; function n(e, t) { return 303 === t ? e.mapping = fo : 304 === t && (e.mapping = mo), e } function i(e) { const n = e.target; n.removeEventListener("dispose", i); const r = t.get(n); void 0 !== r && (t.delete(n), r.dispose()) } return { get: function (r) { if (r && r.isTexture && !1 === r.isRenderTargetTexture) { const s = r.mapping; if (303 === s || 304 === s) { if (t.has(r)) return n(t.get(r).texture, r.mapping); { const s = r.image; if (s && s.height > 0) { const a = new Nu(s.height / 2); return a.fromEquirectangularTexture(e, r), t.set(r, a), r.addEventListener("dispose", i), n(a.texture, r.mapping) } return null } } } return r }, dispose: function () { t = new WeakMap } } } Ku.physical = { uniforms: Au([Ku.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new ul(1, 1) }, clearcoatNormalMap: { value: null }, sheen: { value: 0 }, sheenColor: { value: new _l(0) }, sheenColorMap: { value: null }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new ul }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationColor: { value: new _l(0) }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularColor: { value: new _l(1, 1, 1) }, specularColorMap: { value: null } }]), vertexShader: Yu.meshphysical_vert, fragmentShader: Yu.meshphysical_frag }; class rh extends Ou { constructor(e = -1, t = 1, n = 1, i = -1, r = .1, s = 2e3) { super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = r, this.far = s, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this } setViewOffset(e, t, n, i, r, s) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix() } clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2; let r = n - e, s = n + e, a = i + t, o = i - t; if (null !== this.view && this.view.enabled) { const e = (this.right - this.left) / this.view.fullWidth / this.zoom, t = (this.top - this.bottom) / this.view.fullHeight / this.zoom; r += e * this.view.offsetX, s = r + e * this.view.width, a -= t * this.view.offsetY, o = a - t * this.view.height } this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const t = super.toJSON(e); return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t } } rh.prototype.isOrthographicCamera = !0; const sh = [.125, .215, .35, .446, .526, .582], ah = new rh, oh = new _l; let lh = null; const ch = (1 + Math.sqrt(5)) / 2, uh = 1 / ch, hh = [new Rl(1, 1, 1), new Rl(-1, 1, 1), new Rl(1, 1, -1), new Rl(-1, 1, -1), new Rl(0, ch, uh), new Rl(0, ch, -uh), new Rl(uh, 0, ch), new Rl(-uh, 0, ch), new Rl(ch, uh, 0), new Rl(-ch, uh, 0)]; class dh { constructor(e) { this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial) } fromScene(e, t = 0, n = .1, i = 100) { lh = this._renderer.getRenderTarget(), this._setSize(256); const r = this._allocateTargets(); return r.depthBuffer = !0, this._sceneToCubeUV(e, n, i, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r } fromEquirectangular(e, t = null) { return this._fromTexture(e, t) } fromCubemap(e, t = null) { return this._fromTexture(e, t) } compileCubemapShader() { null === this._cubemapMaterial && (this._cubemapMaterial = gh(), this._compileMaterial(this._cubemapMaterial)) } compileEquirectangularShader() { null === this._equirectMaterial && (this._equirectMaterial = mh(), this._compileMaterial(this._equirectMaterial)) } dispose() { this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose() } _setSize(e) { this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax) } _dispose() { this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose(); for (let e = 0; e < this._lodPlanes.length; e++)this._lodPlanes[e].dispose() } _cleanup(e) { this._renderer.setRenderTarget(lh), e.scissorTest = !1, fh(e, 0, 0, e.width, e.height) } _fromTexture(e, t) { e.mapping === fo || e.mapping === mo ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), lh = this._renderer.getRenderTarget(); const n = t || this._allocateTargets(); return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n } _allocateTargets() { const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize - 32, n = { magFilter: So, minFilter: So, generateMipmaps: !1, type: Lo, format: Po, encoding: jo, depthBuffer: !1 }, i = ph(e, t, n); if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e) { null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = ph(e, t, n); const { _lodMax: i } = this; ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = function (e) { const t = [], n = [], i = []; let r = e; const s = e - 4 + 1 + sh.length; for (let a = 0; a < s; a++) { const s = Math.pow(2, r); n.push(s); let o = 1 / s; a > e - 4 ? o = sh[a - e + 4 - 1] : 0 === a && (o = 0), i.push(o); const l = 1 / (s - 1), c = -l / 2, u = 1 + l / 2, h = [c, c, u, c, u, u, c, c, u, u, c, u], d = 6, p = 6, f = 3, m = 2, g = 1, v = new Float32Array(f * p * d), y = new Float32Array(m * p * d), x = new Float32Array(g * p * d); for (let e = 0; e < d; e++) { const t = e % 3 * 2 / 3 - 1, n = e > 2 ? 0 : -1, i = [t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0]; v.set(i, f * p * e), y.set(h, m * p * e); const r = [e, e, e, e, e, e]; x.set(r, g * p * e) } const _ = new lu; _.setAttribute("position", new Kc(v, f)), _.setAttribute("uv", new Kc(y, m)), _.setAttribute("faceIndex", new Kc(x, g)), t.push(_), r > 4 && r-- } return { lodPlanes: t, sizeLods: n, sigmas: i } }(i)), this._blurMaterial = function (e, t, n) { const i = new Float32Array(20), r = new Rl(0, 1, 0); return new Ru({ name: "SphericalGaussianBlur", defines: { n: 20, CUBEUV_TEXEL_WIDTH: 1 / t, CUBEUV_TEXEL_HEIGHT: 1 / n, CUBEUV_MAX_MIP: `${e}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: i }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: r } }, vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t", fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t", blending: 0, depthTest: !1, depthWrite: !1 }) }(i, e, t) } return i } _compileMaterial(e) { const t = new Tu(this._lodPlanes[0], e); this._renderer.compile(t, ah) } _sceneToCubeUV(e, t, n, i) { const r = new Iu(90, 1, t, n), s = [1, -1, 1, 1, 1, 1], a = [1, 1, 1, -1, -1, -1], o = this._renderer, l = o.autoClear, c = o.toneMapping; o.getClearColor(oh), o.toneMapping = 0, o.autoClear = !1; const u = new Xc({ name: "PMREM.Background", side: 1, depthWrite: !1, depthTest: !1 }), h = new Tu(new Du, u); let d = !1; const p = e.background; p ? p.isColor && (u.color.copy(p), e.background = null, d = !0) : (u.color.copy(oh), d = !0); for (let t = 0; t < 6; t++) { const n = t % 3; 0 === n ? (r.up.set(0, s[t], 0), r.lookAt(a[t], 0, 0)) : 1 === n ? (r.up.set(0, 0, s[t]), r.lookAt(0, a[t], 0)) : (r.up.set(0, s[t], 0), r.lookAt(0, 0, a[t])); const l = this._cubeSize; fh(i, n * l, t > 2 ? l : 0, l, l), o.setRenderTarget(i), d && o.render(h, r), o.render(e, r) } h.geometry.dispose(), h.material.dispose(), o.toneMapping = c, o.autoClear = l, e.background = p } _textureToCubeUV(e, t) { const n = this._renderer, i = e.mapping === fo || e.mapping === mo; i ? (null === this._cubemapMaterial && (this._cubemapMaterial = gh()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = mh()); const r = i ? this._cubemapMaterial : this._equirectMaterial, s = new Tu(this._lodPlanes[0], r); r.uniforms.envMap.value = e; const a = this._cubeSize; fh(t, 0, 0, 3 * a, 2 * a), n.setRenderTarget(t), n.render(s, ah) } _applyPMREM(e) { const t = this._renderer, n = t.autoClear; t.autoClear = !1; for (let t = 1; t < this._lodPlanes.length; t++) { const n = Math.sqrt(this._sigmas[t] * this._sigmas[t] - this._sigmas[t - 1] * this._sigmas[t - 1]), i = hh[(t - 1) % hh.length]; this._blur(e, t - 1, t, n, i) } t.autoClear = n } _blur(e, t, n, i, r) { const s = this._pingPongRenderTarget; this._halfBlur(e, s, t, n, i, "latitudinal", r), this._halfBlur(s, e, n, n, i, "longitudinal", r) } _halfBlur(e, t, n, i, r, s, a) { const o = this._renderer, l = this._blurMaterial; "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!"); const c = new Tu(this._lodPlanes[i], l), u = l.uniforms, h = this._sizeLods[n] - 1, d = isFinite(r) ? Math.PI / (2 * h) : 2 * Math.PI / 39, p = r / d, f = isFinite(r) ? 1 + Math.floor(3 * p) : 20; f > 20 && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`); const m = []; let g = 0; for (let e = 0; e < 20; ++e) { const t = e / p, n = Math.exp(-t * t / 2); m.push(n), 0 === e ? g += n : e < f && (g += 2 * n) } for (let e = 0; e < m.length; e++)m[e] = m[e] / g; u.envMap.value = e.texture, u.samples.value = f, u.weights.value = m, u.latitudinal.value = "latitudinal" === s, a && (u.poleAxis.value = a); const { _lodMax: v } = this; u.dTheta.value = d, u.mipInt.value = v - n; const y = this._sizeLods[i]; fh(t, 3 * y * (i > v - 4 ? i - v + 4 : 0), 4 * (this._cubeSize - y), 3 * y, 2 * y), o.setRenderTarget(t), o.render(c, ah) } } function ph(e, t, n) { const i = new Dl(e, t, n); return i.texture.mapping = go, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i } function fh(e, t, n, i, r) { e.viewport.set(t, n, i, r), e.scissor.set(t, n, i, r) } function mh() { return new Ru({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t", fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t", blending: 0, depthTest: !1, depthWrite: !1 }) } function gh() { return new Ru({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t", fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t", blending: 0, depthTest: !1, depthWrite: !1 }) } function vh(e) { let t = new WeakMap, n = null; function i(e) { const n = e.target; n.removeEventListener("dispose", i); const r = t.get(n); void 0 !== r && (t.delete(n), r.dispose()) } return { get: function (r) { if (r && r.isTexture) { const s = r.mapping, a = 303 === s || 304 === s, o = s === fo || s === mo; if (a || o) { if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) { r.needsPMREMUpdate = !1; let i = t.get(r); return null === n && (n = new dh(e)), i = a ? n.fromEquirectangular(r, i) : n.fromCubemap(r, i), t.set(r, i), i.texture } if (t.has(r)) return t.get(r).texture; { const s = r.image; if (a && s && s.height > 0 || o && s && function (e) { let t = 0; for (let n = 0; n < 6; n++)void 0 !== e[n] && t++; return 6 === t }(s)) { null === n && (n = new dh(e)); const s = a ? n.fromEquirectangular(r) : n.fromCubemap(r); return t.set(r, s), r.addEventListener("dispose", i), s.texture } return null } } } return r }, dispose: function () { t = new WeakMap, null !== n && (n.dispose(), n = null) } } } function yh(e) { const t = {}; function n(n) { if (void 0 !== t[n]) return t[n]; let i; switch (n) { case "WEBGL_depth_texture": i = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": i = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": i = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": i = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: i = e.getExtension(n) }return t[n] = i, i } return { has: function (e) { return null !== n(e) }, init: function (e) { e.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture") }, get: function (e) { const t = n(e); return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."), t } } } function xh(e, t, n, i) { const r = {}, s = new WeakMap; function a(e) { const o = e.target; null !== o.index && t.remove(o.index); for (const e in o.attributes) t.remove(o.attributes[e]); o.removeEventListener("dispose", a), delete r[o.id]; const l = s.get(o); l && (t.remove(l), s.delete(o)), i.releaseStatesOfGeometry(o), !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount, n.memory.geometries-- } function o(e) { const n = [], i = e.index, r = e.attributes.position; let a = 0; if (null !== i) { const e = i.array; a = i.version; for (let t = 0, i = e.length; t < i; t += 3) { const i = e[t + 0], r = e[t + 1], s = e[t + 2]; n.push(i, r, r, s, s, i) } } else { const e = r.array; a = r.version; for (let t = 0, i = e.length / 3 - 1; t < i; t += 3) { const e = t + 0, i = t + 1, r = t + 2; n.push(e, i, i, r, r, e) } } const o = new (dl(n) ? Qc : Jc)(n, 1); o.version = a; const l = s.get(e); l && t.remove(l), s.set(e, o) } return { get: function (e, t) { return !0 === r[t.id] || (t.addEventListener("dispose", a), r[t.id] = !0, n.memory.geometries++), t }, update: function (e) { const n = e.attributes; for (const e in n) t.update(n[e], 34962); const i = e.morphAttributes; for (const e in i) { const n = i[e]; for (let e = 0, i = n.length; e < i; e++)t.update(n[e], 34962) } }, getWireframeAttribute: function (e) { const t = s.get(e); if (t) { const n = e.index; null !== n && t.version < n.version && o(e) } else o(e); return s.get(e) } } } function _h(e, t, n, i) { const r = i.isWebGL2; let s, a, o; this.setMode = function (e) { s = e }, this.setIndex = function (e) { a = e.type, o = e.bytesPerElement }, this.render = function (t, i) { e.drawElements(s, i, a, t * o), n.update(i, s, 1) }, this.renderInstances = function (i, l, c) { if (0 === c) return; let u, h; if (r) u = e, h = "drawElementsInstanced"; else if (u = t.get("ANGLE_instanced_arrays"), h = "drawElementsInstancedANGLE", null === u) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); u[h](s, l, a, i * o, c), n.update(l, s, c) } } function wh(e) { const t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; return { memory: { geometries: 0, textures: 0 }, render: t, programs: null, autoReset: !0, reset: function () { t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0 }, update: function (e, n, i) { switch (t.calls++, n) { case 4: t.triangles += i * (e / 3); break; case 1: t.lines += i * (e / 2); break; case 3: t.lines += i * (e - 1); break; case 2: t.lines += i * e; break; case 0: t.points += i * e; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", n) } } } } function bh(e, t) { return e[0] - t[0] } function Sh(e, t) { return Math.abs(t[1]) - Math.abs(e[1]) } function Eh(e, t) { let n = 1; const i = t.isInterleavedBufferAttribute ? t.data.array : t.array; i instanceof Int8Array ? n = 127 : i instanceof Int16Array ? n = 32767 : i instanceof Int32Array ? n = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", i), e.divideScalar(n) } function Mh(e, t, n) { const i = {}, r = new Float32Array(8), s = new WeakMap, a = new Cl, o = []; for (let e = 0; e < 8; e++)o[e] = [e, 0]; return { update: function (l, c, u, h) { const d = l.morphTargetInfluences; if (!0 === t.isWebGL2) { const i = c.morphAttributes.position || c.morphAttributes.normal || c.morphAttributes.color, r = void 0 !== i ? i.length : 0; let o = s.get(c); if (void 0 === o || o.count !== r) { void 0 !== o && o.texture.dispose(); const e = void 0 !== c.morphAttributes.position, n = void 0 !== c.morphAttributes.normal, i = void 0 !== c.morphAttributes.color, l = c.morphAttributes.position || [], u = c.morphAttributes.normal || [], h = c.morphAttributes.color || []; let d = 0; !0 === e && (d = 1), !0 === n && (d = 2), !0 === i && (d = 3); let p = c.attributes.position.count * d, f = 1; p > t.maxTextureSize && (f = Math.ceil(p / t.maxTextureSize), p = t.maxTextureSize); const m = new Float32Array(p * f * 4 * r), g = new Ll(m, p, f, r); g.format = Po, g.type = Do, g.needsUpdate = !0; const v = 4 * d; for (let t = 0; t < r; t++) { const r = l[t], s = u[t], o = h[t], c = p * f * 4 * t; for (let t = 0; t < r.count; t++) { const l = t * v; !0 === e && (a.fromBufferAttribute(r, t), !0 === r.normalized && Eh(a, r), m[c + l + 0] = a.x, m[c + l + 1] = a.y, m[c + l + 2] = a.z, m[c + l + 3] = 0), !0 === n && (a.fromBufferAttribute(s, t), !0 === s.normalized && Eh(a, s), m[c + l + 4] = a.x, m[c + l + 5] = a.y, m[c + l + 6] = a.z, m[c + l + 7] = 0), !0 === i && (a.fromBufferAttribute(o, t), !0 === o.normalized && Eh(a, s), m[c + l + 8] = a.x, m[c + l + 9] = a.y, m[c + l + 10] = a.z, m[c + l + 11] = 4 === o.itemSize ? a.w : 1) } } function y() { g.dispose(), s.delete(c), c.removeEventListener("dispose", y) } o = { count: r, texture: g, size: new ul(p, f) }, s.set(c, o), c.addEventListener("dispose", y) } let l = 0; for (let e = 0; e < d.length; e++)l += d[e]; const u = c.morphTargetsRelative ? 1 : 1 - l; h.getUniforms().setValue(e, "morphTargetBaseInfluence", u), h.getUniforms().setValue(e, "morphTargetInfluences", d), h.getUniforms().setValue(e, "morphTargetsTexture", o.texture, n), h.getUniforms().setValue(e, "morphTargetsTextureSize", o.size) } else { const t = void 0 === d ? 0 : d.length; let n = i[c.id]; if (void 0 === n || n.length !== t) { n = []; for (let e = 0; e < t; e++)n[e] = [e, 0]; i[c.id] = n } for (let e = 0; e < t; e++) { const t = n[e]; t[0] = e, t[1] = d[e] } n.sort(Sh); for (let e = 0; e < 8; e++)e < t && n[e][1] ? (o[e][0] = n[e][0], o[e][1] = n[e][1]) : (o[e][0] = Number.MAX_SAFE_INTEGER, o[e][1] = 0); o.sort(bh); const s = c.morphAttributes.position, a = c.morphAttributes.normal; let l = 0; for (let e = 0; e < 8; e++) { const t = o[e], n = t[0], i = t[1]; n !== Number.MAX_SAFE_INTEGER && i ? (s && c.getAttribute("morphTarget" + e) !== s[n] && c.setAttribute("morphTarget" + e, s[n]), a && c.getAttribute("morphNormal" + e) !== a[n] && c.setAttribute("morphNormal" + e, a[n]), r[e] = i, l += i) : (s && !0 === c.hasAttribute("morphTarget" + e) && c.deleteAttribute("morphTarget" + e), a && !0 === c.hasAttribute("morphNormal" + e) && c.deleteAttribute("morphNormal" + e), r[e] = 0) } const u = c.morphTargetsRelative ? 1 : 1 - l; h.getUniforms().setValue(e, "morphTargetBaseInfluence", u), h.getUniforms().setValue(e, "morphTargetInfluences", r) } } } } function Th(e, t, n, i) { let r = new WeakMap; function s(e) { const t = e.target; t.removeEventListener("dispose", s), n.remove(t.instanceMatrix), null !== t.instanceColor && n.remove(t.instanceColor) } return { update: function (e) { const a = i.render.frame, o = e.geometry, l = t.get(e, o); return r.get(l) !== a && (t.update(l), r.set(l, a)), e.isInstancedMesh && (!1 === e.hasEventListener("dispose", s) && e.addEventListener("dispose", s), n.update(e.instanceMatrix, 34962), null !== e.instanceColor && n.update(e.instanceColor, 34962)), l }, dispose: function () { r = new WeakMap } } } const Ch = new Tl, Dh = new Ll, Lh = new Al, Ah = new ku, Ph = [], Rh = [], Oh = new Float32Array(16), Ih = new Float32Array(9), Fh = new Float32Array(4); function zh(e, t, n) { const i = e[0]; if (i <= 0 || i > 0) return e; const r = t * n; let s = Ph[r]; if (void 0 === s && (s = new Float32Array(r), Ph[r] = s), 0 !== t) { i.toArray(s, 0); for (let i = 1, r = 0; i !== t; ++i)r += n, e[i].toArray(s, r) } return s } function kh(e, t) { if (e.length !== t.length) return !1; for (let n = 0, i = e.length; n < i; n++)if (e[n] !== t[n]) return !1; return !0 } function Nh(e, t) { for (let n = 0, i = t.length; n < i; n++)e[n] = t[n] } function Bh(e, t) { let n = Rh[t]; void 0 === n && (n = new Int32Array(t), Rh[t] = n); for (let i = 0; i !== t; ++i)n[i] = e.allocateTextureUnit(); return n } function Hh(e, t) { const n = this.cache; n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t) } function Uh(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y); else { if (kh(n, t)) return; e.uniform2fv(this.addr, t), Nh(n, t) } } function Vh(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z); else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b); else { if (kh(n, t)) return; e.uniform3fv(this.addr, t), Nh(n, t) } } function Gh(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w); else { if (kh(n, t)) return; e.uniform4fv(this.addr, t), Nh(n, t) } } function jh(e, t) { const n = this.cache, i = t.elements; if (void 0 === i) { if (kh(n, t)) return; e.uniformMatrix2fv(this.addr, !1, t), Nh(n, t) } else { if (kh(n, i)) return; Fh.set(i), e.uniformMatrix2fv(this.addr, !1, Fh), Nh(n, i) } } function Wh(e, t) { const n = this.cache, i = t.elements; if (void 0 === i) { if (kh(n, t)) return; e.uniformMatrix3fv(this.addr, !1, t), Nh(n, t) } else { if (kh(n, i)) return; Ih.set(i), e.uniformMatrix3fv(this.addr, !1, Ih), Nh(n, i) } } function qh(e, t) { const n = this.cache, i = t.elements; if (void 0 === i) { if (kh(n, t)) return; e.uniformMatrix4fv(this.addr, !1, t), Nh(n, t) } else { if (kh(n, i)) return; Oh.set(i), e.uniformMatrix4fv(this.addr, !1, Oh), Nh(n, i) } } function $h(e, t) { const n = this.cache; n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t) } function Xh(e, t) { const n = this.cache; kh(n, t) || (e.uniform2iv(this.addr, t), Nh(n, t)) } function Yh(e, t) { const n = this.cache; kh(n, t) || (e.uniform3iv(this.addr, t), Nh(n, t)) } function Zh(e, t) { const n = this.cache; kh(n, t) || (e.uniform4iv(this.addr, t), Nh(n, t)) } function Kh(e, t) { const n = this.cache; n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t) } function Jh(e, t) { const n = this.cache; kh(n, t) || (e.uniform2uiv(this.addr, t), Nh(n, t)) } function Qh(e, t) { const n = this.cache; kh(n, t) || (e.uniform3uiv(this.addr, t), Nh(n, t)) } function ed(e, t) { const n = this.cache; kh(n, t) || (e.uniform4uiv(this.addr, t), Nh(n, t)) } function td(e, t, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture2D(t || Ch, r) } function nd(e, t, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(t || Lh, r) } function id(e, t, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTextureCube(t || Ah, r) } function rd(e, t, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(t || Dh, r) } function sd(e, t) { e.uniform1fv(this.addr, t) } function ad(e, t) { const n = zh(t, this.size, 2); e.uniform2fv(this.addr, n) } function od(e, t) { const n = zh(t, this.size, 3); e.uniform3fv(this.addr, n) } function ld(e, t) { const n = zh(t, this.size, 4); e.uniform4fv(this.addr, n) } function cd(e, t) { const n = zh(t, this.size, 4); e.uniformMatrix2fv(this.addr, !1, n) } function ud(e, t) { const n = zh(t, this.size, 9); e.uniformMatrix3fv(this.addr, !1, n) } function hd(e, t) { const n = zh(t, this.size, 16); e.uniformMatrix4fv(this.addr, !1, n) } function dd(e, t) { e.uniform1iv(this.addr, t) } function pd(e, t) { e.uniform2iv(this.addr, t) } function fd(e, t) { e.uniform3iv(this.addr, t) } function md(e, t) { e.uniform4iv(this.addr, t) } function gd(e, t) { e.uniform1uiv(this.addr, t) } function vd(e, t) { e.uniform2uiv(this.addr, t) } function yd(e, t) { e.uniform3uiv(this.addr, t) } function xd(e, t) { e.uniform4uiv(this.addr, t) } function _d(e, t, n) { const i = t.length, r = Bh(n, i); e.uniform1iv(this.addr, r); for (let e = 0; e !== i; ++e)n.setTexture2D(t[e] || Ch, r[e]) } function wd(e, t, n) { const i = t.length, r = Bh(n, i); e.uniform1iv(this.addr, r); for (let e = 0; e !== i; ++e)n.setTexture3D(t[e] || Lh, r[e]) } function bd(e, t, n) { const i = t.length, r = Bh(n, i); e.uniform1iv(this.addr, r); for (let e = 0; e !== i; ++e)n.setTextureCube(t[e] || Ah, r[e]) } function Sd(e, t, n) { const i = t.length, r = Bh(n, i); e.uniform1iv(this.addr, r); for (let e = 0; e !== i; ++e)n.setTexture2DArray(t[e] || Dh, r[e]) } function Ed(e, t, n) { this.id = e, this.addr = n, this.cache = [], this.setValue = function (e) { switch (e) { case 5126: return Hh; case 35664: return Uh; case 35665: return Vh; case 35666: return Gh; case 35674: return jh; case 35675: return Wh; case 35676: return qh; case 5124: case 35670: return $h; case 35667: case 35671: return Xh; case 35668: case 35672: return Yh; case 35669: case 35673: return Zh; case 5125: return Kh; case 36294: return Jh; case 36295: return Qh; case 36296: return ed; case 35678: case 36198: case 36298: case 36306: case 35682: return td; case 35679: case 36299: case 36307: return nd; case 35680: case 36300: case 36308: case 36293: return id; case 36289: case 36303: case 36311: case 36292: return rd } }(t.type) } function Md(e, t, n) { this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = function (e) { switch (e) { case 5126: return sd; case 35664: return ad; case 35665: return od; case 35666: return ld; case 35674: return cd; case 35675: return ud; case 35676: return hd; case 5124: case 35670: return dd; case 35667: case 35671: return pd; case 35668: case 35672: return fd; case 35669: case 35673: return md; case 5125: return gd; case 36294: return vd; case 36295: return yd; case 36296: return xd; case 35678: case 36198: case 36298: case 36306: case 35682: return _d; case 35679: case 36299: case 36307: return wd; case 35680: case 36300: case 36308: case 36293: return bd; case 36289: case 36303: case 36311: case 36292: return Sd } }(t.type) } function Td(e) { this.id = e, this.seq = [], this.map = {} } Md.prototype.updateCache = function (e) { const t = this.cache; e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), Nh(t, e) }, Td.prototype.setValue = function (e, t, n) { const i = this.seq; for (let r = 0, s = i.length; r !== s; ++r) { const s = i[r]; s.setValue(e, t[s.id], n) } }; const Cd = /(\w+)(\])?(\[|\.)?/g; function Dd(e, t) { e.seq.push(t), e.map[t.id] = t } function Ld(e, t, n) { const i = e.name, r = i.length; for (Cd.lastIndex = 0; ;) { const s = Cd.exec(i), a = Cd.lastIndex; let o = s[1]; const l = "]" === s[2], c = s[3]; if (l && (o |= 0), void 0 === c || "[" === c && a + 2 === r) { Dd(n, void 0 === c ? new Ed(o, e, t) : new Md(o, e, t)); break } { let e = n.map[o]; void 0 === e && (e = new Td(o), Dd(n, e)), n = e } } } function Ad(e, t) { this.seq = [], this.map = {}; const n = e.getProgramParameter(t, 35718); for (let i = 0; i < n; ++i) { const n = e.getActiveUniform(t, i); Ld(n, e.getUniformLocation(t, n.name), this) } } function Pd(e, t, n) { const i = e.createShader(t); return e.shaderSource(i, n), e.compileShader(i), i } Ad.prototype.setValue = function (e, t, n, i) { const r = this.map[t]; void 0 !== r && r.setValue(e, n, i) }, Ad.prototype.setOptional = function (e, t, n) { const i = t[n]; void 0 !== i && this.setValue(e, n, i) }, Ad.upload = function (e, t, n, i) { for (let r = 0, s = t.length; r !== s; ++r) { const s = t[r], a = n[s.id]; !1 !== a.needsUpdate && s.setValue(e, a.value, i) } }, Ad.seqWithValue = function (e, t) { const n = []; for (let i = 0, r = e.length; i !== r; ++i) { const r = e[i]; r.id in t && n.push(r) } return n }; let Rd = 0; function Od(e, t, n) { const i = e.getShaderParameter(t, 35713), r = e.getShaderInfoLog(t).trim(); return i && "" === r ? "" : n.toUpperCase() + "\n\n" + r + "\n\n" + function (e) { const t = e.split("\n"); for (let e = 0; e < t.length; e++)t[e] = e + 1 + ": " + t[e]; return t.join("\n") }(e.getShaderSource(t)) } function Id(e, t) { const n = function (e) { switch (e) { case jo: return ["Linear", "( value )"]; case Wo: return ["sRGB", "( value )"]; default: return console.warn("THREE.WebGLProgram: Unsupported encoding:", e), ["Linear", "( value )"] } }(t); return "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }" } function Fd(e, t) { let n; switch (t) { case 1: n = "Linear"; break; case 2: n = "Reinhard"; break; case 3: n = "OptimizedCineon"; break; case 4: n = "ACESFilmic"; break; case 5: n = "Custom"; break; default: console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), n = "Linear" }return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }" } function zd(e) { return "" !== e } function kd(e, t) { return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows) } function Nd(e, t) { return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection) } const Bd = /^[ \t]*#include +<([\w\d./]+)>/gm; function Hd(e) { return e.replace(Bd, Ud) } function Ud(e, t) { const n = Yu[t]; if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">"); return Hd(n) } const Vd = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, Gd = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g; function jd(e) { return e.replace(Gd, qd).replace(Vd, Wd) } function Wd(e, t, n, i) { return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), qd(0, t, n, i) } function qd(e, t, n, i) { let r = ""; for (let e = parseInt(t); e < parseInt(n); e++)r += i.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e); return r } function $d(e) { let t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;"; return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t } function Xd(e, t, n, i) { const r = e.getContext(), s = n.defines; let a = n.vertexShader, o = n.fragmentShader; const l = function (e) { let t = "SHADOWMAP_TYPE_BASIC"; return 1 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF" : 2 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"), t }(n), c = function (e) { let t = "ENVMAP_TYPE_CUBE"; if (e.envMap) switch (e.envMapMode) { case fo: case mo: t = "ENVMAP_TYPE_CUBE"; break; case go: case 307: t = "ENVMAP_TYPE_CUBE_UV" }return t }(n), u = function (e) { let t = "ENVMAP_MODE_REFLECTION"; if (e.envMap) switch (e.envMapMode) { case mo: case 307: t = "ENVMAP_MODE_REFRACTION" }return t }(n), h = function (e) { let t = "ENVMAP_BLENDING_NONE"; if (e.envMap) switch (e.combine) { case 0: t = "ENVMAP_BLENDING_MULTIPLY"; break; case 1: t = "ENVMAP_BLENDING_MIX"; break; case 2: t = "ENVMAP_BLENDING_ADD" }return t }(n), d = function (e) { const t = e.envMapCubeUVHeight; if (null === t) return null; const n = Math.log2(t / 32 + 1) + 3, i = 1 / t; return { texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)), texelHeight: i, maxMip: n } }(n), p = n.isWebGL2 ? "" : function (e) { return [e.extensionDerivatives || e.envMapCubeUVHeight || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap || e.transmission) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(zd).join("\n") }(n), f = function (e) { const t = []; for (const n in e) { const i = e[n]; !1 !== i && t.push("#define " + n + " " + i) } return t.join("\n") }(s), m = r.createProgram(); let g, v, y = n.glslVersion ? "#version " + n.glslVersion + "\n" : ""; n.isRawShaderMaterial ? (g = [f].filter(zd).join("\n"), g.length > 0 && (g += "\n"), v = [p, f].filter(zd).join("\n"), v.length > 0 && (v += "\n")) : (g = [$d(n), "#define SHADER_NAME " + n.shaderName, f, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(zd).join("\n"), v = [p, $d(n), "#define SHADER_NAME " + n.shaderName, f, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + h : "", d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "", d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "", d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? Yu.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? Fd("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", Yu.encodings_pars_fragment, Id("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(zd).join("\n")), a = Hd(a), a = kd(a, n), a = Nd(a, n), o = Hd(o), o = kd(o, n), o = Nd(o, n), a = jd(a), o = jd(o), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (y = "#version 300 es\n", g = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, v = ["#define varying in", n.glslVersion === Yo ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === Yo ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v); const x = y + v + o, _ = Pd(r, 35633, y + g + a), w = Pd(r, 35632, x); if (r.attachShader(m, _), r.attachShader(m, w), void 0 !== n.index0AttributeName ? r.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"), r.linkProgram(m), e.debug.checkShaderErrors) { const e = r.getProgramInfoLog(m).trim(), t = r.getShaderInfoLog(_).trim(), n = r.getShaderInfoLog(w).trim(); let i = !0, s = !0; if (!1 === r.getProgramParameter(m, 35714)) { i = !1; const t = Od(r, _, "vertex"), n = Od(r, w, "fragment"); console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(m, 35715) + "\n\nProgram Info Log: " + e + "\n" + t + "\n" + n) } else "" !== e ? console.warn("THREE.WebGLProgram: Program Info Log:", e) : "" !== t && "" !== n || (s = !1); s && (this.diagnostics = { runnable: i, programLog: e, vertexShader: { log: t, prefix: g }, fragmentShader: { log: n, prefix: v } }) } let b, S; return r.deleteShader(_), r.deleteShader(w), this.getUniforms = function () { return void 0 === b && (b = new Ad(r, m)), b }, this.getAttributes = function () { return void 0 === S && (S = function (e, t) { const n = {}, i = e.getProgramParameter(t, 35721); for (let r = 0; r < i; r++) { const i = e.getActiveAttrib(t, r), s = i.name; let a = 1; 35674 === i.type && (a = 2), 35675 === i.type && (a = 3), 35676 === i.type && (a = 4), n[s] = { type: i.type, location: e.getAttribLocation(t, s), locationSize: a } } return n }(r, m)), S }, this.destroy = function () { i.releaseStatesOfProgram(this), r.deleteProgram(m), this.program = void 0 }, this.name = n.shaderName, this.id = Rd++, this.cacheKey = t, this.usedTimes = 1, this.program = m, this.vertexShader = _, this.fragmentShader = w, this } let Yd = 0; class Zd { constructor() { this.shaderCache = new Map, this.materialCache = new Map } update(e) { const t = e.vertexShader, n = e.fragmentShader, i = this._getShaderStage(t), r = this._getShaderStage(n), s = this._getShaderCacheForMaterial(e); return !1 === s.has(i) && (s.add(i), i.usedTimes++), !1 === s.has(r) && (s.add(r), r.usedTimes++), this } remove(e) { const t = this.materialCache.get(e); for (const e of t) e.usedTimes--, 0 === e.usedTimes && this.shaderCache.delete(e); return this.materialCache.delete(e), this } getVertexShaderID(e) { return this._getShaderStage(e.vertexShader).id } getFragmentShaderID(e) { return this._getShaderStage(e.fragmentShader).id } dispose() { this.shaderCache.clear(), this.materialCache.clear() } _getShaderCacheForMaterial(e) { const t = this.materialCache; return !1 === t.has(e) && t.set(e, new Set), t.get(e) } _getShaderStage(e) { const t = this.shaderCache; if (!1 === t.has(e)) { const n = new Kd; t.set(e, n) } return t.get(e) } } class Kd { constructor() { this.id = Yd++, this.usedTimes = 0 } } function Jd(e, t, n, i, r, s, a) { const o = new _c, l = new Zd, c = [], u = r.isWebGL2, h = r.logarithmicDepthBuffer, d = r.floatVertexTextures, p = r.maxVertexUniforms, f = r.vertexTextures; let m = r.precision; const g = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }; return { getParameters: function (s, o, c, v, y) { const x = v.fog, _ = y.geometry, w = s.isMeshStandardMaterial ? v.environment : null, b = (s.isMeshStandardMaterial ? n : t).get(s.envMap || w), S = !b || b.mapping !== go && 307 !== b.mapping ? null : b.image.height, E = g[s.type], M = y.isSkinnedMesh ? function (e) { const t = e.skeleton.bones; if (d) return 1024; { const e = p, n = Math.floor((e - 20) / 4), i = Math.min(n, t.length); return i < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + i + "."), 0) : i } }(y) : 0; null !== s.precision && (m = r.getMaxPrecision(s.precision), m !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", m, "instead.")); const T = _.morphAttributes.position || _.morphAttributes.normal || _.morphAttributes.color, C = void 0 !== T ? T.length : 0; let D, L, A, P, R = 0; if (void 0 !== _.morphAttributes.position && (R = 1), void 0 !== _.morphAttributes.normal && (R = 2), void 0 !== _.morphAttributes.color && (R = 3), E) { const e = Ku[E]; D = e.vertexShader, L = e.fragmentShader } else D = s.vertexShader, L = s.fragmentShader, l.update(s), A = l.getVertexShaderID(s), P = l.getFragmentShaderID(s); const O = e.getRenderTarget(), I = s.alphaTest > 0, F = s.clearcoat > 0; return { isWebGL2: u, shaderID: E, shaderName: s.type, vertexShader: D, fragmentShader: L, defines: s.defines, customVertexShaderID: A, customFragmentShaderID: P, isRawShaderMaterial: !0 === s.isRawShaderMaterial, glslVersion: s.glslVersion, precision: m, instancing: !0 === y.isInstancedMesh, instancingColor: !0 === y.isInstancedMesh && null !== y.instanceColor, supportsVertexTextures: f, outputEncoding: null === O ? e.outputEncoding : !0 === O.isXRRenderTarget ? O.texture.encoding : jo, map: !!s.map, matcap: !!s.matcap, envMap: !!b, envMapMode: b && b.mapping, envMapCubeUVHeight: S, lightMap: !!s.lightMap, aoMap: !!s.aoMap, emissiveMap: !!s.emissiveMap, bumpMap: !!s.bumpMap, normalMap: !!s.normalMap, objectSpaceNormalMap: 1 === s.normalMapType, tangentSpaceNormalMap: 0 === s.normalMapType, decodeVideoTexture: !!s.map && !0 === s.map.isVideoTexture && s.map.encoding === Wo, clearcoat: F, clearcoatMap: F && !!s.clearcoatMap, clearcoatRoughnessMap: F && !!s.clearcoatRoughnessMap, clearcoatNormalMap: F && !!s.clearcoatNormalMap, displacementMap: !!s.displacementMap, roughnessMap: !!s.roughnessMap, metalnessMap: !!s.metalnessMap, specularMap: !!s.specularMap, specularIntensityMap: !!s.specularIntensityMap, specularColorMap: !!s.specularColorMap, opaque: !1 === s.transparent && 1 === s.blending, alphaMap: !!s.alphaMap, alphaTest: I, gradientMap: !!s.gradientMap, sheen: s.sheen > 0, sheenColorMap: !!s.sheenColorMap, sheenRoughnessMap: !!s.sheenRoughnessMap, transmission: s.transmission > 0, transmissionMap: !!s.transmissionMap, thicknessMap: !!s.thicknessMap, combine: s.combine, vertexTangents: !!s.normalMap && !!_.attributes.tangent, vertexColors: s.vertexColors, vertexAlphas: !0 === s.vertexColors && !!_.attributes.color && 4 === _.attributes.color.itemSize, vertexUvs: !!(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatMap || s.clearcoatRoughnessMap || s.clearcoatNormalMap || s.displacementMap || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || s.sheenColorMap || s.sheenRoughnessMap), uvsVertexOnly: !(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatNormalMap || s.transmission > 0 || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || s.sheen > 0 || s.sheenColorMap || s.sheenRoughnessMap || !s.displacementMap), fog: !!x, useFog: s.fog, fogExp2: x && x.isFogExp2, flatShading: !!s.flatShading, sizeAttenuation: s.sizeAttenuation, logarithmicDepthBuffer: h, skinning: !0 === y.isSkinnedMesh && M > 0, maxBones: M, useVertexTexture: d, morphTargets: void 0 !== _.morphAttributes.position, morphNormals: void 0 !== _.morphAttributes.normal, morphColors: void 0 !== _.morphAttributes.color, morphTargetsCount: C, morphTextureStride: R, numDirLights: o.directional.length, numPointLights: o.point.length, numSpotLights: o.spot.length, numRectAreaLights: o.rectArea.length, numHemiLights: o.hemi.length, numDirLightShadows: o.directionalShadowMap.length, numPointLightShadows: o.pointShadowMap.length, numSpotLightShadows: o.spotShadowMap.length, numClippingPlanes: a.numPlanes, numClipIntersection: a.numIntersection, dithering: s.dithering, shadowMapEnabled: e.shadowMap.enabled && c.length > 0, shadowMapType: e.shadowMap.type, toneMapping: s.toneMapped ? e.toneMapping : 0, physicallyCorrectLights: e.physicallyCorrectLights, premultipliedAlpha: s.premultipliedAlpha, doubleSided: 2 === s.side, flipSided: 1 === s.side, depthPacking: void 0 !== s.depthPacking && s.depthPacking, index0AttributeName: s.index0AttributeName, extensionDerivatives: s.extensions && s.extensions.derivatives, extensionFragDepth: s.extensions && s.extensions.fragDepth, extensionDrawBuffers: s.extensions && s.extensions.drawBuffers, extensionShaderTextureLOD: s.extensions && s.extensions.shaderTextureLOD, rendererExtensionFragDepth: u || i.has("EXT_frag_depth"), rendererExtensionDrawBuffers: u || i.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: u || i.has("EXT_shader_texture_lod"), customProgramCacheKey: s.customProgramCacheKey() } }, getProgramCacheKey: function (t) { const n = []; if (t.shaderID ? n.push(t.shaderID) : (n.push(t.customVertexShaderID), n.push(t.customFragmentShaderID)), void 0 !== t.defines) for (const e in t.defines) n.push(e), n.push(t.defines[e]); return !1 === t.isRawShaderMaterial && (function (e, t) { e.push(t.precision), e.push(t.outputEncoding), e.push(t.envMapMode), e.push(t.envMapCubeUVHeight), e.push(t.combine), e.push(t.vertexUvs), e.push(t.fogExp2), e.push(t.sizeAttenuation), e.push(t.maxBones), e.push(t.morphTargetsCount), e.push(t.morphAttributeCount), e.push(t.numDirLights), e.push(t.numPointLights), e.push(t.numSpotLights), e.push(t.numHemiLights), e.push(t.numRectAreaLights), e.push(t.numDirLightShadows), e.push(t.numPointLightShadows), e.push(t.numSpotLightShadows), e.push(t.shadowMapType), e.push(t.toneMapping), e.push(t.numClippingPlanes), e.push(t.numClipIntersection) }(n, t), function (e, t) { o.disableAll(), t.isWebGL2 && o.enable(0), t.supportsVertexTextures && o.enable(1), t.instancing && o.enable(2), t.instancingColor && o.enable(3), t.map && o.enable(4), t.matcap && o.enable(5), t.envMap && o.enable(6), t.lightMap && o.enable(7), t.aoMap && o.enable(8), t.emissiveMap && o.enable(9), t.bumpMap && o.enable(10), t.normalMap && o.enable(11), t.objectSpaceNormalMap && o.enable(12), t.tangentSpaceNormalMap && o.enable(13), t.clearcoat && o.enable(14), t.clearcoatMap && o.enable(15), t.clearcoatRoughnessMap && o.enable(16), t.clearcoatNormalMap && o.enable(17), t.displacementMap && o.enable(18), t.specularMap && o.enable(19), t.roughnessMap && o.enable(20), t.metalnessMap && o.enable(21), t.gradientMap && o.enable(22), t.alphaMap && o.enable(23), t.alphaTest && o.enable(24), t.vertexColors && o.enable(25), t.vertexAlphas && o.enable(26), t.vertexUvs && o.enable(27), t.vertexTangents && o.enable(28), t.uvsVertexOnly && o.enable(29), t.fog && o.enable(30), e.push(o.mask), o.disableAll(), t.useFog && o.enable(0), t.flatShading && o.enable(1), t.logarithmicDepthBuffer && o.enable(2), t.skinning && o.enable(3), t.useVertexTexture && o.enable(4), t.morphTargets && o.enable(5), t.morphNormals && o.enable(6), t.morphColors && o.enable(7), t.premultipliedAlpha && o.enable(8), t.shadowMapEnabled && o.enable(9), t.physicallyCorrectLights && o.enable(10), t.doubleSided && o.enable(11), t.flipSided && o.enable(12), t.depthPacking && o.enable(13), t.dithering && o.enable(14), t.specularIntensityMap && o.enable(15), t.specularColorMap && o.enable(16), t.transmission && o.enable(17), t.transmissionMap && o.enable(18), t.thicknessMap && o.enable(19), t.sheen && o.enable(20), t.sheenColorMap && o.enable(21), t.sheenRoughnessMap && o.enable(22), t.decodeVideoTexture && o.enable(23), t.opaque && o.enable(24), e.push(o.mask) }(n, t), n.push(e.outputEncoding)), n.push(t.customProgramCacheKey), n.join() }, getUniforms: function (e) { const t = g[e.type]; let n; if (t) { const e = Ku[t]; n = Pu.clone(e.uniforms) } else n = e.uniforms; return n }, acquireProgram: function (t, n) { let i; for (let e = 0, t = c.length; e < t; e++) { const t = c[e]; if (t.cacheKey === n) { i = t, ++i.usedTimes; break } } return void 0 === i && (i = new Xd(e, n, t, s), c.push(i)), i }, releaseProgram: function (e) { if (0 == --e.usedTimes) { const t = c.indexOf(e); c[t] = c[c.length - 1], c.pop(), e.destroy() } }, releaseShaderCache: function (e) { l.remove(e) }, programs: c, dispose: function () { l.dispose() } } } function Qd() { let e = new WeakMap; return { get: function (t) { let n = e.get(t); return void 0 === n && (n = {}, e.set(t, n)), n }, remove: function (t) { e.delete(t) }, update: function (t, n, i) { e.get(t)[n] = i }, dispose: function () { e = new WeakMap } } } function ep(e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id } function tp(e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id } function np() { const e = []; let t = 0; const n = [], i = [], r = []; function s(n, i, r, s, a, o) { let l = e[t]; return void 0 === l ? (l = { id: n.id, object: n, geometry: i, material: r, groupOrder: s, renderOrder: n.renderOrder, z: a, group: o }, e[t] = l) : (l.id = n.id, l.object = n, l.geometry = i, l.material = r, l.groupOrder = s, l.renderOrder = n.renderOrder, l.z = a, l.group = o), t++, l } return { opaque: n, transmissive: i, transparent: r, init: function () { t = 0, n.length = 0, i.length = 0, r.length = 0 }, push: function (e, t, a, o, l, c) { const u = s(e, t, a, o, l, c); a.transmission > 0 ? i.push(u) : !0 === a.transparent ? r.push(u) : n.push(u) }, unshift: function (e, t, a, o, l, c) { const u = s(e, t, a, o, l, c); a.transmission > 0 ? i.unshift(u) : !0 === a.transparent ? r.unshift(u) : n.unshift(u) }, finish: function () { for (let n = t, i = e.length; n < i; n++) { const t = e[n]; if (null === t.id) break; t.id = null, t.object = null, t.geometry = null, t.material = null, t.group = null } }, sort: function (e, t) { n.length > 1 && n.sort(e || ep), i.length > 1 && i.sort(t || tp), r.length > 1 && r.sort(t || tp) } } } function ip() { let e = new WeakMap; return { get: function (t, n) { let i; return !1 === e.has(t) ? (i = new np, e.set(t, [i])) : n >= e.get(t).length ? (i = new np, e.get(t).push(i)) : i = e.get(t)[n], i }, dispose: function () { e = new WeakMap } } } function rp() { const e = {}; return { get: function (t) { if (void 0 !== e[t.id]) return e[t.id]; let n; switch (t.type) { case "DirectionalLight": n = { direction: new Rl, color: new _l }; break; case "SpotLight": n = { position: new Rl, direction: new Rl, color: new _l, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case "PointLight": n = { position: new Rl, color: new _l, distance: 0, decay: 0 }; break; case "HemisphereLight": n = { direction: new Rl, skyColor: new _l, groundColor: new _l }; break; case "RectAreaLight": n = { color: new _l, position: new Rl, halfWidth: new Rl, halfHeight: new Rl } }return e[t.id] = n, n } } } let sp = 0; function ap(e, t) { return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0) } function op(e, t) { const n = new rp, i = function () { const e = {}; return { get: function (t) { if (void 0 !== e[t.id]) return e[t.id]; let n; switch (t.type) { case "DirectionalLight": case "SpotLight": n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new ul }; break; case "PointLight": n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new ul, shadowCameraNear: 1, shadowCameraFar: 1e3 } }return e[t.id] = n, n } } }(), r = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] }; for (let e = 0; e < 9; e++)r.probe.push(new Rl); const s = new Rl, a = new cc, o = new cc; return { setup: function (s, a) { let o = 0, l = 0, c = 0; for (let e = 0; e < 9; e++)r.probe[e].set(0, 0, 0); let u = 0, h = 0, d = 0, p = 0, f = 0, m = 0, g = 0, v = 0; s.sort(ap); const y = !0 !== a ? Math.PI : 1; for (let e = 0, t = s.length; e < t; e++) { const t = s[e], a = t.color, x = t.intensity, _ = t.distance, w = t.shadow && t.shadow.map ? t.shadow.map.texture : null; if (t.isAmbientLight) o += a.r * x * y, l += a.g * x * y, c += a.b * x * y; else if (t.isLightProbe) for (let e = 0; e < 9; e++)r.probe[e].addScaledVector(t.sh.coefficients[e], x); else if (t.isDirectionalLight) { const e = n.get(t); if (e.color.copy(t.color).multiplyScalar(t.intensity * y), t.castShadow) { const e = t.shadow, n = i.get(t); n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, r.directionalShadow[u] = n, r.directionalShadowMap[u] = w, r.directionalShadowMatrix[u] = t.shadow.matrix, m++ } r.directional[u] = e, u++ } else if (t.isSpotLight) { const e = n.get(t); if (e.position.setFromMatrixPosition(t.matrixWorld), e.color.copy(a).multiplyScalar(x * y), e.distance = _, e.coneCos = Math.cos(t.angle), e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra)), e.decay = t.decay, t.castShadow) { const e = t.shadow, n = i.get(t); n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, r.spotShadow[d] = n, r.spotShadowMap[d] = w, r.spotShadowMatrix[d] = t.shadow.matrix, v++ } r.spot[d] = e, d++ } else if (t.isRectAreaLight) { const e = n.get(t); e.color.copy(a).multiplyScalar(x), e.halfWidth.set(.5 * t.width, 0, 0), e.halfHeight.set(0, .5 * t.height, 0), r.rectArea[p] = e, p++ } else if (t.isPointLight) { const e = n.get(t); if (e.color.copy(t.color).multiplyScalar(t.intensity * y), e.distance = t.distance, e.decay = t.decay, t.castShadow) { const e = t.shadow, n = i.get(t); n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, n.shadowCameraNear = e.camera.near, n.shadowCameraFar = e.camera.far, r.pointShadow[h] = n, r.pointShadowMap[h] = w, r.pointShadowMatrix[h] = t.shadow.matrix, g++ } r.point[h] = e, h++ } else if (t.isHemisphereLight) { const e = n.get(t); e.skyColor.copy(t.color).multiplyScalar(x * y), e.groundColor.copy(t.groundColor).multiplyScalar(x * y), r.hemi[f] = e, f++ } } p > 0 && (t.isWebGL2 || !0 === e.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = Zu.LTC_FLOAT_1, r.rectAreaLTC2 = Zu.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = Zu.LTC_HALF_1, r.rectAreaLTC2 = Zu.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = o, r.ambient[1] = l, r.ambient[2] = c; const x = r.hash; x.directionalLength === u && x.pointLength === h && x.spotLength === d && x.rectAreaLength === p && x.hemiLength === f && x.numDirectionalShadows === m && x.numPointShadows === g && x.numSpotShadows === v || (r.directional.length = u, r.spot.length = d, r.rectArea.length = p, r.point.length = h, r.hemi.length = f, r.directionalShadow.length = m, r.directionalShadowMap.length = m, r.pointShadow.length = g, r.pointShadowMap.length = g, r.spotShadow.length = v, r.spotShadowMap.length = v, r.directionalShadowMatrix.length = m, r.pointShadowMatrix.length = g, r.spotShadowMatrix.length = v, x.directionalLength = u, x.pointLength = h, x.spotLength = d, x.rectAreaLength = p, x.hemiLength = f, x.numDirectionalShadows = m, x.numPointShadows = g, x.numSpotShadows = v, r.version = sp++) }, setupView: function (e, t) { let n = 0, i = 0, l = 0, c = 0, u = 0; const h = t.matrixWorldInverse; for (let t = 0, d = e.length; t < d; t++) { const d = e[t]; if (d.isDirectionalLight) { const e = r.directional[n]; e.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(s), e.direction.transformDirection(h), n++ } else if (d.isSpotLight) { const e = r.spot[l]; e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(h), e.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(s), e.direction.transformDirection(h), l++ } else if (d.isRectAreaLight) { const e = r.rectArea[c]; e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(h), o.identity(), a.copy(d.matrixWorld), a.premultiply(h), o.extractRotation(a), e.halfWidth.set(.5 * d.width, 0, 0), e.halfHeight.set(0, .5 * d.height, 0), e.halfWidth.applyMatrix4(o), e.halfHeight.applyMatrix4(o), c++ } else if (d.isPointLight) { const e = r.point[i]; e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(h), i++ } else if (d.isHemisphereLight) { const e = r.hemi[u]; e.direction.setFromMatrixPosition(d.matrixWorld), e.direction.transformDirection(h), e.direction.normalize(), u++ } } }, state: r } } function lp(e, t) { const n = new op(e, t), i = [], r = []; return { init: function () { i.length = 0, r.length = 0 }, state: { lightsArray: i, shadowsArray: r, lights: n }, setupLights: function (e) { n.setup(i, e) }, setupLightsView: function (e) { n.setupView(i, e) }, pushLight: function (e) { i.push(e) }, pushShadow: function (e) { r.push(e) } } } function cp(e, t) { let n = new WeakMap; return { get: function (i, r = 0) { let s; return !1 === n.has(i) ? (s = new lp(e, t), n.set(i, [s])) : r >= n.get(i).length ? (s = new lp(e, t), n.get(i).push(s)) : s = n.get(i)[r], s }, dispose: function () { n = new WeakMap } } } class up extends $c { constructor(e) { super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(e) } copy(e) { return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this } } up.prototype.isMeshDepthMaterial = !0; class hp extends $c { constructor(e) { super(), this.type = "MeshDistanceMaterial", this.referencePosition = new Rl, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(e) } copy(e) { return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this } } function dp(e, t, n) { let i = new Wu; const r = new ul, s = new ul, a = new Cl, o = new up({ depthPacking: 3201 }), l = new hp, c = {}, u = n.maxTextureSize, h = { 0: 1, 1: 0, 2: 2 }, d = new Ru({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new ul }, radius: { value: 4 } }, vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}" }), p = d.clone(); p.defines.HORIZONTAL_PASS = 1; const f = new lu; f.setAttribute("position", new Kc(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)); const m = new Tu(f, d), g = this; function v(n, i) { const r = t.update(m); d.defines.VSM_SAMPLES !== n.blurSamples && (d.defines.VSM_SAMPLES = n.blurSamples, p.defines.VSM_SAMPLES = n.blurSamples, d.needsUpdate = !0, p.needsUpdate = !0), d.uniforms.shadow_pass.value = n.map.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, e.setRenderTarget(n.mapPass), e.clear(), e.renderBufferDirect(i, null, r, d, m, null), p.uniforms.shadow_pass.value = n.mapPass.texture, p.uniforms.resolution.value = n.mapSize, p.uniforms.radius.value = n.radius, e.setRenderTarget(n.map), e.clear(), e.renderBufferDirect(i, null, r, p, m, null) } function y(t, n, i, r, s, a) { let u = null; const d = !0 === i.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial; if (u = void 0 !== d ? d : !0 === i.isPointLight ? l : o, e.localClippingEnabled && !0 === n.clipShadows && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0) { const e = u.uuid, t = n.uuid; let i = c[e]; void 0 === i && (i = {}, c[e] = i); let r = i[t]; void 0 === r && (r = u.clone(), i[t] = r), u = r } return u.visible = n.visible, u.wireframe = n.wireframe, u.side = 3 === a ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : h[n.side], u.alphaMap = n.alphaMap, u.alphaTest = n.alphaTest, u.clipShadows = n.clipShadows, u.clippingPlanes = n.clippingPlanes, u.clipIntersection = n.clipIntersection, u.displacementMap = n.displacementMap, u.displacementScale = n.displacementScale, u.displacementBias = n.displacementBias, u.wireframeLinewidth = n.wireframeLinewidth, u.linewidth = n.linewidth, !0 === i.isPointLight && !0 === u.isMeshDistanceMaterial && (u.referencePosition.setFromMatrixPosition(i.matrixWorld), u.nearDistance = r, u.farDistance = s), u } function x(n, r, s, a, o) { if (!1 === n.visible) return; if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === o) && (!n.frustumCulled || i.intersectsObject(n))) { n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld); const i = t.update(n), r = n.material; if (Array.isArray(r)) { const t = i.groups; for (let l = 0, c = t.length; l < c; l++) { const c = t[l], u = r[c.materialIndex]; if (u && u.visible) { const t = y(n, u, a, s.near, s.far, o); e.renderBufferDirect(s, null, i, t, n, c) } } } else if (r.visible) { const t = y(n, r, a, s.near, s.far, o); e.renderBufferDirect(s, null, i, t, n, null) } } const l = n.children; for (let e = 0, t = l.length; e < t; e++)x(l[e], r, s, a, o) } this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function (t, n, o) { if (!1 === g.enabled) return; if (!1 === g.autoUpdate && !1 === g.needsUpdate) return; if (0 === t.length) return; const l = e.getRenderTarget(), c = e.getActiveCubeFace(), h = e.getActiveMipmapLevel(), d = e.state; d.setBlending(0), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1); for (let l = 0, c = t.length; l < c; l++) { const c = t[l], h = c.shadow; if (void 0 === h) { console.warn("THREE.WebGLShadowMap:", c, "has no shadow."); continue } if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue; r.copy(h.mapSize); const p = h.getFrameExtents(); if (r.multiply(p), s.copy(h.mapSize), (r.x > u || r.y > u) && (r.x > u && (s.x = Math.floor(u / p.x), r.x = s.x * p.x, h.mapSize.x = s.x), r.y > u && (s.y = Math.floor(u / p.y), r.y = s.y * p.y, h.mapSize.y = s.y)), null === h.map && !h.isPointLightShadow && 3 === this.type) { const e = { minFilter: So, magFilter: So, format: Po }; h.map = new Dl(r.x, r.y, e), h.map.texture.name = c.name + ".shadowMap", h.mapPass = new Dl(r.x, r.y, e), h.camera.updateProjectionMatrix() } if (null === h.map) { const e = { minFilter: _o, magFilter: _o, format: Po }; h.map = new Dl(r.x, r.y, e), h.map.texture.name = c.name + ".shadowMap", h.camera.updateProjectionMatrix() } e.setRenderTarget(h.map), e.clear(); const f = h.getViewportCount(); for (let e = 0; e < f; e++) { const t = h.getViewport(e); a.set(s.x * t.x, s.y * t.y, s.x * t.z, s.y * t.w), d.viewport(a), h.updateMatrices(c, e), i = h.getFrustum(), x(n, o, h.camera, c, this.type) } h.isPointLightShadow || 3 !== this.type || v(h, o), h.needsUpdate = !1 } g.needsUpdate = !1, e.setRenderTarget(l, c, h) } } function pp(e, t, n) { const i = n.isWebGL2, r = new function () { let t = !1; const n = new Cl; let i = null; const r = new Cl(0, 0, 0, 0); return { setMask: function (n) { i === n || t || (e.colorMask(n, n, n, n), i = n) }, setLocked: function (e) { t = e }, setClear: function (t, i, s, a, o) { !0 === o && (t *= a, i *= a, s *= a), n.set(t, i, s, a), !1 === r.equals(n) && (e.clearColor(t, i, s, a), r.copy(n)) }, reset: function () { t = !1, i = null, r.set(-1, 0, 0, 0) } } }, s = new function () { let t = !1, n = null, i = null, r = null; return { setTest: function (e) { e ? N(2929) : B(2929) }, setMask: function (i) { n === i || t || (e.depthMask(i), n = i) }, setFunc: function (t) { if (i !== t) { if (t) switch (t) { case 0: e.depthFunc(512); break; case 1: e.depthFunc(519); break; case 2: e.depthFunc(513); break; case 3: default: e.depthFunc(515); break; case 4: e.depthFunc(514); break; case 5: e.depthFunc(518); break; case 6: e.depthFunc(516); break; case 7: e.depthFunc(517) } else e.depthFunc(515); i = t } }, setLocked: function (e) { t = e }, setClear: function (t) { r !== t && (e.clearDepth(t), r = t) }, reset: function () { t = !1, n = null, i = null, r = null } } }, a = new function () { let t = !1, n = null, i = null, r = null, s = null, a = null, o = null, l = null, c = null; return { setTest: function (e) { t || (e ? N(2960) : B(2960)) }, setMask: function (i) { n === i || t || (e.stencilMask(i), n = i) }, setFunc: function (t, n, a) { i === t && r === n && s === a || (e.stencilFunc(t, n, a), i = t, r = n, s = a) }, setOp: function (t, n, i) { a === t && o === n && l === i || (e.stencilOp(t, n, i), a = t, o = n, l = i) }, setLocked: function (e) { t = e }, setClear: function (t) { c !== t && (e.clearStencil(t), c = t) }, reset: function () { t = !1, n = null, i = null, r = null, s = null, a = null, o = null, l = null, c = null } } }; let o = {}, l = {}, c = new WeakMap, u = [], h = null, d = !1, p = null, f = null, m = null, g = null, v = null, y = null, x = null, _ = !1, w = null, b = null, S = null, E = null, M = null; const T = e.getParameter(35661); let C = !1, D = 0; const L = e.getParameter(7938); -1 !== L.indexOf("WebGL") ? (D = parseFloat(/^WebGL (\d)/.exec(L)[1]), C = D >= 1) : -1 !== L.indexOf("OpenGL ES") && (D = parseFloat(/^OpenGL ES (\d)/.exec(L)[1]), C = D >= 2); let A = null, P = {}; const R = e.getParameter(3088), O = e.getParameter(2978), I = (new Cl).fromArray(R), F = (new Cl).fromArray(O); function z(t, n, i) { const r = new Uint8Array(4), s = e.createTexture(); e.bindTexture(t, s), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728); for (let t = 0; t < i; t++)e.texImage2D(n + t, 0, 6408, 1, 1, 0, 6408, 5121, r); return s } const k = {}; function N(t) { !0 !== o[t] && (e.enable(t), o[t] = !0) } function B(t) { !1 !== o[t] && (e.disable(t), o[t] = !1) } k[3553] = z(3553, 3553, 1), k[34067] = z(34067, 34069, 6), r.setClear(0, 0, 0, 1), s.setClear(1), a.setClear(0), N(2929), s.setFunc(3), G(!1), j(1), N(2884), V(0); const H = { [po]: 32774, 101: 32778, 102: 32779 }; if (i) H[103] = 32775, H[104] = 32776; else { const e = t.get("EXT_blend_minmax"); null !== e && (H[103] = e.MIN_EXT, H[104] = e.MAX_EXT) } const U = { 200: 0, 201: 1, 202: 768, 204: 770, 210: 776, 208: 774, 206: 772, 203: 769, 205: 771, 209: 775, 207: 773 }; function V(t, n, i, r, s, a, o, l) { if (0 !== t) { if (!1 === d && (N(3042), d = !0), 5 === t) s = s || n, a = a || i, o = o || r, n === f && s === v || (e.blendEquationSeparate(H[n], H[s]), f = n, v = s), i === m && r === g && a === y && o === x || (e.blendFuncSeparate(U[i], U[r], U[a], U[o]), m = i, g = r, y = a, x = o), p = t, _ = null; else if (t !== p || l !== _) { if (f === po && v === po || (e.blendEquation(32774), f = po, v = po), l) switch (t) { case 1: e.blendFuncSeparate(1, 771, 1, 771); break; case 2: e.blendFunc(1, 1); break; case 3: e.blendFuncSeparate(0, 769, 0, 1); break; case 4: e.blendFuncSeparate(0, 768, 0, 770); break; default: console.error("THREE.WebGLState: Invalid blending: ", t) } else switch (t) { case 1: e.blendFuncSeparate(770, 771, 1, 771); break; case 2: e.blendFunc(770, 1); break; case 3: e.blendFuncSeparate(0, 769, 0, 1); break; case 4: e.blendFunc(0, 768); break; default: console.error("THREE.WebGLState: Invalid blending: ", t) }m = null, g = null, y = null, x = null, p = t, _ = l } } else !0 === d && (B(3042), d = !1) } function G(t) { w !== t && (t ? e.frontFace(2304) : e.frontFace(2305), w = t) } function j(t) { 0 !== t ? (N(2884), t !== b && (1 === t ? e.cullFace(1029) : 2 === t ? e.cullFace(1028) : e.cullFace(1032))) : B(2884), b = t } function W(t, n, i) { t ? (N(32823), E === n && M === i || (e.polygonOffset(n, i), E = n, M = i)) : B(32823) } function q(t) { void 0 === t && (t = 33984 + T - 1), A !== t && (e.activeTexture(t), A = t) } return { buffers: { color: r, depth: s, stencil: a }, enable: N, disable: B, bindFramebuffer: function (t, n) { return l[t] !== n && (e.bindFramebuffer(t, n), l[t] = n, i && (36009 === t && (l[36160] = n), 36160 === t && (l[36009] = n)), !0) }, drawBuffers: function (i, r) { let s = u, a = !1; if (i) if (s = c.get(r), void 0 === s && (s = [], c.set(r, s)), i.isWebGLMultipleRenderTargets) { const e = i.texture; if (s.length !== e.length || 36064 !== s[0]) { for (let t = 0, n = e.length; t < n; t++)s[t] = 36064 + t; s.length = e.length, a = !0 } } else 36064 !== s[0] && (s[0] = 36064, a = !0); else 1029 !== s[0] && (s[0] = 1029, a = !0); a && (n.isWebGL2 ? e.drawBuffers(s) : t.get("WEBGL_draw_buffers").drawBuffersWEBGL(s)) }, useProgram: function (t) { return h !== t && (e.useProgram(t), h = t, !0) }, setBlending: V, setMaterial: function (e, t) { 2 === e.side ? B(2884) : N(2884); let n = 1 === e.side; t && (n = !n), G(n), 1 === e.blending && !1 === e.transparent ? V(0) : V(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), s.setFunc(e.depthFunc), s.setTest(e.depthTest), s.setMask(e.depthWrite), r.setMask(e.colorWrite); const i = e.stencilWrite; a.setTest(i), i && (a.setMask(e.stencilWriteMask), a.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), a.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), W(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), !0 === e.alphaToCoverage ? N(32926) : B(32926) }, setFlipSided: G, setCullFace: j, setLineWidth: function (t) { t !== S && (C && e.lineWidth(t), S = t) }, setPolygonOffset: W, setScissorTest: function (e) { e ? N(3089) : B(3089) }, activeTexture: q, bindTexture: function (t, n) { null === A && q(); let i = P[A]; void 0 === i && (i = { type: void 0, texture: void 0 }, P[A] = i), i.type === t && i.texture === n || (e.bindTexture(t, n || k[t]), i.type = t, i.texture = n) }, unbindTexture: function () { const t = P[A]; void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0) }, compressedTexImage2D: function () { try { e.compressedTexImage2D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage2D: function () { try { e.texImage2D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage3D: function () { try { e.texImage3D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texStorage2D: function () { try { e.texStorage2D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texStorage3D: function () { try { e.texStorage3D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texSubImage2D: function () { try { e.texSubImage2D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texSubImage3D: function () { try { e.texSubImage3D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, compressedTexSubImage2D: function () { try { e.compressedTexSubImage2D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, scissor: function (t) { !1 === I.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), I.copy(t)) }, viewport: function (t) { !1 === F.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), F.copy(t)) }, reset: function () { e.disable(3042), e.disable(2884), e.disable(2929), e.disable(32823), e.disable(3089), e.disable(2960), e.disable(32926), e.blendEquation(32774), e.blendFunc(1, 0), e.blendFuncSeparate(1, 0, 1, 0), e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.depthMask(!0), e.depthFunc(513), e.clearDepth(1), e.stencilMask(4294967295), e.stencilFunc(519, 0, 4294967295), e.stencilOp(7680, 7680, 7680), e.clearStencil(0), e.cullFace(1029), e.frontFace(2305), e.polygonOffset(0, 0), e.activeTexture(33984), e.bindFramebuffer(36160, null), !0 === i && (e.bindFramebuffer(36009, null), e.bindFramebuffer(36008, null)), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), o = {}, A = null, P = {}, l = {}, c = new WeakMap, u = [], h = null, d = !1, p = null, f = null, m = null, g = null, v = null, y = null, x = null, _ = !1, w = null, b = null, S = null, E = null, M = null, I.set(0, 0, e.canvas.width, e.canvas.height), F.set(0, 0, e.canvas.width, e.canvas.height), r.reset(), s.reset(), a.reset() } } } function fp(e, t, n, i, r, s, a) { const o = r.isWebGL2, l = r.maxTextures, c = r.maxCubemapSize, u = r.maxTextureSize, h = r.maxSamples, d = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null, p = new WeakMap; let f; const m = new WeakMap; let g = !1; try { g = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d") } catch (e) { } function v(e, t) { return g ? new OffscreenCanvas(e, t) : pl("canvas") } function y(e, t, n, i) { let r = 1; if ((e.width > i || e.height > i) && (r = i / Math.max(e.width, e.height)), r < 1 || !0 === t) { if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) { const i = t ? ll : Math.floor, s = i(r * e.width), a = i(r * e.height); void 0 === f && (f = v(s, a)); const o = n ? v(s, a) : f; return o.width = s, o.height = a, o.getContext("2d").drawImage(e, 0, 0, s, a), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + s + "x" + a + ")."), o } return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."), e } return e } function x(e) { return al(e.width) && al(e.height) } function _(e, t) { return e.generateMipmaps && t && e.minFilter !== _o && e.minFilter !== So } function w(t) { e.generateMipmap(t) } function b(n, i, r, s, a = !1) { if (!1 === o) return i; if (null !== n) { if (void 0 !== e[n]) return e[n]; console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'") } let l = i; return 6403 === i && (5126 === r && (l = 33326), 5131 === r && (l = 33325), 5121 === r && (l = 33321)), 33319 === i && (5126 === r && (l = 33328), 5131 === r && (l = 33327), 5121 === r && (l = 33323)), 6408 === i && (5126 === r && (l = 34836), 5131 === r && (l = 34842), 5121 === r && (l = s === Wo && !1 === a ? 35907 : 32856), 32819 === r && (l = 32854), 32820 === r && (l = 32855)), 33325 !== l && 33326 !== l && 33327 !== l && 33328 !== l && 34842 !== l && 34836 !== l || t.get("EXT_color_buffer_float"), l } function S(e, t, n) { return !0 === _(e, n) || e.isFramebufferTexture && e.minFilter !== _o && e.minFilter !== So ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1 } function E(e) { return e === _o || e === wo || e === bo ? 9728 : 9729 } function M(e) { const t = e.target; t.removeEventListener("dispose", M), function (e) { const t = i.get(e); if (void 0 === t.__webglInit) return; const n = e.source, r = m.get(n); if (r) { const i = r[t.__cacheKey]; i.usedTimes--, 0 === i.usedTimes && C(e), 0 === Object.keys(r).length && m.delete(n) } i.remove(e) }(t), t.isVideoTexture && p.delete(t) } function T(t) { const n = t.target; n.removeEventListener("dispose", T), function (t) { const n = t.texture, r = i.get(t), s = i.get(n); if (void 0 !== s.__webglTexture && (e.deleteTexture(s.__webglTexture), a.memory.textures--), t.depthTexture && t.depthTexture.dispose(), t.isWebGLCubeRenderTarget) for (let t = 0; t < 6; t++)e.deleteFramebuffer(r.__webglFramebuffer[t]), r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer[t]); else e.deleteFramebuffer(r.__webglFramebuffer), r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && e.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer && e.deleteRenderbuffer(r.__webglColorRenderbuffer), r.__webglDepthRenderbuffer && e.deleteRenderbuffer(r.__webglDepthRenderbuffer); if (t.isWebGLMultipleRenderTargets) for (let t = 0, r = n.length; t < r; t++) { const r = i.get(n[t]); r.__webglTexture && (e.deleteTexture(r.__webglTexture), a.memory.textures--), i.remove(n[t]) } i.remove(n), i.remove(t) }(n) } function C(t) { const n = i.get(t); e.deleteTexture(n.__webglTexture); const r = t.source; delete m.get(r)[n.__cacheKey], a.memory.textures-- } let D = 0; function L(e, t) { const r = i.get(e); if (e.isVideoTexture && function (e) { const t = a.render.frame; p.get(e) !== t && (p.set(e, t), e.update()) }(e), !1 === e.isRenderTargetTexture && e.version > 0 && r.__version !== e.version) { const n = e.image; if (null === n) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found."); else { if (!1 !== n.complete) return void I(r, e, t); console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete") } } n.activeTexture(33984 + t), n.bindTexture(3553, r.__webglTexture) } const A = { [vo]: 10497, [yo]: 33071, [xo]: 33648 }, P = { [_o]: 9728, [wo]: 9984, [bo]: 9986, [So]: 9729, 1007: 9985, [Eo]: 9987 }; function R(n, s, a) { if (a ? (e.texParameteri(n, 10242, A[s.wrapS]), e.texParameteri(n, 10243, A[s.wrapT]), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, A[s.wrapR]), e.texParameteri(n, 10240, P[s.magFilter]), e.texParameteri(n, 10241, P[s.minFilter])) : (e.texParameteri(n, 10242, 33071), e.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, 33071), s.wrapS === yo && s.wrapT === yo || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(n, 10240, E(s.magFilter)), e.texParameteri(n, 10241, E(s.minFilter)), s.minFilter !== _o && s.minFilter !== So && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === t.has("EXT_texture_filter_anisotropic")) { const a = t.get("EXT_texture_filter_anisotropic"); if (s.type === Do && !1 === t.has("OES_texture_float_linear")) return; if (!1 === o && s.type === Lo && !1 === t.has("OES_texture_half_float_linear")) return; (s.anisotropy > 1 || i.get(s).__currentAnisotropy) && (e.texParameterf(n, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())), i.get(s).__currentAnisotropy = s.anisotropy) } } function O(t, n) { let i = !1; void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener("dispose", M)); const r = n.source; let s = m.get(r); void 0 === s && (s = {}, m.set(r, s)); const o = function (e) { const t = []; return t.push(e.wrapS), t.push(e.wrapT), t.push(e.magFilter), t.push(e.minFilter), t.push(e.anisotropy), t.push(e.internalFormat), t.push(e.format), t.push(e.type), t.push(e.generateMipmaps), t.push(e.premultiplyAlpha), t.push(e.flipY), t.push(e.unpackAlignment), t.push(e.encoding), t.join() }(n); if (o !== t.__cacheKey) { void 0 === s[o] && (s[o] = { texture: e.createTexture(), usedTimes: 0 }, a.memory.textures++, i = !0), s[o].usedTimes++; const r = s[t.__cacheKey]; void 0 !== r && (s[t.__cacheKey].usedTimes--, 0 === r.usedTimes && C(n)), t.__cacheKey = o, t.__webglTexture = s[o].texture } return i } function I(t, i, r) { let a = 3553; i.isDataArrayTexture && (a = 35866), i.isData3DTexture && (a = 32879); const l = O(t, i), c = i.source; if (n.activeTexture(33984 + r), n.bindTexture(a, t.__webglTexture), c.version !== c.__currentVersion || !0 === l) { e.pixelStorei(37440, i.flipY), e.pixelStorei(37441, i.premultiplyAlpha), e.pixelStorei(3317, i.unpackAlignment), e.pixelStorei(37443, 0); const r = function (e) { return !o && (e.wrapS !== yo || e.wrapT !== yo || e.minFilter !== _o && e.minFilter !== So) }(i) && !1 === x(i.image); let l = y(i.image, r, !1, u); l = H(i, l); const h = x(l) || o, d = s.convert(i.format, i.encoding); let p, f = s.convert(i.type), m = b(i.internalFormat, d, f, i.encoding, i.isVideoTexture); R(a, i, h); const g = i.mipmaps, v = o && !0 !== i.isVideoTexture, E = void 0 === t.__version, M = S(i, l, h); if (i.isDepthTexture) m = 6402, o ? m = i.type === Do ? 36012 : i.type === Co ? 33190 : i.type === Ao ? 35056 : 33189 : i.type === Do && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i.format === Ro && 6402 === m && i.type !== To && i.type !== Co && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = To, f = s.convert(i.type)), i.format === Oo && 6402 === m && (m = 34041, i.type !== Ao && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = Ao, f = s.convert(i.type))), v && E ? n.texStorage2D(3553, 1, m, l.width, l.height) : n.texImage2D(3553, 0, m, l.width, l.height, 0, d, f, null); else if (i.isDataTexture) if (g.length > 0 && h) { v && E && n.texStorage2D(3553, M, m, g[0].width, g[0].height); for (let e = 0, t = g.length; e < t; e++)p = g[e], v ? n.texSubImage2D(3553, e, 0, 0, p.width, p.height, d, f, p.data) : n.texImage2D(3553, e, m, p.width, p.height, 0, d, f, p.data); i.generateMipmaps = !1 } else v ? (E && n.texStorage2D(3553, M, m, l.width, l.height), n.texSubImage2D(3553, 0, 0, 0, l.width, l.height, d, f, l.data)) : n.texImage2D(3553, 0, m, l.width, l.height, 0, d, f, l.data); else if (i.isCompressedTexture) { v && E && n.texStorage2D(3553, M, m, g[0].width, g[0].height); for (let e = 0, t = g.length; e < t; e++)p = g[e], i.format !== Po ? null !== d ? v ? n.compressedTexSubImage2D(3553, e, 0, 0, p.width, p.height, d, p.data) : n.compressedTexImage2D(3553, e, m, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : v ? n.texSubImage2D(3553, e, 0, 0, p.width, p.height, d, f, p.data) : n.texImage2D(3553, e, m, p.width, p.height, 0, d, f, p.data) } else if (i.isDataArrayTexture) v ? (E && n.texStorage3D(35866, M, m, l.width, l.height, l.depth), n.texSubImage3D(35866, 0, 0, 0, 0, l.width, l.height, l.depth, d, f, l.data)) : n.texImage3D(35866, 0, m, l.width, l.height, l.depth, 0, d, f, l.data); else if (i.isData3DTexture) v ? (E && n.texStorage3D(32879, M, m, l.width, l.height, l.depth), n.texSubImage3D(32879, 0, 0, 0, 0, l.width, l.height, l.depth, d, f, l.data)) : n.texImage3D(32879, 0, m, l.width, l.height, l.depth, 0, d, f, l.data); else if (i.isFramebufferTexture) v && E ? n.texStorage2D(3553, M, m, l.width, l.height) : n.texImage2D(3553, 0, m, l.width, l.height, 0, d, f, null); else if (g.length > 0 && h) { v && E && n.texStorage2D(3553, M, m, g[0].width, g[0].height); for (let e = 0, t = g.length; e < t; e++)p = g[e], v ? n.texSubImage2D(3553, e, 0, 0, d, f, p) : n.texImage2D(3553, e, m, d, f, p); i.generateMipmaps = !1 } else v ? (E && n.texStorage2D(3553, M, m, l.width, l.height), n.texSubImage2D(3553, 0, 0, 0, d, f, l)) : n.texImage2D(3553, 0, m, d, f, l); _(i, h) && w(a), c.__currentVersion = c.version, i.onUpdate && i.onUpdate(i) } t.__version = i.version } function F(t, r, a, o, l) { const c = s.convert(a.format, a.encoding), u = s.convert(a.type), h = b(a.internalFormat, c, u, a.encoding); i.get(r).__hasExternalTextures || (32879 === l || 35866 === l ? n.texImage3D(l, 0, h, r.width, r.height, r.depth, 0, c, u, null) : n.texImage2D(l, 0, h, r.width, r.height, 0, c, u, null)), n.bindFramebuffer(36160, t), B(r) ? d.framebufferTexture2DMultisampleEXT(36160, o, l, i.get(a).__webglTexture, 0, N(r)) : e.framebufferTexture2D(36160, o, l, i.get(a).__webglTexture, 0), n.bindFramebuffer(36160, null) } function z(t, n, i) { if (e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer) { let r = 33189; if (i || B(n)) { const t = n.depthTexture; t && t.isDepthTexture && (t.type === Do ? r = 36012 : t.type === Co && (r = 33190)); const i = N(n); B(n) ? d.renderbufferStorageMultisampleEXT(36161, i, r, n.width, n.height) : e.renderbufferStorageMultisample(36161, i, r, n.width, n.height) } else e.renderbufferStorage(36161, r, n.width, n.height); e.framebufferRenderbuffer(36160, 36096, 36161, t) } else if (n.depthBuffer && n.stencilBuffer) { const r = N(n); i && !1 === B(n) ? e.renderbufferStorageMultisample(36161, r, 35056, n.width, n.height) : B(n) ? d.renderbufferStorageMultisampleEXT(36161, r, 35056, n.width, n.height) : e.renderbufferStorage(36161, 34041, n.width, n.height), e.framebufferRenderbuffer(36160, 33306, 36161, t) } else { const t = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture, r = s.convert(t.format, t.encoding), a = s.convert(t.type), o = b(t.internalFormat, r, a, t.encoding), l = N(n); i && !1 === B(n) ? e.renderbufferStorageMultisample(36161, l, o, n.width, n.height) : B(n) ? d.renderbufferStorageMultisampleEXT(36161, l, o, n.width, n.height) : e.renderbufferStorage(36161, o, n.width, n.height) } e.bindRenderbuffer(36161, null) } function k(t) { const r = i.get(t), s = !0 === t.isWebGLCubeRenderTarget; if (t.depthTexture && !r.__autoAllocateDepthBuffer) { if (s) throw new Error("target.depthTexture not supported in Cube render targets"); !function (t, r) { if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported"); if (n.bindFramebuffer(36160, t), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), L(r.depthTexture, 0); const s = i.get(r.depthTexture).__webglTexture, a = N(r); if (r.depthTexture.format === Ro) B(r) ? d.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, s, 0, a) : e.framebufferTexture2D(36160, 36096, 3553, s, 0); else { if (r.depthTexture.format !== Oo) throw new Error("Unknown depthTexture format"); B(r) ? d.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, s, 0, a) : e.framebufferTexture2D(36160, 33306, 3553, s, 0) } }(r.__webglFramebuffer, t) } else if (s) { r.__webglDepthbuffer = []; for (let i = 0; i < 6; i++)n.bindFramebuffer(36160, r.__webglFramebuffer[i]), r.__webglDepthbuffer[i] = e.createRenderbuffer(), z(r.__webglDepthbuffer[i], t, !1) } else n.bindFramebuffer(36160, r.__webglFramebuffer), r.__webglDepthbuffer = e.createRenderbuffer(), z(r.__webglDepthbuffer, t, !1); n.bindFramebuffer(36160, null) } function N(e) { return Math.min(h, e.samples) } function B(e) { const n = i.get(e); return o && e.samples > 0 && !0 === t.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture } function H(e, n) { const i = e.encoding, r = e.format, s = e.type; return !0 === e.isCompressedTexture || !0 === e.isVideoTexture || e.format === Zo || i !== jo && (i === Wo ? !1 === o ? !0 === t.has("EXT_sRGB") && r === Po ? (e.format = Zo, e.minFilter = So, e.generateMipmaps = !1) : n = bl.sRGBToLinear(n) : r === Po && s === Mo || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", i)), n } this.allocateTextureUnit = function () { const e = D; return e >= l && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + l), D += 1, e }, this.resetTextureUnits = function () { D = 0 }, this.setTexture2D = L, this.setTexture2DArray = function (e, t) { const r = i.get(e); e.version > 0 && r.__version !== e.version ? I(r, e, t) : (n.activeTexture(33984 + t), n.bindTexture(35866, r.__webglTexture)) }, this.setTexture3D = function (e, t) { const r = i.get(e); e.version > 0 && r.__version !== e.version ? I(r, e, t) : (n.activeTexture(33984 + t), n.bindTexture(32879, r.__webglTexture)) }, this.setTextureCube = function (t, r) { const a = i.get(t); t.version > 0 && a.__version !== t.version ? function (t, i, r) { if (6 !== i.image.length) return; const a = O(t, i), l = i.source; if (n.activeTexture(33984 + r), n.bindTexture(34067, t.__webglTexture), l.version !== l.__currentVersion || !0 === a) { e.pixelStorei(37440, i.flipY), e.pixelStorei(37441, i.premultiplyAlpha), e.pixelStorei(3317, i.unpackAlignment), e.pixelStorei(37443, 0); const r = i.isCompressedTexture || i.image[0].isCompressedTexture, a = i.image[0] && i.image[0].isDataTexture, u = []; for (let e = 0; e < 6; e++)u[e] = r || a ? a ? i.image[e].image : i.image[e] : y(i.image[e], !1, !0, c), u[e] = H(i, u[e]); const h = u[0], d = x(h) || o, p = s.convert(i.format, i.encoding), f = s.convert(i.type), m = b(i.internalFormat, p, f, i.encoding), g = o && !0 !== i.isVideoTexture, v = void 0 === t.__version; let E, M = S(i, h, d); if (R(34067, i, d), r) { g && v && n.texStorage2D(34067, M, m, h.width, h.height); for (let e = 0; e < 6; e++) { E = u[e].mipmaps; for (let t = 0; t < E.length; t++) { const r = E[t]; i.format !== Po ? null !== p ? g ? n.compressedTexSubImage2D(34069 + e, t, 0, 0, r.width, r.height, p, r.data) : n.compressedTexImage2D(34069 + e, t, m, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : g ? n.texSubImage2D(34069 + e, t, 0, 0, r.width, r.height, p, f, r.data) : n.texImage2D(34069 + e, t, m, r.width, r.height, 0, p, f, r.data) } } } else { E = i.mipmaps, g && v && (E.length > 0 && M++, n.texStorage2D(34067, M, m, u[0].width, u[0].height)); for (let e = 0; e < 6; e++)if (a) { g ? n.texSubImage2D(34069 + e, 0, 0, 0, u[e].width, u[e].height, p, f, u[e].data) : n.texImage2D(34069 + e, 0, m, u[e].width, u[e].height, 0, p, f, u[e].data); for (let t = 0; t < E.length; t++) { const i = E[t].image[e].image; g ? n.texSubImage2D(34069 + e, t + 1, 0, 0, i.width, i.height, p, f, i.data) : n.texImage2D(34069 + e, t + 1, m, i.width, i.height, 0, p, f, i.data) } } else { g ? n.texSubImage2D(34069 + e, 0, 0, 0, p, f, u[e]) : n.texImage2D(34069 + e, 0, m, p, f, u[e]); for (let t = 0; t < E.length; t++) { const i = E[t]; g ? n.texSubImage2D(34069 + e, t + 1, 0, 0, p, f, i.image[e]) : n.texImage2D(34069 + e, t + 1, m, p, f, i.image[e]) } } } _(i, d) && w(34067), l.__currentVersion = l.version, i.onUpdate && i.onUpdate(i) } t.__version = i.version }(a, t, r) : (n.activeTexture(33984 + r), n.bindTexture(34067, a.__webglTexture)) }, this.rebindTextures = function (e, t, n) { const r = i.get(e); void 0 !== t && F(r.__webglFramebuffer, e, e.texture, 36064, 3553), void 0 !== n && k(e) }, this.setupRenderTarget = function (t) { const l = t.texture, c = i.get(t), u = i.get(l); t.addEventListener("dispose", T), !0 !== t.isWebGLMultipleRenderTargets && (void 0 === u.__webglTexture && (u.__webglTexture = e.createTexture()), u.__version = l.version, a.memory.textures++); const h = !0 === t.isWebGLCubeRenderTarget, d = !0 === t.isWebGLMultipleRenderTargets, p = x(t) || o; if (h) { c.__webglFramebuffer = []; for (let t = 0; t < 6; t++)c.__webglFramebuffer[t] = e.createFramebuffer() } else if (c.__webglFramebuffer = e.createFramebuffer(), d) if (r.drawBuffers) { const n = t.texture; for (let t = 0, r = n.length; t < r; t++) { const r = i.get(n[t]); void 0 === r.__webglTexture && (r.__webglTexture = e.createTexture(), a.memory.textures++) } } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."); else if (o && t.samples > 0 && !1 === B(t)) { c.__webglMultisampledFramebuffer = e.createFramebuffer(), c.__webglColorRenderbuffer = e.createRenderbuffer(), e.bindRenderbuffer(36161, c.__webglColorRenderbuffer); const i = s.convert(l.format, l.encoding), r = s.convert(l.type), a = b(l.internalFormat, i, r, l.encoding), o = N(t); e.renderbufferStorageMultisample(36161, o, a, t.width, t.height), n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064, 36161, c.__webglColorRenderbuffer), e.bindRenderbuffer(36161, null), t.depthBuffer && (c.__webglDepthRenderbuffer = e.createRenderbuffer(), z(c.__webglDepthRenderbuffer, t, !0)), n.bindFramebuffer(36160, null) } if (h) { n.bindTexture(34067, u.__webglTexture), R(34067, l, p); for (let e = 0; e < 6; e++)F(c.__webglFramebuffer[e], t, l, 36064, 34069 + e); _(l, p) && w(34067), n.unbindTexture() } else if (d) { const e = t.texture; for (let r = 0, s = e.length; r < s; r++) { const s = e[r], a = i.get(s); n.bindTexture(3553, a.__webglTexture), R(3553, s, p), F(c.__webglFramebuffer, t, s, 36064 + r, 3553), _(s, p) && w(3553) } n.unbindTexture() } else { let e = 3553; (t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (o ? e = t.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), n.bindTexture(e, u.__webglTexture), R(e, l, p), F(c.__webglFramebuffer, t, l, 36064, e), _(l, p) && w(e), n.unbindTexture() } t.depthBuffer && k(t) }, this.updateRenderTargetMipmap = function (e) { const t = x(e) || o, r = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture]; for (let s = 0, a = r.length; s < a; s++) { const a = r[s]; if (_(a, t)) { const t = e.isWebGLCubeRenderTarget ? 34067 : 3553, r = i.get(a).__webglTexture; n.bindTexture(t, r), w(t), n.unbindTexture() } } }, this.updateMultisampleRenderTarget = function (t) { if (o && t.samples > 0 && !1 === B(t)) { const r = t.width, s = t.height; let a = 16384; const o = [36064], l = t.stencilBuffer ? 33306 : 36096; t.depthBuffer && o.push(l); const c = i.get(t), u = void 0 !== c.__ignoreDepthValues && c.__ignoreDepthValues; !1 === u && (t.depthBuffer && (a |= 256), t.stencilBuffer && (a |= 1024)), n.bindFramebuffer(36008, c.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, c.__webglFramebuffer), !0 === u && (e.invalidateFramebuffer(36008, [l]), e.invalidateFramebuffer(36009, [l])), e.blitFramebuffer(0, 0, r, s, 0, 0, r, s, a, 9728), e.invalidateFramebuffer(36008, o), n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, c.__webglMultisampledFramebuffer) } }, this.setupDepthRenderbuffer = k, this.setupFrameBufferTexture = F, this.useMultisampledRTT = B } function mp(e, t, n) { const i = n.isWebGL2; return { convert: function (e, n = null) { let r; if (e === Mo) return 5121; if (1017 === e) return 32819; if (1018 === e) return 32820; if (1010 === e) return 5120; if (1011 === e) return 5122; if (e === To) return 5123; if (1013 === e) return 5124; if (e === Co) return 5125; if (e === Do) return 5126; if (e === Lo) return i ? 5131 : (r = t.get("OES_texture_half_float"), null !== r ? r.HALF_FLOAT_OES : null); if (1021 === e) return 6406; if (e === Po) return 6408; if (1024 === e) return 6409; if (1025 === e) return 6410; if (e === Ro) return 6402; if (e === Oo) return 34041; if (1028 === e) return 6403; if (1022 === e) return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"), 6408; if (e === Zo) return r = t.get("EXT_sRGB"), null !== r ? r.SRGB_ALPHA_EXT : null; if (1029 === e) return 36244; if (1030 === e) return 33319; if (1031 === e) return 33320; if (1033 === e) return 36249; if (e === Io || e === Fo || e === zo || e === ko) if (n === Wo) { if (r = t.get("WEBGL_compressed_texture_s3tc_srgb"), null === r) return null; if (e === Io) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT; if (e === Fo) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT; if (e === zo) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT; if (e === ko) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT } else { if (r = t.get("WEBGL_compressed_texture_s3tc"), null === r) return null; if (e === Io) return r.COMPRESSED_RGB_S3TC_DXT1_EXT; if (e === Fo) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (e === zo) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (e === ko) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT } if (35840 === e || 35841 === e || 35842 === e || 35843 === e) { if (r = t.get("WEBGL_compressed_texture_pvrtc"), null === r) return null; if (35840 === e) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (35841 === e) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (35842 === e) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (35843 === e) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (36196 === e) return r = t.get("WEBGL_compressed_texture_etc1"), null !== r ? r.COMPRESSED_RGB_ETC1_WEBGL : null; if (37492 === e || 37496 === e) { if (r = t.get("WEBGL_compressed_texture_etc"), null === r) return null; if (37492 === e) return n === Wo ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2; if (37496 === e) return n === Wo ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC } if (37808 === e || 37809 === e || 37810 === e || 37811 === e || 37812 === e || 37813 === e || 37814 === e || 37815 === e || 37816 === e || 37817 === e || 37818 === e || 37819 === e || 37820 === e || 37821 === e) { if (r = t.get("WEBGL_compressed_texture_astc"), null === r) return null; if (37808 === e) return n === Wo ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR; if (37809 === e) return n === Wo ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR; if (37810 === e) return n === Wo ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR; if (37811 === e) return n === Wo ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR; if (37812 === e) return n === Wo ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR; if (37813 === e) return n === Wo ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR; if (37814 === e) return n === Wo ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR; if (37815 === e) return n === Wo ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR; if (37816 === e) return n === Wo ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR; if (37817 === e) return n === Wo ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR; if (37818 === e) return n === Wo ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR; if (37819 === e) return n === Wo ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR; if (37820 === e) return n === Wo ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR; if (37821 === e) return n === Wo ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR } if (36492 === e) { if (r = t.get("EXT_texture_compression_bptc"), null === r) return null; if (36492 === e) return n === Wo ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT } return e === Ao ? i ? 34042 : (r = t.get("WEBGL_depth_texture"), null !== r ? r.UNSIGNED_INT_24_8_WEBGL : null) : void 0 } } } hp.prototype.isMeshDistanceMaterial = !0; class gp extends Iu { constructor(e = []) { super(), this.cameras = e } } gp.prototype.isArrayCamera = !0; class vp extends Ic { constructor() { super(), this.type = "Group" } } vp.prototype.isGroup = !0; const yp = { type: "move" }; class xp { constructor() { this._targetRay = null, this._grip = null, this._hand = null } getHandSpace() { return null === this._hand && (this._hand = new vp, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand } getTargetRaySpace() { return null === this._targetRay && (this._targetRay = new vp, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Rl, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Rl), this._targetRay } getGripSpace() { return null === this._grip && (this._grip = new vp, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Rl, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Rl), this._grip } dispatchEvent(e) { return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this } disconnect(e) { return this.dispatchEvent({ type: "disconnected", data: e }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this } update(e, t, n) { let i = null, r = null, s = null; const a = this._targetRay, o = this._grip, l = this._hand; if (e && "visible-blurred" !== t.session.visibilityState) if (null !== a && (i = t.getPose(e.targetRaySpace, n), null !== i && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(yp))), l && e.hand) { s = !0; for (const i of e.hand.values()) { const e = t.getJointPose(i, n); if (void 0 === l.joints[i.jointName]) { const e = new vp; e.matrixAutoUpdate = !1, e.visible = !1, l.joints[i.jointName] = e, l.add(e) } const r = l.joints[i.jointName]; null !== e && (r.matrix.fromArray(e.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.jointRadius = e.radius), r.visible = null !== e } const i = l.joints["index-finger-tip"], r = l.joints["thumb-tip"], a = i.position.distanceTo(r.position), o = .02, c = .005; l.inputState.pinching && a > o + c ? (l.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: e.handedness, target: this })) : !l.inputState.pinching && a <= o - c && (l.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: e.handedness, target: this })) } else null !== o && e.gripSpace && (r = t.getPose(e.gripSpace, n), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1)); return null !== a && (a.visible = null !== i), null !== o && (o.visible = null !== r), null !== l && (l.visible = null !== s), this } } class _p extends Tl { constructor(e, t, n, i, r, s, a, o, l, c) { if ((c = void 0 !== c ? c : Ro) !== Ro && c !== Oo) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); void 0 === n && c === Ro && (n = To), void 0 === n && c === Oo && (n = Ao), super(null, i, r, s, a, o, c, n, l), this.image = { width: e, height: t }, this.magFilter = void 0 !== a ? a : _o, this.minFilter = void 0 !== o ? o : _o, this.flipY = !1, this.generateMipmaps = !1 } } _p.prototype.isDepthTexture = !0; class wp extends Ko { constructor(e, t) { super(); const n = this; let i = null, r = 1, s = null, a = "local-floor", o = null, l = null, c = null, u = null, h = null; const d = t.getContextAttributes(); let p = null, f = null; const m = [], g = new Map, v = new Iu; v.layers.enable(1), v.viewport = new Cl; const y = new Iu; y.layers.enable(2), y.viewport = new Cl; const x = [v, y], _ = new gp; _.layers.enable(1), _.layers.enable(2); let w = null, b = null; function S(e) { const t = g.get(e.inputSource); t && t.dispatchEvent({ type: e.type, data: e.inputSource }) } function E() { g.forEach((function (e, t) { e.disconnect(t) })), g.clear(), w = null, b = null, e.setRenderTarget(p), u = null, c = null, l = null, i = null, f = null, A.stop(), n.isPresenting = !1, n.dispatchEvent({ type: "sessionend" }) } function M(e) { const t = i.inputSources; for (let e = 0; e < m.length; e++)g.set(t[e], m[e]); for (let t = 0; t < e.removed.length; t++) { const n = e.removed[t], i = g.get(n); i && (i.dispatchEvent({ type: "disconnected", data: n }), g.delete(n)) } for (let t = 0; t < e.added.length; t++) { const n = e.added[t], i = g.get(n); i && i.dispatchEvent({ type: "connected", data: n }) } } this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (e) { let t = m[e]; return void 0 === t && (t = new xp, m[e] = t), t.getTargetRaySpace() }, this.getControllerGrip = function (e) { let t = m[e]; return void 0 === t && (t = new xp, m[e] = t), t.getGripSpace() }, this.getHand = function (e) { let t = m[e]; return void 0 === t && (t = new xp, m[e] = t), t.getHandSpace() }, this.setFramebufferScaleFactor = function (e) { r = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function (e) { a = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function () { return s }, this.getBaseLayer = function () { return null !== c ? c : u }, this.getBinding = function () { return l }, this.getFrame = function () { return h }, this.getSession = function () { return i }, this.setSession = async function (o) { if (i = o, null !== i) { if (p = e.getRenderTarget(), i.addEventListener("select", S), i.addEventListener("selectstart", S), i.addEventListener("selectend", S), i.addEventListener("squeeze", S), i.addEventListener("squeezestart", S), i.addEventListener("squeezeend", S), i.addEventListener("end", E), i.addEventListener("inputsourceschange", M), !0 !== d.xrCompatible && await t.makeXRCompatible(), void 0 === i.renderState.layers || !1 === e.capabilities.isWebGL2) { const n = { antialias: void 0 !== i.renderState.layers || d.antialias, alpha: d.alpha, depth: d.depth, stencil: d.stencil, framebufferScaleFactor: r }; u = new XRWebGLLayer(i, t, n), i.updateRenderState({ baseLayer: u }), f = new Dl(u.framebufferWidth, u.framebufferHeight, { format: Po, type: Mo, encoding: e.outputEncoding }) } else { let n = null, s = null, a = null; d.depth && (a = d.stencil ? 35056 : 33190, n = d.stencil ? Oo : Ro, s = d.stencil ? Ao : To); const o = { colorFormat: e.outputEncoding === Wo ? 35907 : 32856, depthFormat: a, scaleFactor: r }; l = new XRWebGLBinding(i, t), c = l.createProjectionLayer(o), i.updateRenderState({ layers: [c] }), f = new Dl(c.textureWidth, c.textureHeight, { format: Po, type: Mo, depthTexture: new _p(c.textureWidth, c.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, n), stencilBuffer: d.stencil, encoding: e.outputEncoding, samples: d.antialias ? 4 : 0 }), e.properties.get(f).__ignoreDepthValues = c.ignoreDepthValues } f.isXRRenderTarget = !0, this.setFoveation(1), s = await i.requestReferenceSpace(a), A.setContext(i), A.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" }) } }; const T = new Rl, C = new Rl; function D(e, t) { null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert() } this.updateCamera = function (e) { if (null === i) return; _.near = y.near = v.near = e.near, _.far = y.far = v.far = e.far, w === _.near && b === _.far || (i.updateRenderState({ depthNear: _.near, depthFar: _.far }), w = _.near, b = _.far); const t = e.parent, n = _.cameras; D(_, t); for (let e = 0; e < n.length; e++)D(n[e], t); _.matrixWorld.decompose(_.position, _.quaternion, _.scale), e.position.copy(_.position), e.quaternion.copy(_.quaternion), e.scale.copy(_.scale), e.matrix.copy(_.matrix), e.matrixWorld.copy(_.matrixWorld); const r = e.children; for (let e = 0, t = r.length; e < t; e++)r[e].updateMatrixWorld(!0); 2 === n.length ? function (e, t, n) { T.setFromMatrixPosition(t.matrixWorld), C.setFromMatrixPosition(n.matrixWorld); const i = T.distanceTo(C), r = t.projectionMatrix.elements, s = n.projectionMatrix.elements, a = r[14] / (r[10] - 1), o = r[14] / (r[10] + 1), l = (r[9] + 1) / r[5], c = (r[9] - 1) / r[5], u = (r[8] - 1) / r[0], h = (s[8] + 1) / s[0], d = a * u, p = a * h, f = i / (-u + h), m = f * -u; t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(m), e.translateZ(f), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert(); const g = a + f, v = o + f, y = d - m, x = p + (i - m), _ = l * o / v * g, w = c * o / v * g; e.projectionMatrix.makePerspective(y, x, _, w, g, v) }(_, v, y) : _.projectionMatrix.copy(v.projectionMatrix) }, this.getCamera = function () { return _ }, this.getFoveation = function () { return null !== c ? c.fixedFoveation : null !== u ? u.fixedFoveation : void 0 }, this.setFoveation = function (e) { null !== c && (c.fixedFoveation = e), null !== u && void 0 !== u.fixedFoveation && (u.fixedFoveation = e) }; let L = null; const A = new qu; A.setAnimationLoop((function (t, n) { if (o = n.getViewerPose(s), h = n, null !== o) { const t = o.views; null !== u && (e.setRenderTargetFramebuffer(f, u.framebuffer), e.setRenderTarget(f)); let n = !1; t.length !== _.cameras.length && (_.cameras.length = 0, n = !0); for (let i = 0; i < t.length; i++) { const r = t[i]; let s = null; if (null !== u) s = u.getViewport(r); else { const t = l.getViewSubImage(c, r); s = t.viewport, 0 === i && (e.setRenderTargetTextures(f, t.colorTexture, c.ignoreDepthValues ? void 0 : t.depthStencilTexture), e.setRenderTarget(f)) } const a = x[i]; a.matrix.fromArray(r.transform.matrix), a.projectionMatrix.fromArray(r.projectionMatrix), a.viewport.set(s.x, s.y, s.width, s.height), 0 === i && _.matrix.copy(a.matrix), !0 === n && _.cameras.push(a) } } const r = i.inputSources; for (let e = 0; e < m.length; e++) { const t = m[e], i = r[e]; t.update(i, n, s) } L && L(t, n), h = null })), this.setAnimationLoop = function (e) { L = e }, this.dispose = function () { } } } function bp(e) { function t(t, n) { t.opacity.value = n.opacity, n.color && t.diffuse.value.copy(n.color), n.emissive && t.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (t.map.value = n.map), n.alphaMap && (t.alphaMap.value = n.alphaMap), n.specularMap && (t.specularMap.value = n.specularMap), n.alphaTest > 0 && (t.alphaTest.value = n.alphaTest); const i = e.get(n).envMap; let r, s; i && (t.envMap.value = i, t.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1, t.reflectivity.value = n.reflectivity, t.ior.value = n.ior, t.refractionRatio.value = n.refractionRatio), n.lightMap && (t.lightMap.value = n.lightMap, t.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (t.aoMap.value = n.aoMap, t.aoMapIntensity.value = n.aoMapIntensity), n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap ? r = n.clearcoatRoughnessMap : n.specularIntensityMap ? r = n.specularIntensityMap : n.specularColorMap ? r = n.specularColorMap : n.transmissionMap ? r = n.transmissionMap : n.thicknessMap ? r = n.thicknessMap : n.sheenColorMap ? r = n.sheenColorMap : n.sheenRoughnessMap && (r = n.sheenRoughnessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix)), n.aoMap ? s = n.aoMap : n.lightMap && (s = n.lightMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), t.uv2Transform.value.copy(s.matrix)) } function n(t, n) { t.roughness.value = n.roughness, t.metalness.value = n.metalness, n.roughnessMap && (t.roughnessMap.value = n.roughnessMap), n.metalnessMap && (t.metalnessMap.value = n.metalnessMap), n.emissiveMap && (t.emissiveMap.value = n.emissiveMap), n.bumpMap && (t.bumpMap.value = n.bumpMap, t.bumpScale.value = n.bumpScale, 1 === n.side && (t.bumpScale.value *= -1)), n.normalMap && (t.normalMap.value = n.normalMap, t.normalScale.value.copy(n.normalScale), 1 === n.side && t.normalScale.value.negate()), n.displacementMap && (t.displacementMap.value = n.displacementMap, t.displacementScale.value = n.displacementScale, t.displacementBias.value = n.displacementBias), e.get(n).envMap && (t.envMapIntensity.value = n.envMapIntensity) } return { refreshFogUniforms: function (e, t) { e.fogColor.value.copy(t.color), t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density) }, refreshMaterialUniforms: function (e, i, r, s, a) { i.isMeshBasicMaterial ? t(e, i) : i.isMeshLambertMaterial ? (t(e, i), function (e, t) { t.emissiveMap && (e.emissiveMap.value = t.emissiveMap) }(e, i)) : i.isMeshToonMaterial ? (t(e, i), function (e, t) { t.gradientMap && (e.gradientMap.value = t.gradientMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, i)) : i.isMeshPhongMaterial ? (t(e, i), function (e, t) { e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, i)) : i.isMeshStandardMaterial ? (t(e, i), i.isMeshPhysicalMaterial ? function (e, t, i) { n(e, t), e.ior.value = t.ior, t.sheen > 0 && (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen), e.sheenRoughness.value = t.sheenRoughness, t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap), t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap)), t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap), t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap), t.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), e.clearcoatNormalMap.value = t.clearcoatNormalMap, 1 === t.side && e.clearcoatNormalScale.value.negate())), t.transmission > 0 && (e.transmission.value = t.transmission, e.transmissionSamplerMap.value = i.texture, e.transmissionSamplerSize.value.set(i.width, i.height), t.transmissionMap && (e.transmissionMap.value = t.transmissionMap), e.thickness.value = t.thickness, t.thicknessMap && (e.thicknessMap.value = t.thicknessMap), e.attenuationDistance.value = t.attenuationDistance, e.attenuationColor.value.copy(t.attenuationColor)), e.specularIntensity.value = t.specularIntensity, e.specularColor.value.copy(t.specularColor), t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap), t.specularColorMap && (e.specularColorMap.value = t.specularColorMap) }(e, i, a) : n(e, i)) : i.isMeshMatcapMaterial ? (t(e, i), function (e, t) { t.matcap && (e.matcap.value = t.matcap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, i)) : i.isMeshDepthMaterial ? (t(e, i), function (e, t) { t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, i)) : i.isMeshDistanceMaterial ? (t(e, i), function (e, t) { t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance }(e, i)) : i.isMeshNormalMaterial ? (t(e, i), function (e, t) { t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, i)) : i.isLineBasicMaterial ? (function (e, t) { e.diffuse.value.copy(t.color), e.opacity.value = t.opacity }(e, i), i.isLineDashedMaterial && function (e, t) { e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale }(e, i)) : i.isPointsMaterial ? function (e, t, n, i) { let r; e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * n, e.scale.value = .5 * i, t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest), t.map ? r = t.map : t.alphaMap && (r = t.alphaMap), void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix)) }(e, i, r, s) : i.isSpriteMaterial ? function (e, t) { let n; e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest), t.map ? n = t.map : t.alphaMap && (n = t.alphaMap), void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix)) }(e, i) : i.isShadowMaterial ? (e.color.value.copy(i.color), e.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1) } } } function Sp(e = {}) { const t = void 0 !== e.canvas ? e.canvas : function () { const e = pl("canvas"); return e.style.display = "block", e }(), n = void 0 !== e.context ? e.context : null, i = void 0 === e.depth || e.depth, r = void 0 === e.stencil || e.stencil, s = void 0 !== e.antialias && e.antialias, a = void 0 === e.premultipliedAlpha || e.premultipliedAlpha, o = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer, l = void 0 !== e.powerPreference ? e.powerPreference : "default", c = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat; let u; u = void 0 !== e.context ? n.getContextAttributes().alpha : void 0 !== e.alpha && e.alpha; let h = null, d = null; const p = [], f = []; this.domElement = t, this.debug = { checkShaderErrors: !0 }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = jo, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1; const m = this; let g = !1, v = 0, y = 0, x = null, _ = -1, w = null; const b = new Cl, S = new Cl; let E = null, M = t.width, T = t.height, C = 1, D = null, L = null; const A = new Cl(0, 0, M, T), P = new Cl(0, 0, M, T); let R = !1; const O = new Wu; let I = !1, F = !1, z = null; const k = new cc, N = new ul, B = new Rl, H = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }; function U() { return null === x ? C : 1 } let V, G, j, W, q, $, X, Y, Z, K, J, Q, ee, te, ne, ie, re, se, ae, oe, le, ce, ue, he = n; function de(e, n) { for (let i = 0; i < e.length; i++) { const r = e[i], s = t.getContext(r, n); if (null !== s) return s } return null } try { const e = { alpha: !0, depth: i, stencil: r, antialias: s, premultipliedAlpha: a, preserveDrawingBuffer: o, powerPreference: l, failIfMajorPerformanceCaveat: c }; if ("setAttribute" in t && t.setAttribute("data-engine", "three.js r138"), t.addEventListener("webglcontextlost", me, !1), t.addEventListener("webglcontextrestored", ge, !1), null === he) { const t = ["webgl2", "webgl", "experimental-webgl"]; if (!0 === m.isWebGL1Renderer && t.shift(), he = de(t, e), null === he) throw de(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") } void 0 === he.getShaderPrecisionFormat && (he.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }) } catch (e) { throw console.error("THREE.WebGLRenderer: " + e.message), e } function pe() { V = new yh(he), G = new th(he, V, e), V.init(G), ce = new mp(he, V, G), j = new pp(he, V, G), W = new wh(he), q = new Qd, $ = new fp(he, V, j, q, G, ce, W), X = new ih(m), Y = new vh(m), Z = new $u(he, G), ue = new Qu(he, V, Z, G), K = new xh(he, Z, W, ue), J = new Th(he, K, Z, W), ae = new Mh(he, G, $), ie = new nh(q), Q = new Jd(m, X, Y, V, G, ue, ie), ee = new bp(q), te = new ip, ne = new cp(V, G), se = new Ju(m, X, j, J, u, a), re = new dp(m, J, G), oe = new eh(he, V, W, G), le = new _h(he, V, W, G), W.programs = Q.programs, m.capabilities = G, m.extensions = V, m.properties = q, m.renderLists = te, m.shadowMap = re, m.state = j, m.info = W } pe(); const fe = new wp(m, he); function me(e) { e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), g = !0 } function ge() { console.log("THREE.WebGLRenderer: Context Restored."), g = !1; const e = W.autoReset, t = re.enabled, n = re.autoUpdate, i = re.needsUpdate, r = re.type; pe(), W.autoReset = e, re.enabled = t, re.autoUpdate = n, re.needsUpdate = i, re.type = r } function ve(e) { const t = e.target; t.removeEventListener("dispose", ve), function (e) { (function (e) { const t = q.get(e).programs; void 0 !== t && (t.forEach((function (e) { Q.releaseProgram(e) })), e.isShaderMaterial && Q.releaseShaderCache(e)) })(e), q.remove(e) }(t) } this.xr = fe, this.getContext = function () { return he }, this.getContextAttributes = function () { return he.getContextAttributes() }, this.forceContextLoss = function () { const e = V.get("WEBGL_lose_context"); e && e.loseContext() }, this.forceContextRestore = function () { const e = V.get("WEBGL_lose_context"); e && e.restoreContext() }, this.getPixelRatio = function () { return C }, this.setPixelRatio = function (e) { void 0 !== e && (C = e, this.setSize(M, T, !1)) }, this.getSize = function (e) { return e.set(M, T) }, this.setSize = function (e, n, i) { fe.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (M = e, T = n, t.width = Math.floor(e * C), t.height = Math.floor(n * C), !1 !== i && (t.style.width = e + "px", t.style.height = n + "px"), this.setViewport(0, 0, e, n)) }, this.getDrawingBufferSize = function (e) { return e.set(M * C, T * C).floor() }, this.setDrawingBufferSize = function (e, n, i) { M = e, T = n, C = i, t.width = Math.floor(e * i), t.height = Math.floor(n * i), this.setViewport(0, 0, e, n) }, this.getCurrentViewport = function (e) { return e.copy(b) }, this.getViewport = function (e) { return e.copy(A) }, this.setViewport = function (e, t, n, i) { e.isVector4 ? A.set(e.x, e.y, e.z, e.w) : A.set(e, t, n, i), j.viewport(b.copy(A).multiplyScalar(C).floor()) }, this.getScissor = function (e) { return e.copy(P) }, this.setScissor = function (e, t, n, i) { e.isVector4 ? P.set(e.x, e.y, e.z, e.w) : P.set(e, t, n, i), j.scissor(S.copy(P).multiplyScalar(C).floor()) }, this.getScissorTest = function () { return R }, this.setScissorTest = function (e) { j.setScissorTest(R = e) }, this.setOpaqueSort = function (e) { D = e }, this.setTransparentSort = function (e) { L = e }, this.getClearColor = function (e) { return e.copy(se.getClearColor()) }, this.setClearColor = function () { se.setClearColor.apply(se, arguments) }, this.getClearAlpha = function () { return se.getClearAlpha() }, this.setClearAlpha = function () { se.setClearAlpha.apply(se, arguments) }, this.clear = function (e = !0, t = !0, n = !0) { let i = 0; e && (i |= 16384), t && (i |= 256), n && (i |= 1024), he.clear(i) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { t.removeEventListener("webglcontextlost", me, !1), t.removeEventListener("webglcontextrestored", ge, !1), te.dispose(), ne.dispose(), q.dispose(), X.dispose(), Y.dispose(), J.dispose(), ue.dispose(), Q.dispose(), fe.dispose(), fe.removeEventListener("sessionstart", xe), fe.removeEventListener("sessionend", _e), z && (z.dispose(), z = null), we.stop() }, this.renderBufferDirect = function (e, t, n, i, r, s) { null === t && (t = H); const a = r.isMesh && r.matrixWorld.determinant() < 0, o = function (e, t, n, i, r) { !0 !== t.isScene && (t = H), $.resetTextureUnits(); const s = t.fog, a = i.isMeshStandardMaterial ? t.environment : null, o = null === x ? m.outputEncoding : !0 === x.isXRRenderTarget ? x.texture.encoding : jo, l = (i.isMeshStandardMaterial ? Y : X).get(i.envMap || a), c = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize, u = !!i.normalMap && !!n.attributes.tangent, h = !!n.morphAttributes.position, p = !!n.morphAttributes.normal, f = !!n.morphAttributes.color, g = i.toneMapped ? m.toneMapping : 0, v = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color, y = void 0 !== v ? v.length : 0, b = q.get(i), S = d.state.lights; if (!0 === I && (!0 === F || e !== w)) { const t = e === w && i.id === _; ie.setState(i, e, t) } let E = !1; i.version === b.__version ? b.needsLights && b.lightsStateVersion !== S.state.version || b.outputEncoding !== o || r.isInstancedMesh && !1 === b.instancing ? E = !0 : r.isInstancedMesh || !0 !== b.instancing ? r.isSkinnedMesh && !1 === b.skinning ? E = !0 : r.isSkinnedMesh || !0 !== b.skinning ? b.envMap !== l || i.fog && b.fog !== s ? E = !0 : void 0 === b.numClippingPlanes || b.numClippingPlanes === ie.numPlanes && b.numIntersection === ie.numIntersection ? (b.vertexAlphas !== c || b.vertexTangents !== u || b.morphTargets !== h || b.morphNormals !== p || b.morphColors !== f || b.toneMapping !== g || !0 === G.isWebGL2 && b.morphTargetsCount !== y) && (E = !0) : E = !0 : E = !0 : E = !0 : (E = !0, b.__version = i.version); let M = b.currentProgram; !0 === E && (M = Te(i, t, r)); let D = !1, L = !1, A = !1; const P = M.getUniforms(), R = b.uniforms; if (j.useProgram(M.program) && (D = !0, L = !0, A = !0), i.id !== _ && (_ = i.id, L = !0), D || w !== e) { if (P.setValue(he, "projectionMatrix", e.projectionMatrix), G.logarithmicDepthBuffer && P.setValue(he, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), w !== e && (w = e, L = !0, A = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) { const t = P.map.cameraPosition; void 0 !== t && t.setValue(he, B.setFromMatrixPosition(e.matrixWorld)) } (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && P.setValue(he, "isOrthographic", !0 === e.isOrthographicCamera), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || r.isSkinnedMesh) && P.setValue(he, "viewMatrix", e.matrixWorldInverse) } if (r.isSkinnedMesh) { P.setOptional(he, r, "bindMatrix"), P.setOptional(he, r, "bindMatrixInverse"); const e = r.skeleton; e && (G.floatVertexTextures ? (null === e.boneTexture && e.computeBoneTexture(), P.setValue(he, "boneTexture", e.boneTexture, $), P.setValue(he, "boneTextureSize", e.boneTextureSize)) : P.setOptional(he, e, "boneMatrices")) } const O = n.morphAttributes; var k, N; return (void 0 !== O.position || void 0 !== O.normal || void 0 !== O.color && !0 === G.isWebGL2) && ae.update(r, n, i, M), (L || b.receiveShadow !== r.receiveShadow) && (b.receiveShadow = r.receiveShadow, P.setValue(he, "receiveShadow", r.receiveShadow)), L && (P.setValue(he, "toneMappingExposure", m.toneMappingExposure), b.needsLights && (N = A, (k = R).ambientLightColor.needsUpdate = N, k.lightProbe.needsUpdate = N, k.directionalLights.needsUpdate = N, k.directionalLightShadows.needsUpdate = N, k.pointLights.needsUpdate = N, k.pointLightShadows.needsUpdate = N, k.spotLights.needsUpdate = N, k.spotLightShadows.needsUpdate = N, k.rectAreaLights.needsUpdate = N, k.hemisphereLights.needsUpdate = N), s && i.fog && ee.refreshFogUniforms(R, s), ee.refreshMaterialUniforms(R, i, C, T, z), Ad.upload(he, b.uniformsList, R, $)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (Ad.upload(he, b.uniformsList, R, $), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && P.setValue(he, "center", r.center), P.setValue(he, "modelViewMatrix", r.modelViewMatrix), P.setValue(he, "normalMatrix", r.normalMatrix), P.setValue(he, "modelMatrix", r.matrixWorld), M }(e, t, n, i, r); j.setMaterial(i, a); let l = n.index; const c = n.attributes.position; if (null === l) { if (void 0 === c || 0 === c.count) return } else if (0 === l.count) return; let u, h = 1; !0 === i.wireframe && (l = K.getWireframeAttribute(n), h = 2), ue.setup(r, i, o, n, l); let p = oe; null !== l && (u = Z.get(l), p = le, p.setIndex(u)); const f = null !== l ? l.count : c.count, g = n.drawRange.start * h, v = n.drawRange.count * h, y = null !== s ? s.start * h : 0, b = null !== s ? s.count * h : 1 / 0, S = Math.max(g, y), E = Math.min(f, g + v, y + b) - 1, M = Math.max(0, E - S + 1); if (0 !== M) { if (r.isMesh) !0 === i.wireframe ? (j.setLineWidth(i.wireframeLinewidth * U()), p.setMode(1)) : p.setMode(4); else if (r.isLine) { let e = i.linewidth; void 0 === e && (e = 1), j.setLineWidth(e * U()), r.isLineSegments ? p.setMode(1) : r.isLineLoop ? p.setMode(2) : p.setMode(3) } else r.isPoints ? p.setMode(0) : r.isSprite && p.setMode(4); if (r.isInstancedMesh) p.renderInstances(S, M, r.count); else if (n.isInstancedBufferGeometry) { const e = Math.min(n.instanceCount, n._maxInstanceCount); p.renderInstances(S, M, e) } else p.render(S, M) } }, this.compile = function (e, t) { d = ne.get(e), d.init(), f.push(d), e.traverseVisible((function (e) { e.isLight && e.layers.test(t.layers) && (d.pushLight(e), e.castShadow && d.pushShadow(e)) })), d.setupLights(m.physicallyCorrectLights), e.traverse((function (t) { const n = t.material; if (n) if (Array.isArray(n)) for (let i = 0; i < n.length; i++)Te(n[i], e, t); else Te(n, e, t) })), f.pop(), d = null }; let ye = null; function xe() { we.stop() } function _e() { we.start() } const we = new qu; function be(e, t, n, i) { if (!1 === e.visible) return; if (e.layers.test(t.layers)) if (e.isGroup) n = e.renderOrder; else if (e.isLOD) !0 === e.autoUpdate && e.update(t); else if (e.isLight) d.pushLight(e), e.castShadow && d.pushShadow(e); else if (e.isSprite) { if (!e.frustumCulled || O.intersectsSprite(e)) { i && B.setFromMatrixPosition(e.matrixWorld).applyMatrix4(k); const t = J.update(e), r = e.material; r.visible && h.push(e, t, r, n, B.z, null) } } else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== W.render.frame && (e.skeleton.update(), e.skeleton.frame = W.render.frame), !e.frustumCulled || O.intersectsObject(e))) { i && B.setFromMatrixPosition(e.matrixWorld).applyMatrix4(k); const t = J.update(e), r = e.material; if (Array.isArray(r)) { const i = t.groups; for (let s = 0, a = i.length; s < a; s++) { const a = i[s], o = r[a.materialIndex]; o && o.visible && h.push(e, t, o, n, B.z, a) } } else r.visible && h.push(e, t, r, n, B.z, null) } const r = e.children; for (let e = 0, s = r.length; e < s; e++)be(r[e], t, n, i) } function Se(e, t, n, i) { const r = e.opaque, a = e.transmissive, o = e.transparent; d.setupLightsView(n), a.length > 0 && function (e, t, n) { const i = G.isWebGL2; null === z && (z = new Dl(1, 1, { generateMipmaps: !0, type: null !== ce.convert(Lo) ? Lo : Mo, minFilter: Eo, samples: i && !0 === s ? 4 : 0 })), m.getDrawingBufferSize(N), i ? z.setSize(N.x, N.y) : z.setSize(ll(N.x), ll(N.y)); const r = m.getRenderTarget(); m.setRenderTarget(z), m.clear(); const a = m.toneMapping; m.toneMapping = 0, Ee(e, t, n), m.toneMapping = a, $.updateMultisampleRenderTarget(z), $.updateRenderTargetMipmap(z), m.setRenderTarget(r) }(r, t, n), i && j.viewport(b.copy(i)), r.length > 0 && Ee(r, t, n), a.length > 0 && Ee(a, t, n), o.length > 0 && Ee(o, t, n), j.buffers.depth.setTest(!0), j.buffers.depth.setMask(!0), j.buffers.color.setMask(!0), j.setPolygonOffset(!1) } function Ee(e, t, n) { const i = !0 === t.isScene ? t.overrideMaterial : null; for (let r = 0, s = e.length; r < s; r++) { const s = e[r], a = s.object, o = s.geometry, l = null === i ? s.material : i, c = s.group; a.layers.test(n.layers) && Me(a, t, n, o, l, c) } } function Me(e, t, n, i, r, s) { e.onBeforeRender(m, t, n, i, r, s), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), r.onBeforeRender(m, t, n, i, e, s), !0 === r.transparent && 2 === r.side ? (r.side = 1, r.needsUpdate = !0, m.renderBufferDirect(n, t, i, r, e, s), r.side = 0, r.needsUpdate = !0, m.renderBufferDirect(n, t, i, r, e, s), r.side = 2) : m.renderBufferDirect(n, t, i, r, e, s), e.onAfterRender(m, t, n, i, r, s) } function Te(e, t, n) { !0 !== t.isScene && (t = H); const i = q.get(e), r = d.state.lights, s = d.state.shadowsArray, a = r.state.version, o = Q.getParameters(e, r.state, s, t, n), l = Q.getProgramCacheKey(o); let c = i.programs; i.environment = e.isMeshStandardMaterial ? t.environment : null, i.fog = t.fog, i.envMap = (e.isMeshStandardMaterial ? Y : X).get(e.envMap || i.environment), void 0 === c && (e.addEventListener("dispose", ve), c = new Map, i.programs = c); let u = c.get(l); if (void 0 !== u) { if (i.currentProgram === u && i.lightsStateVersion === a) return Ce(e, o), u } else o.uniforms = Q.getUniforms(e), e.onBuild(n, o, m), e.onBeforeCompile(o, m), u = Q.acquireProgram(o, l), c.set(l, u), i.uniforms = o.uniforms; const h = i.uniforms; (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (h.clippingPlanes = ie.uniform), Ce(e, o), i.needsLights = function (e) { return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights }(e), i.lightsStateVersion = a, i.needsLights && (h.ambientLightColor.value = r.state.ambient, h.lightProbe.value = r.state.probe, h.directionalLights.value = r.state.directional, h.directionalLightShadows.value = r.state.directionalShadow, h.spotLights.value = r.state.spot, h.spotLightShadows.value = r.state.spotShadow, h.rectAreaLights.value = r.state.rectArea, h.ltc_1.value = r.state.rectAreaLTC1, h.ltc_2.value = r.state.rectAreaLTC2, h.pointLights.value = r.state.point, h.pointLightShadows.value = r.state.pointShadow, h.hemisphereLights.value = r.state.hemi, h.directionalShadowMap.value = r.state.directionalShadowMap, h.directionalShadowMatrix.value = r.state.directionalShadowMatrix, h.spotShadowMap.value = r.state.spotShadowMap, h.spotShadowMatrix.value = r.state.spotShadowMatrix, h.pointShadowMap.value = r.state.pointShadowMap, h.pointShadowMatrix.value = r.state.pointShadowMatrix); const p = u.getUniforms(), f = Ad.seqWithValue(p.seq, h); return i.currentProgram = u, i.uniformsList = f, u } function Ce(e, t) { const n = q.get(e); n.outputEncoding = t.outputEncoding, n.instancing = t.instancing, n.skinning = t.skinning, n.morphTargets = t.morphTargets, n.morphNormals = t.morphNormals, n.morphColors = t.morphColors, n.morphTargetsCount = t.morphTargetsCount, n.numClippingPlanes = t.numClippingPlanes, n.numIntersection = t.numClipIntersection, n.vertexAlphas = t.vertexAlphas, n.vertexTangents = t.vertexTangents, n.toneMapping = t.toneMapping } we.setAnimationLoop((function (e) { ye && ye(e) })), "undefined" != typeof window && we.setContext(window), this.setAnimationLoop = function (e) { ye = e, fe.setAnimationLoop(e), null === e ? we.stop() : we.start() }, fe.addEventListener("sessionstart", xe), fe.addEventListener("sessionend", _e), this.render = function (e, t) { if (void 0 !== t && !0 !== t.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); if (!0 === g) return; !0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), !0 === fe.enabled && !0 === fe.isPresenting && (!0 === fe.cameraAutoUpdate && fe.updateCamera(t), t = fe.getCamera()), !0 === e.isScene && e.onBeforeRender(m, e, t, x), d = ne.get(e, f.length), d.init(), f.push(d), k.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), O.setFromProjectionMatrix(k), F = this.localClippingEnabled, I = ie.init(this.clippingPlanes, F, t), h = te.get(e, p.length), h.init(), p.push(h), be(e, t, 0, m.sortObjects), h.finish(), !0 === m.sortObjects && h.sort(D, L), !0 === I && ie.beginShadows(); const n = d.state.shadowsArray; if (re.render(n, e, t), !0 === I && ie.endShadows(), !0 === this.info.autoReset && this.info.reset(), se.render(h, e), d.setupLights(m.physicallyCorrectLights), t.isArrayCamera) { const n = t.cameras; for (let t = 0, i = n.length; t < i; t++) { const i = n[t]; Se(h, e, i, i.viewport) } } else Se(h, e, t); null !== x && ($.updateMultisampleRenderTarget(x), $.updateRenderTargetMipmap(x)), !0 === e.isScene && e.onAfterRender(m, e, t), ue.resetDefaultState(), _ = -1, w = null, f.pop(), d = f.length > 0 ? f[f.length - 1] : null, p.pop(), h = p.length > 0 ? p[p.length - 1] : null }, this.getActiveCubeFace = function () { return v }, this.getActiveMipmapLevel = function () { return y }, this.getRenderTarget = function () { return x }, this.setRenderTargetTextures = function (e, t, n) { q.get(e.texture).__webglTexture = t, q.get(e.depthTexture).__webglTexture = n; const i = q.get(e); i.__hasExternalTextures = !0, i.__hasExternalTextures && (i.__autoAllocateDepthBuffer = void 0 === n, i.__autoAllocateDepthBuffer || !0 === V.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), i.__useRenderToTexture = !1)) }, this.setRenderTargetFramebuffer = function (e, t) { const n = q.get(e); n.__webglFramebuffer = t, n.__useDefaultFramebuffer = void 0 === t }, this.setRenderTarget = function (e, t = 0, n = 0) { x = e, v = t, y = n; let i = !0; if (e) { const t = q.get(e); void 0 !== t.__useDefaultFramebuffer ? (j.bindFramebuffer(36160, null), i = !1) : void 0 === t.__webglFramebuffer ? $.setupRenderTarget(e) : t.__hasExternalTextures && $.rebindTextures(e, q.get(e.texture).__webglTexture, q.get(e.depthTexture).__webglTexture) } let r = null, s = !1, a = !1; if (e) { const n = e.texture; (n.isData3DTexture || n.isDataArrayTexture) && (a = !0); const i = q.get(e).__webglFramebuffer; e.isWebGLCubeRenderTarget ? (r = i[t], s = !0) : r = G.isWebGL2 && e.samples > 0 && !1 === $.useMultisampledRTT(e) ? q.get(e).__webglMultisampledFramebuffer : i, b.copy(e.viewport), S.copy(e.scissor), E = e.scissorTest } else b.copy(A).multiplyScalar(C).floor(), S.copy(P).multiplyScalar(C).floor(), E = R; if (j.bindFramebuffer(36160, r) && G.drawBuffers && i && j.drawBuffers(e, r), j.viewport(b), j.scissor(S), j.setScissorTest(E), s) { const i = q.get(e.texture); he.framebufferTexture2D(36160, 36064, 34069 + t, i.__webglTexture, n) } else if (a) { const i = q.get(e.texture), r = t || 0; he.framebufferTextureLayer(36160, 36064, i.__webglTexture, n || 0, r) } _ = -1 }, this.readRenderTargetPixels = function (e, t, n, i, r, s, a) { if (!e || !e.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); let o = q.get(e).__webglFramebuffer; if (e.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o) { j.bindFramebuffer(36160, o); try { const a = e.texture, o = a.format, l = a.type; if (o !== Po && ce.convert(o) !== he.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); const c = l === Lo && (V.has("EXT_color_buffer_half_float") || G.isWebGL2 && V.has("EXT_color_buffer_float")); if (!(l === Mo || ce.convert(l) === he.getParameter(35738) || l === Do && (G.isWebGL2 || V.has("OES_texture_float") || V.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); 36053 === he.checkFramebufferStatus(36160) ? t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r && he.readPixels(t, n, i, r, ce.convert(o), ce.convert(l), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") } finally { const e = null !== x ? q.get(x).__webglFramebuffer : null; j.bindFramebuffer(36160, e) } } }, this.copyFramebufferToTexture = function (e, t, n = 0) { if (!0 !== t.isFramebufferTexture) return void console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture."); const i = Math.pow(2, -n), r = Math.floor(t.image.width * i), s = Math.floor(t.image.height * i); $.setTexture2D(t, 0), he.copyTexSubImage2D(3553, n, 0, 0, e.x, e.y, r, s), j.unbindTexture() }, this.copyTextureToTexture = function (e, t, n, i = 0) { const r = t.image.width, s = t.image.height, a = ce.convert(n.format), o = ce.convert(n.type); $.setTexture2D(n, 0), he.pixelStorei(37440, n.flipY), he.pixelStorei(37441, n.premultiplyAlpha), he.pixelStorei(3317, n.unpackAlignment), t.isDataTexture ? he.texSubImage2D(3553, i, e.x, e.y, r, s, a, o, t.image.data) : t.isCompressedTexture ? he.compressedTexSubImage2D(3553, i, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, a, t.mipmaps[0].data) : he.texSubImage2D(3553, i, e.x, e.y, a, o, t.image), 0 === i && n.generateMipmaps && he.generateMipmap(3553), j.unbindTexture() }, this.copyTextureToTexture3D = function (e, t, n, i, r = 0) { if (m.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."); const s = e.max.x - e.min.x + 1, a = e.max.y - e.min.y + 1, o = e.max.z - e.min.z + 1, l = ce.convert(i.format), c = ce.convert(i.type); let u; if (i.isData3DTexture) $.setTexture3D(i, 0), u = 32879; else { if (!i.isDataArrayTexture) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."); $.setTexture2DArray(i, 0), u = 35866 } he.pixelStorei(37440, i.flipY), he.pixelStorei(37441, i.premultiplyAlpha), he.pixelStorei(3317, i.unpackAlignment); const h = he.getParameter(3314), d = he.getParameter(32878), p = he.getParameter(3316), f = he.getParameter(3315), g = he.getParameter(32877), v = n.isCompressedTexture ? n.mipmaps[0] : n.image; he.pixelStorei(3314, v.width), he.pixelStorei(32878, v.height), he.pixelStorei(3316, e.min.x), he.pixelStorei(3315, e.min.y), he.pixelStorei(32877, e.min.z), n.isDataTexture || n.isData3DTexture ? he.texSubImage3D(u, r, t.x, t.y, t.z, s, a, o, l, c, v.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), he.compressedTexSubImage3D(u, r, t.x, t.y, t.z, s, a, o, l, v.data)) : he.texSubImage3D(u, r, t.x, t.y, t.z, s, a, o, l, c, v), he.pixelStorei(3314, h), he.pixelStorei(32878, d), he.pixelStorei(3316, p), he.pixelStorei(3315, f), he.pixelStorei(32877, g), 0 === r && i.generateMipmaps && he.generateMipmap(u), j.unbindTexture() }, this.initTexture = function (e) { $.setTexture2D(e, 0), j.unbindTexture() }, this.resetState = function () { v = 0, y = 0, x = null, j.reset(), ue.reset() }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } Sp.prototype.isWebGLRenderer = !0, class extends Sp { }.prototype.isWebGL1Renderer = !0; class Ep { constructor(e, t = 25e-5) { this.name = "", this.color = new _l(e), this.density = t } clone() { return new Ep(this.color, this.density) } toJSON() { return { type: "FogExp2", color: this.color.getHex(), density: this.density } } } Ep.prototype.isFogExp2 = !0; class Mp { constructor(e, t = 1, n = 1e3) { this.name = "", this.color = new _l(e), this.near = t, this.far = n } clone() { return new Mp(this.color, this.near, this.far) } toJSON() { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } } } Mp.prototype.isFog = !0; class Tp extends Ic { constructor() { super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } copy(e, t) { return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this } toJSON(e) { const t = super.toJSON(e); return null !== this.fog && (t.object.fog = this.fog.toJSON()), t } } Tp.prototype.isScene = !0; class Cp { constructor(e, t) { this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = $o, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = nl() } onUploadCallback() { } set needsUpdate(e) { !0 === e && this.version++ } setUsage(e) { return this.usage = e, this } copy(e) { return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this } copyAt(e, t, n) { e *= this.stride, n *= t.stride; for (let i = 0, r = this.stride; i < r; i++)this.array[e + i] = t.array[n + i]; return this } set(e, t = 0) { return this.array.set(e, t), this } clone(e) { void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = nl()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer); const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(t, this.stride); return n.setUsage(this.usage), n } onUpload(e) { return this.onUploadCallback = e, this } toJSON(e) { return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = nl()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } } } Cp.prototype.isInterleavedBuffer = !0; const Dp = new Rl; class Lp { constructor(e, t, n, i = !1) { this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = !0 === i } get count() { return this.data.count } get array() { return this.data.array } set needsUpdate(e) { this.data.needsUpdate = e } applyMatrix4(e) { for (let t = 0, n = this.data.count; t < n; t++)Dp.x = this.getX(t), Dp.y = this.getY(t), Dp.z = this.getZ(t), Dp.applyMatrix4(e), this.setXYZ(t, Dp.x, Dp.y, Dp.z); return this } applyNormalMatrix(e) { for (let t = 0, n = this.count; t < n; t++)Dp.x = this.getX(t), Dp.y = this.getY(t), Dp.z = this.getZ(t), Dp.applyNormalMatrix(e), this.setXYZ(t, Dp.x, Dp.y, Dp.z); return this } transformDirection(e) { for (let t = 0, n = this.count; t < n; t++)Dp.x = this.getX(t), Dp.y = this.getY(t), Dp.z = this.getZ(t), Dp.transformDirection(e), this.setXYZ(t, Dp.x, Dp.y, Dp.z); return this } setX(e, t) { return this.data.array[e * this.data.stride + this.offset] = t, this } setY(e, t) { return this.data.array[e * this.data.stride + this.offset + 1] = t, this } setZ(e, t) { return this.data.array[e * this.data.stride + this.offset + 2] = t, this } setW(e, t) { return this.data.array[e * this.data.stride + this.offset + 3] = t, this } getX(e) { return this.data.array[e * this.data.stride + this.offset] } getY(e) { return this.data.array[e * this.data.stride + this.offset + 1] } getZ(e) { return this.data.array[e * this.data.stride + this.offset + 2] } getW(e) { return this.data.array[e * this.data.stride + this.offset + 3] } setXY(e, t, n) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this } setXYZ(e, t, n, i) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this } setXYZW(e, t, n, i, r) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = r, this } clone(e) { if (void 0 === e) { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."); const e = []; for (let t = 0; t < this.count; t++) { const n = t * this.data.stride + this.offset; for (let t = 0; t < this.itemSize; t++)e.push(this.data.array[n + t]) } return new Kc(new this.array.constructor(e), this.itemSize, this.normalized) } return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Lp(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized) } toJSON(e) { if (void 0 === e) { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."); const e = []; for (let t = 0; t < this.count; t++) { const n = t * this.data.stride + this.offset; for (let t = 0; t < this.itemSize; t++)e.push(this.data.array[n + t]) } return { itemSize: this.itemSize, type: this.array.constructor.name, array: e, normalized: this.normalized } } return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized } } } Lp.prototype.isInterleavedBufferAttribute = !0; class Ap extends $c { constructor(e) { super(), this.type = "SpriteMaterial", this.color = new _l(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this } } let Pp; Ap.prototype.isSpriteMaterial = !0; const Rp = new Rl, Op = new Rl, Ip = new Rl, Fp = new ul, zp = new ul, kp = new cc, Np = new Rl, Bp = new Rl, Hp = new Rl, Up = new ul, Vp = new ul, Gp = new ul; function jp(e, t, n, i, r, s) { Fp.subVectors(e, n).addScalar(.5).multiply(i), void 0 !== r ? (zp.x = s * Fp.x - r * Fp.y, zp.y = r * Fp.x + s * Fp.y) : zp.copy(Fp), e.copy(t), e.x += zp.x, e.y += zp.y, e.applyMatrix4(kp) } (class extends Ic { constructor(e) { if (super(), this.type = "Sprite", void 0 === Pp) { Pp = new lu; const e = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), t = new Cp(e, 5); Pp.setIndex([0, 1, 2, 0, 2, 3]), Pp.setAttribute("position", new Lp(t, 3, 0, !1)), Pp.setAttribute("uv", new Lp(t, 2, 3, !1)) } this.geometry = Pp, this.material = void 0 !== e ? e : new Ap, this.center = new ul(.5, .5) } raycast(e, t) { null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Op.setFromMatrixScale(this.matrixWorld), kp.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Ip.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Op.multiplyScalar(-Ip.z); const n = this.material.rotation; let i, r; 0 !== n && (r = Math.cos(n), i = Math.sin(n)); const s = this.center; jp(Np.set(-.5, -.5, 0), Ip, s, Op, i, r), jp(Bp.set(.5, -.5, 0), Ip, s, Op, i, r), jp(Hp.set(.5, .5, 0), Ip, s, Op, i, r), Up.set(0, 0), Vp.set(1, 0), Gp.set(1, 1); let a = e.ray.intersectTriangle(Np, Bp, Hp, !1, Rp); if (null === a && (jp(Bp.set(-.5, .5, 0), Ip, s, Op, i, r), Vp.set(0, 1), a = e.ray.intersectTriangle(Np, Hp, Bp, !1, Rp), null === a)) return; const o = e.ray.origin.distanceTo(Rp); o < e.near || o > e.far || t.push({ distance: o, point: Rp.clone(), uv: Wc.getUV(Rp, Np, Bp, Hp, Up, Vp, Gp, new ul), face: null, object: this }) } copy(e) { return super.copy(e), void 0 !== e.center && this.center.copy(e.center), this.material = e.material, this } }).prototype.isSprite = !0; const Wp = new Rl, qp = new Cl, $p = new Cl, Xp = new Rl, Yp = new cc; class Zp extends Tu { constructor(e, t) { super(e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new cc, this.bindMatrixInverse = new cc } copy(e) { return super.copy(e), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this } bind(e, t) { this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert() } pose() { this.skeleton.pose() } normalizeSkinWeights() { const e = new Cl, t = this.geometry.attributes.skinWeight; for (let n = 0, i = t.count; n < i; n++) { e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.w = t.getW(n); const i = 1 / e.manhattanLength(); i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w) } } updateMatrixWorld(e) { super.updateMatrixWorld(e), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) } boneTransform(e, t) { const n = this.skeleton, i = this.geometry; qp.fromBufferAttribute(i.attributes.skinIndex, e), $p.fromBufferAttribute(i.attributes.skinWeight, e), Wp.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0); for (let e = 0; e < 4; e++) { const i = $p.getComponent(e); if (0 !== i) { const r = qp.getComponent(e); Yp.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), t.addScaledVector(Xp.copy(Wp).applyMatrix4(Yp), i) } } return t.applyMatrix4(this.bindMatrixInverse) } } Zp.prototype.isSkinnedMesh = !0; class Kp extends Ic { constructor() { super(), this.type = "Bone" } } Kp.prototype.isBone = !0; class Jp extends Tl { constructor(e = null, t = 1, n = 1, i, r, s, a, o, l = 1003, c = 1003, u, h) { super(null, s, a, o, l, c, i, r, u, h), this.image = { data: e, width: t, height: n }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } } Jp.prototype.isDataTexture = !0; const Qp = new cc, ef = new cc; class tf { constructor(e = [], t = []) { this.uuid = nl(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init() } init() { const e = this.bones, t = this.boneInverses; if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses(); else if (e.length !== t.length) { console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = []; for (let e = 0, t = this.bones.length; e < t; e++)this.boneInverses.push(new cc) } } calculateInverses() { this.boneInverses.length = 0; for (let e = 0, t = this.bones.length; e < t; e++) { const t = new cc; this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(t) } } pose() { for (let e = 0, t = this.bones.length; e < t; e++) { const t = this.bones[e]; t && t.matrixWorld.copy(this.boneInverses[e]).invert() } for (let e = 0, t = this.bones.length; e < t; e++) { const t = this.bones[e]; t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale)) } } update() { const e = this.bones, t = this.boneInverses, n = this.boneMatrices, i = this.boneTexture; for (let i = 0, r = e.length; i < r; i++) { const r = e[i] ? e[i].matrixWorld : ef; Qp.multiplyMatrices(r, t[i]), Qp.toArray(n, 16 * i) } null !== i && (i.needsUpdate = !0) } clone() { return new tf(this.bones, this.boneInverses) } computeBoneTexture() { let e = Math.sqrt(4 * this.bones.length); e = ol(e), e = Math.max(e, 4); const t = new Float32Array(e * e * 4); t.set(this.boneMatrices); const n = new Jp(t, e, e, Po, Do); return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this.boneTextureSize = e, this } getBoneByName(e) { for (let t = 0, n = this.bones.length; t < n; t++) { const n = this.bones[t]; if (n.name === e) return n } } dispose() { null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null) } fromJSON(e, t) { this.uuid = e.uuid; for (let n = 0, i = e.bones.length; n < i; n++) { const i = e.bones[n]; let r = t[i]; void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", i), r = new Kp), this.bones.push(r), this.boneInverses.push((new cc).fromArray(e.boneInverses[n])) } return this.init(), this } toJSON() { const e = { metadata: { version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] }; e.uuid = this.uuid; const t = this.bones, n = this.boneInverses; for (let i = 0, r = t.length; i < r; i++) { const r = t[i]; e.bones.push(r.uuid); const s = n[i]; e.boneInverses.push(s.toArray()) } return e } } class nf extends Kc { constructor(e, t, n, i = 1) { "number" == typeof n && (i = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(e, t, n), this.meshPerAttribute = i } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } toJSON() { const e = super.toJSON(); return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e } } nf.prototype.isInstancedBufferAttribute = !0; const rf = new cc, sf = new cc, af = [], of = new Tu; (class extends Tu { constructor(e, t, n) { super(e, t), this.instanceMatrix = new nf(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1 } copy(e) { return super.copy(e), this.instanceMatrix.copy(e.instanceMatrix), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this } getColorAt(e, t) { t.fromArray(this.instanceColor.array, 3 * e) } getMatrixAt(e, t) { t.fromArray(this.instanceMatrix.array, 16 * e) } raycast(e, t) { const n = this.matrixWorld, i = this.count; if (of.geometry = this.geometry, of.material = this.material, void 0 !== of.material) for (let r = 0; r < i; r++) { this.getMatrixAt(r, rf), sf.multiplyMatrices(n, rf), of.matrixWorld = sf, of.raycast(e, af); for (let e = 0, n = af.length; e < n; e++) { const n = af[e]; n.instanceId = r, n.object = this, t.push(n) } af.length = 0 } } setColorAt(e, t) { null === this.instanceColor && (this.instanceColor = new nf(new Float32Array(3 * this.instanceMatrix.count), 3)), t.toArray(this.instanceColor.array, 3 * e) } setMatrixAt(e, t) { t.toArray(this.instanceMatrix.array, 16 * e) } updateMorphTargets() { } dispose() { this.dispatchEvent({ type: "dispose" }) } }).prototype.isInstancedMesh = !0; class lf extends $c { constructor(e) { super(), this.type = "LineBasicMaterial", this.color = new _l(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this } } lf.prototype.isLineBasicMaterial = !0; const cf = new Rl, uf = new Rl, hf = new cc, df = new lc, pf = new ec; class ff extends Ic { constructor(e = new lu, t = new lf) { super(), this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e) { return super.copy(e), this.material = e.material, this.geometry = e.geometry, this } computeLineDistances() { const e = this.geometry; if (e.isBufferGeometry) if (null === e.index) { const t = e.attributes.position, n = [0]; for (let e = 1, i = t.count; e < i; e++)cf.fromBufferAttribute(t, e - 1), uf.fromBufferAttribute(t, e), n[e] = n[e - 1], n[e] += cf.distanceTo(uf); e.setAttribute("lineDistance", new eu(n, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else e.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."); return this } raycast(e, t) { const n = this.geometry, i = this.matrixWorld, r = e.params.Line.threshold, s = n.drawRange; if (null === n.boundingSphere && n.computeBoundingSphere(), pf.copy(n.boundingSphere), pf.applyMatrix4(i), pf.radius += r, !1 === e.ray.intersectsSphere(pf)) return; hf.copy(i).invert(), df.copy(e.ray).applyMatrix4(hf); const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), o = a * a, l = new Rl, c = new Rl, u = new Rl, h = new Rl, d = this.isLineSegments ? 2 : 1; if (n.isBufferGeometry) { const i = n.index, r = n.attributes.position; if (null !== i) for (let n = Math.max(0, s.start), a = Math.min(i.count, s.start + s.count) - 1; n < a; n += d) { const s = i.getX(n), a = i.getX(n + 1); if (l.fromBufferAttribute(r, s), c.fromBufferAttribute(r, a), df.distanceSqToSegment(l, c, h, u) > o) continue; h.applyMatrix4(this.matrixWorld); const d = e.ray.origin.distanceTo(h); d < e.near || d > e.far || t.push({ distance: d, point: u.clone().applyMatrix4(this.matrixWorld), index: n, face: null, faceIndex: null, object: this }) } else for (let n = Math.max(0, s.start), i = Math.min(r.count, s.start + s.count) - 1; n < i; n += d) { if (l.fromBufferAttribute(r, n), c.fromBufferAttribute(r, n + 1), df.distanceSqToSegment(l, c, h, u) > o) continue; h.applyMatrix4(this.matrixWorld); const i = e.ray.origin.distanceTo(h); i < e.near || i > e.far || t.push({ distance: i, point: u.clone().applyMatrix4(this.matrixWorld), index: n, face: null, faceIndex: null, object: this }) } } else n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } updateMorphTargets() { const e = this.geometry; if (e.isBufferGeometry) { const t = e.morphAttributes, n = Object.keys(t); if (n.length > 0) { const e = t[n[0]]; if (void 0 !== e) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let t = 0, n = e.length; t < n; t++) { const n = e[t].name || String(t); this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t } } } } else { const t = e.morphTargets; void 0 !== t && t.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.") } } } ff.prototype.isLine = !0; const mf = new Rl, gf = new Rl; class vf extends ff { constructor(e, t) { super(e, t), this.type = "LineSegments" } computeLineDistances() { const e = this.geometry; if (e.isBufferGeometry) if (null === e.index) { const t = e.attributes.position, n = []; for (let e = 0, i = t.count; e < i; e += 2)mf.fromBufferAttribute(t, e), gf.fromBufferAttribute(t, e + 1), n[e] = 0 === e ? 0 : n[e - 1], n[e + 1] = n[e] + mf.distanceTo(gf); e.setAttribute("lineDistance", new eu(n, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else e.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."); return this } } vf.prototype.isLineSegments = !0; class yf extends ff { constructor(e, t) { super(e, t), this.type = "LineLoop" } } yf.prototype.isLineLoop = !0; class xf extends $c { constructor(e) { super(), this.type = "PointsMaterial", this.color = new _l(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this } } xf.prototype.isPointsMaterial = !0; const _f = new cc, wf = new lc, bf = new ec, Sf = new Rl; class Ef extends Ic { constructor(e = new lu, t = new xf) { super(), this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e) { return super.copy(e), this.material = e.material, this.geometry = e.geometry, this } raycast(e, t) { const n = this.geometry, i = this.matrixWorld, r = e.params.Points.threshold, s = n.drawRange; if (null === n.boundingSphere && n.computeBoundingSphere(), bf.copy(n.boundingSphere), bf.applyMatrix4(i), bf.radius += r, !1 === e.ray.intersectsSphere(bf)) return; _f.copy(i).invert(), wf.copy(e.ray).applyMatrix4(_f); const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), o = a * a; if (n.isBufferGeometry) { const r = n.index, a = n.attributes.position; if (null !== r) for (let n = Math.max(0, s.start), l = Math.min(r.count, s.start + s.count); n < l; n++) { const s = r.getX(n); Sf.fromBufferAttribute(a, s), Mf(Sf, s, o, i, e, t, this) } else for (let n = Math.max(0, s.start), r = Math.min(a.count, s.start + s.count); n < r; n++)Sf.fromBufferAttribute(a, n), Mf(Sf, n, o, i, e, t, this) } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } updateMorphTargets() { const e = this.geometry; if (e.isBufferGeometry) { const t = e.morphAttributes, n = Object.keys(t); if (n.length > 0) { const e = t[n[0]]; if (void 0 !== e) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let t = 0, n = e.length; t < n; t++) { const n = e[t].name || String(t); this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t } } } } else { const t = e.morphTargets; void 0 !== t && t.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.") } } } function Mf(e, t, n, i, r, s, a) { const o = wf.distanceSqToPoint(e); if (o < n) { const n = new Rl; wf.closestPointToPoint(e, n), n.applyMatrix4(i); const l = r.ray.origin.distanceTo(n); if (l < r.near || l > r.far) return; s.push({ distance: l, distanceToRay: Math.sqrt(o), point: n, index: t, face: null, object: a }) } } Ef.prototype.isPoints = !0; class Tf extends Tl { constructor(e, t, n, i, r, s, a, o, l) { super(e, t, n, i, r, s, a, o, l), this.minFilter = void 0 !== s ? s : So, this.magFilter = void 0 !== r ? r : So, this.generateMipmaps = !1; const c = this; "requestVideoFrameCallback" in e && e.requestVideoFrameCallback((function t() { c.needsUpdate = !0, e.requestVideoFrameCallback(t) })) } clone() { return new this.constructor(this.image).copy(this) } update() { const e = this.image; !1 == "requestVideoFrameCallback" in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } } Tf.prototype.isVideoTexture = !0, class extends Tl { constructor(e, t, n) { super({ width: e, height: t }), this.format = n, this.magFilter = _o, this.minFilter = _o, this.generateMipmaps = !1, this.needsUpdate = !0 } }.prototype.isFramebufferTexture = !0; (class extends Tl { constructor(e, t, n, i, r, s, a, o, l, c, u, h) { super(null, s, a, o, l, c, i, r, u, h), this.image = { width: t, height: n }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1 } }).prototype.isCompressedTexture = !0, class extends Tl { constructor(e, t, n, i, r, s, a, o, l) { super(e, t, n, i, r, s, a, o, l), this.needsUpdate = !0 } }.prototype.isCanvasTexture = !0, new Rl, new Rl, new Rl, new Wc; class Cf { constructor() { this.type = "Curve", this.arcLengthDivisions = 200 } getPoint() { return console.warn("THREE.Curve: .getPoint() not implemented."), null } getPointAt(e, t) { const n = this.getUtoTmapping(e); return this.getPoint(n, t) } getPoints(e = 5) { const t = []; for (let n = 0; n <= e; n++)t.push(this.getPoint(n / e)); return t } getSpacedPoints(e = 5) { const t = []; for (let n = 0; n <= e; n++)t.push(this.getPointAt(n / e)); return t } getLength() { const e = this.getLengths(); return e[e.length - 1] } getLengths(e = this.arcLengthDivisions) { if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; const t = []; let n, i = this.getPoint(0), r = 0; t.push(0); for (let s = 1; s <= e; s++)n = this.getPoint(s / e), r += n.distanceTo(i), t.push(r), i = n; return this.cacheArcLengths = t, t } updateArcLengths() { this.needsUpdate = !0, this.getLengths() } getUtoTmapping(e, t) { const n = this.getLengths(); let i = 0; const r = n.length; let s; s = t || e * n[r - 1]; let a, o = 0, l = r - 1; for (; o <= l;)if (i = Math.floor(o + (l - o) / 2), a = n[i] - s, a < 0) o = i + 1; else { if (!(a > 0)) { l = i; break } l = i - 1 } if (i = l, n[i] === s) return i / (r - 1); const c = n[i]; return (i + (s - c) / (n[i + 1] - c)) / (r - 1) } getTangent(e, t) { const n = 1e-4; let i = e - n, r = e + n; i < 0 && (i = 0), r > 1 && (r = 1); const s = this.getPoint(i), a = this.getPoint(r), o = t || (s.isVector2 ? new ul : new Rl); return o.copy(a).sub(s).normalize(), o } getTangentAt(e, t) { const n = this.getUtoTmapping(e); return this.getTangent(n, t) } computeFrenetFrames(e, t) { const n = new Rl, i = [], r = [], s = [], a = new Rl, o = new cc; for (let t = 0; t <= e; t++) { const n = t / e; i[t] = this.getTangentAt(n, new Rl) } r[0] = new Rl, s[0] = new Rl; let l = Number.MAX_VALUE; const c = Math.abs(i[0].x), u = Math.abs(i[0].y), h = Math.abs(i[0].z); c <= l && (l = c, n.set(1, 0, 0)), u <= l && (l = u, n.set(0, 1, 0)), h <= l && n.set(0, 0, 1), a.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], a), s[0].crossVectors(i[0], r[0]); for (let t = 1; t <= e; t++) { if (r[t] = r[t - 1].clone(), s[t] = s[t - 1].clone(), a.crossVectors(i[t - 1], i[t]), a.length() > Number.EPSILON) { a.normalize(); const e = Math.acos(il(i[t - 1].dot(i[t]), -1, 1)); r[t].applyMatrix4(o.makeRotationAxis(a, e)) } s[t].crossVectors(i[t], r[t]) } if (!0 === t) { let t = Math.acos(il(r[0].dot(r[e]), -1, 1)); t /= e, i[0].dot(a.crossVectors(r[0], r[e])) > 0 && (t = -t); for (let n = 1; n <= e; n++)r[n].applyMatrix4(o.makeRotationAxis(i[n], t * n)), s[n].crossVectors(i[n], r[n]) } return { tangents: i, normals: r, binormals: s } } clone() { return (new this.constructor).copy(this) } copy(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } toJSON() { const e = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }; return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e } fromJSON(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } } class Df extends Cf { constructor(e = 0, t = 0, n = 1, i = 1, r = 0, s = 2 * Math.PI, a = !1, o = 0) { super(), this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = i, this.aStartAngle = r, this.aEndAngle = s, this.aClockwise = a, this.aRotation = o } getPoint(e, t) { const n = t || new ul, i = 2 * Math.PI; let r = this.aEndAngle - this.aStartAngle; const s = Math.abs(r) < Number.EPSILON; for (; r < 0;)r += i; for (; r > i;)r -= i; r < Number.EPSILON && (r = s ? 0 : i), !0 !== this.aClockwise || s || (r === i ? r = -i : r -= i); const a = this.aStartAngle + e * r; let o = this.aX + this.xRadius * Math.cos(a), l = this.aY + this.yRadius * Math.sin(a); if (0 !== this.aRotation) { const e = Math.cos(this.aRotation), t = Math.sin(this.aRotation), n = o - this.aX, i = l - this.aY; o = n * e - i * t + this.aX, l = n * t + i * e + this.aY } return n.set(o, l) } copy(e) { return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } toJSON() { const e = super.toJSON(); return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e } fromJSON(e) { return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } } Df.prototype.isEllipseCurve = !0; class Lf extends Df { constructor(e, t, n, i, r, s) { super(e, t, n, n, i, r, s), this.type = "ArcCurve" } } function Af() { let e = 0, t = 0, n = 0, i = 0; function r(r, s, a, o) { e = r, t = a, n = -3 * r + 3 * s - 2 * a - o, i = 2 * r - 2 * s + a + o } return { initCatmullRom: function (e, t, n, i, s) { r(t, n, s * (n - e), s * (i - t)) }, initNonuniformCatmullRom: function (e, t, n, i, s, a, o) { let l = (t - e) / s - (n - e) / (s + a) + (n - t) / a, c = (n - t) / a - (i - t) / (a + o) + (i - n) / o; l *= a, c *= a, r(t, n, l, c) }, calc: function (r) { const s = r * r; return e + t * r + n * s + i * (s * r) } } } Lf.prototype.isArcCurve = !0; const Pf = new Rl, Rf = new Af, Of = new Af, If = new Af; class Ff extends Cf { constructor(e = [], t = !1, n = "centripetal", i = .5) { super(), this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = i } getPoint(e, t = new Rl) { const n = t, i = this.points, r = i.length, s = (r - (this.closed ? 0 : 1)) * e; let a, o, l = Math.floor(s), c = s - l; this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2, c = 1), this.closed || l > 0 ? a = i[(l - 1) % r] : (Pf.subVectors(i[0], i[1]).add(i[0]), a = Pf); const u = i[l % r], h = i[(l + 1) % r]; if (this.closed || l + 2 < r ? o = i[(l + 2) % r] : (Pf.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), o = Pf), "centripetal" === this.curveType || "chordal" === this.curveType) { const e = "chordal" === this.curveType ? .5 : .25; let t = Math.pow(a.distanceToSquared(u), e), n = Math.pow(u.distanceToSquared(h), e), i = Math.pow(h.distanceToSquared(o), e); n < 1e-4 && (n = 1), t < 1e-4 && (t = n), i < 1e-4 && (i = n), Rf.initNonuniformCatmullRom(a.x, u.x, h.x, o.x, t, n, i), Of.initNonuniformCatmullRom(a.y, u.y, h.y, o.y, t, n, i), If.initNonuniformCatmullRom(a.z, u.z, h.z, o.z, t, n, i) } else "catmullrom" === this.curveType && (Rf.initCatmullRom(a.x, u.x, h.x, o.x, this.tension), Of.initCatmullRom(a.y, u.y, h.y, o.y, this.tension), If.initCatmullRom(a.z, u.z, h.z, o.z, this.tension)); return n.set(Rf.calc(c), Of.calc(c), If.calc(c)), n } copy(e) { super.copy(e), this.points = []; for (let t = 0, n = e.points.length; t < n; t++) { const n = e.points[t]; this.points.push(n.clone()) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this } toJSON() { const e = super.toJSON(); e.points = []; for (let t = 0, n = this.points.length; t < n; t++) { const n = this.points[t]; e.points.push(n.toArray()) } return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e } fromJSON(e) { super.fromJSON(e), this.points = []; for (let t = 0, n = e.points.length; t < n; t++) { const n = e.points[t]; this.points.push((new Rl).fromArray(n)) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this } } function zf(e, t, n, i, r) { const s = .5 * (i - t), a = .5 * (r - n), o = e * e; return (2 * n - 2 * i + s + a) * (e * o) + (-3 * n + 3 * i - 2 * s - a) * o + s * e + n } function kf(e, t, n, i) { return function (e, t) { const n = 1 - e; return n * n * t }(e, t) + function (e, t) { return 2 * (1 - e) * e * t }(e, n) + function (e, t) { return e * e * t }(e, i) } function Nf(e, t, n, i, r) { return function (e, t) { const n = 1 - e; return n * n * n * t }(e, t) + function (e, t) { const n = 1 - e; return 3 * n * n * e * t }(e, n) + function (e, t) { return 3 * (1 - e) * e * e * t }(e, i) + function (e, t) { return e * e * e * t }(e, r) } Ff.prototype.isCatmullRomCurve3 = !0; class Bf extends Cf { constructor(e = new ul, t = new ul, n = new ul, i = new ul) { super(), this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i } getPoint(e, t = new ul) { const n = t, i = this.v0, r = this.v1, s = this.v2, a = this.v3; return n.set(Nf(e, i.x, r.x, s.x, a.x), Nf(e, i.y, r.y, s.y, a.y)), n } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } Bf.prototype.isCubicBezierCurve = !0; class Hf extends Cf { constructor(e = new Rl, t = new Rl, n = new Rl, i = new Rl) { super(), this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i } getPoint(e, t = new Rl) { const n = t, i = this.v0, r = this.v1, s = this.v2, a = this.v3; return n.set(Nf(e, i.x, r.x, s.x, a.x), Nf(e, i.y, r.y, s.y, a.y), Nf(e, i.z, r.z, s.z, a.z)), n } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } Hf.prototype.isCubicBezierCurve3 = !0; class Uf extends Cf { constructor(e = new ul, t = new ul) { super(), this.type = "LineCurve", this.v1 = e, this.v2 = t } getPoint(e, t = new ul) { const n = t; return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n } getPointAt(e, t) { return this.getPoint(e, t) } getTangent(e, t) { const n = t || new ul; return n.copy(this.v2).sub(this.v1).normalize(), n } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } Uf.prototype.isLineCurve = !0; class Vf extends Cf { constructor(e = new ul, t = new ul, n = new ul) { super(), this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n } getPoint(e, t = new ul) { const n = t, i = this.v0, r = this.v1, s = this.v2; return n.set(kf(e, i.x, r.x, s.x), kf(e, i.y, r.y, s.y)), n } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } Vf.prototype.isQuadraticBezierCurve = !0; class Gf extends Cf { constructor(e = new Rl, t = new Rl, n = new Rl) { super(), this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n } getPoint(e, t = new Rl) { const n = t, i = this.v0, r = this.v1, s = this.v2; return n.set(kf(e, i.x, r.x, s.x), kf(e, i.y, r.y, s.y), kf(e, i.z, r.z, s.z)), n } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } Gf.prototype.isQuadraticBezierCurve3 = !0; class jf extends Cf { constructor(e = []) { super(), this.type = "SplineCurve", this.points = e } getPoint(e, t = new ul) { const n = t, i = this.points, r = (i.length - 1) * e, s = Math.floor(r), a = r - s, o = i[0 === s ? s : s - 1], l = i[s], c = i[s > i.length - 2 ? i.length - 1 : s + 1], u = i[s > i.length - 3 ? i.length - 1 : s + 2]; return n.set(zf(a, o.x, l.x, c.x, u.x), zf(a, o.y, l.y, c.y, u.y)), n } copy(e) { super.copy(e), this.points = []; for (let t = 0, n = e.points.length; t < n; t++) { const n = e.points[t]; this.points.push(n.clone()) } return this } toJSON() { const e = super.toJSON(); e.points = []; for (let t = 0, n = this.points.length; t < n; t++) { const n = this.points[t]; e.points.push(n.toArray()) } return e } fromJSON(e) { super.fromJSON(e), this.points = []; for (let t = 0, n = e.points.length; t < n; t++) { const n = e.points[t]; this.points.push((new ul).fromArray(n)) } return this } } jf.prototype.isSplineCurve = !0; var Wf = Object.freeze({ __proto__: null, ArcCurve: Lf, CatmullRomCurve3: Ff, CubicBezierCurve: Bf, CubicBezierCurve3: Hf, EllipseCurve: Df, LineCurve: Uf, LineCurve3: class extends Cf { constructor(e = new Rl, t = new Rl) { super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = e, this.v2 = t } getPoint(e, t = new Rl) { const n = t; return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n } getPointAt(e, t) { return this.getPoint(e, t) } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } }, QuadraticBezierCurve: Vf, QuadraticBezierCurve3: Gf, SplineCurve: jf }); class qf extends Cf { constructor() { super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1 } add(e) { this.curves.push(e) } closePath() { const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1); e.equals(t) || this.curves.push(new Uf(t, e)) } getPoint(e, t) { const n = e * this.getLength(), i = this.getCurveLengths(); let r = 0; for (; r < i.length;) { if (i[r] >= n) { const e = i[r] - n, s = this.curves[r], a = s.getLength(), o = 0 === a ? 0 : 1 - e / a; return s.getPointAt(o, t) } r++ } return null } getLength() { const e = this.getCurveLengths(); return e[e.length - 1] } updateArcLengths() { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() } getCurveLengths() { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; const e = []; let t = 0; for (let n = 0, i = this.curves.length; n < i; n++)t += this.curves[n].getLength(), e.push(t); return this.cacheLengths = e, e } getSpacedPoints(e = 40) { const t = []; for (let n = 0; n <= e; n++)t.push(this.getPoint(n / e)); return this.autoClose && t.push(t[0]), t } getPoints(e = 12) { const t = []; let n; for (let i = 0, r = this.curves; i < r.length; i++) { const s = r[i], a = s.isEllipseCurve ? 2 * e : s.isLineCurve || s.isLineCurve3 ? 1 : s.isSplineCurve ? e * s.points.length : e, o = s.getPoints(a); for (let e = 0; e < o.length; e++) { const i = o[e]; n && n.equals(i) || (t.push(i), n = i) } } return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t } copy(e) { super.copy(e), this.curves = []; for (let t = 0, n = e.curves.length; t < n; t++) { const n = e.curves[t]; this.curves.push(n.clone()) } return this.autoClose = e.autoClose, this } toJSON() { const e = super.toJSON(); e.autoClose = this.autoClose, e.curves = []; for (let t = 0, n = this.curves.length; t < n; t++) { const n = this.curves[t]; e.curves.push(n.toJSON()) } return e } fromJSON(e) { super.fromJSON(e), this.autoClose = e.autoClose, this.curves = []; for (let t = 0, n = e.curves.length; t < n; t++) { const n = e.curves[t]; this.curves.push((new Wf[n.type]).fromJSON(n)) } return this } } class $f extends qf { constructor(e) { super(), this.type = "Path", this.currentPoint = new ul, e && this.setFromPoints(e) } setFromPoints(e) { this.moveTo(e[0].x, e[0].y); for (let t = 1, n = e.length; t < n; t++)this.lineTo(e[t].x, e[t].y); return this } moveTo(e, t) { return this.currentPoint.set(e, t), this } lineTo(e, t) { const n = new Uf(this.currentPoint.clone(), new ul(e, t)); return this.curves.push(n), this.currentPoint.set(e, t), this } quadraticCurveTo(e, t, n, i) { const r = new Vf(this.currentPoint.clone(), new ul(e, t), new ul(n, i)); return this.curves.push(r), this.currentPoint.set(n, i), this } bezierCurveTo(e, t, n, i, r, s) { const a = new Bf(this.currentPoint.clone(), new ul(e, t), new ul(n, i), new ul(r, s)); return this.curves.push(a), this.currentPoint.set(r, s), this } splineThru(e) { const t = [this.currentPoint.clone()].concat(e), n = new jf(t); return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this } arc(e, t, n, i, r, s) { const a = this.currentPoint.x, o = this.currentPoint.y; return this.absarc(e + a, t + o, n, i, r, s), this } absarc(e, t, n, i, r, s) { return this.absellipse(e, t, n, n, i, r, s), this } ellipse(e, t, n, i, r, s, a, o) { const l = this.currentPoint.x, c = this.currentPoint.y; return this.absellipse(e + l, t + c, n, i, r, s, a, o), this } absellipse(e, t, n, i, r, s, a, o) { const l = new Df(e, t, n, i, r, s, a, o); if (this.curves.length > 0) { const e = l.getPoint(0); e.equals(this.currentPoint) || this.lineTo(e.x, e.y) } this.curves.push(l); const c = l.getPoint(1); return this.currentPoint.copy(c), this } copy(e) { return super.copy(e), this.currentPoint.copy(e.currentPoint), this } toJSON() { const e = super.toJSON(); return e.currentPoint = this.currentPoint.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this } } class Xf extends $f { constructor(e) { super(e), this.uuid = nl(), this.type = "Shape", this.holes = [] } getPointsHoles(e) { const t = []; for (let n = 0, i = this.holes.length; n < i; n++)t[n] = this.holes[n].getPoints(e); return t } extractPoints(e) { return { shape: this.getPoints(e), holes: this.getPointsHoles(e) } } copy(e) { super.copy(e), this.holes = []; for (let t = 0, n = e.holes.length; t < n; t++) { const n = e.holes[t]; this.holes.push(n.clone()) } return this } toJSON() { const e = super.toJSON(); e.uuid = this.uuid, e.holes = []; for (let t = 0, n = this.holes.length; t < n; t++) { const n = this.holes[t]; e.holes.push(n.toJSON()) } return e } fromJSON(e) { super.fromJSON(e), this.uuid = e.uuid, this.holes = []; for (let t = 0, n = e.holes.length; t < n; t++) { const n = e.holes[t]; this.holes.push((new $f).fromJSON(n)) } return this } } function Yf(e, t, n, i, r) { let s, a; if (r === function (e, t, n, i) { let r = 0; for (let s = t, a = n - i; s < n; s += i)r += (e[a] - e[s]) * (e[s + 1] + e[a + 1]), a = s; return r }(e, t, n, i) > 0) for (s = t; s < n; s += i)a = gm(s, e[s], e[s + 1], a); else for (s = n - i; s >= t; s -= i)a = gm(s, e[s], e[s + 1], a); return a && um(a, a.next) && (vm(a), a = a.next), a } function Zf(e, t) { if (!e) return e; t || (t = e); let n, i = e; do { if (n = !1, i.steiner || !um(i, i.next) && 0 !== cm(i.prev, i, i.next)) i = i.next; else { if (vm(i), i = t = i.prev, i === i.next) break; n = !0 } } while (n || i !== t); return t } function Kf(e, t, n, i, r, s, a) { if (!e) return; !a && s && function (e, t, n, i) { let r = e; do { null === r.z && (r.z = sm(r.x, r.y, t, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next } while (r !== e); r.prevZ.nextZ = null, r.prevZ = null, function (e) { let t, n, i, r, s, a, o, l, c = 1; do { for (n = e, e = null, s = null, a = 0; n;) { for (a++, i = n, o = 0, t = 0; t < c && (o++, i = i.nextZ, i); t++); for (l = c; o > 0 || l > 0 && i;)0 !== o && (0 === l || !i || n.z <= i.z) ? (r = n, n = n.nextZ, o--) : (r = i, i = i.nextZ, l--), s ? s.nextZ = r : e = r, r.prevZ = s, s = r; n = i } s.nextZ = null, c *= 2 } while (a > 1) }(r) }(e, i, r, s); let o, l, c = e; for (; e.prev !== e.next;)if (o = e.prev, l = e.next, s ? Qf(e, i, r, s) : Jf(e)) t.push(o.i / n), t.push(e.i / n), t.push(l.i / n), vm(e), e = l.next, c = l.next; else if ((e = l) === c) { a ? 1 === a ? Kf(e = em(Zf(e), t, n), t, n, i, r, s, 2) : 2 === a && tm(e, t, n, i, r, s) : Kf(Zf(e), t, n, i, r, s, 1); break } } function Jf(e) { const t = e.prev, n = e, i = e.next; if (cm(t, n, i) >= 0) return !1; let r = e.next.next; for (; r !== e.prev;) { if (om(t.x, t.y, n.x, n.y, i.x, i.y, r.x, r.y) && cm(r.prev, r, r.next) >= 0) return !1; r = r.next } return !0 } function Qf(e, t, n, i) { const r = e.prev, s = e, a = e.next; if (cm(r, s, a) >= 0) return !1; const o = r.x < s.x ? r.x < a.x ? r.x : a.x : s.x < a.x ? s.x : a.x, l = r.y < s.y ? r.y < a.y ? r.y : a.y : s.y < a.y ? s.y : a.y, c = r.x > s.x ? r.x > a.x ? r.x : a.x : s.x > a.x ? s.x : a.x, u = r.y > s.y ? r.y > a.y ? r.y : a.y : s.y > a.y ? s.y : a.y, h = sm(o, l, t, n, i), d = sm(c, u, t, n, i); let p = e.prevZ, f = e.nextZ; for (; p && p.z >= h && f && f.z <= d;) { if (p !== e.prev && p !== e.next && om(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && cm(p.prev, p, p.next) >= 0) return !1; if (p = p.prevZ, f !== e.prev && f !== e.next && om(r.x, r.y, s.x, s.y, a.x, a.y, f.x, f.y) && cm(f.prev, f, f.next) >= 0) return !1; f = f.nextZ } for (; p && p.z >= h;) { if (p !== e.prev && p !== e.next && om(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && cm(p.prev, p, p.next) >= 0) return !1; p = p.prevZ } for (; f && f.z <= d;) { if (f !== e.prev && f !== e.next && om(r.x, r.y, s.x, s.y, a.x, a.y, f.x, f.y) && cm(f.prev, f, f.next) >= 0) return !1; f = f.nextZ } return !0 } function em(e, t, n) { let i = e; do { const r = i.prev, s = i.next.next; !um(r, s) && hm(r, i, i.next, s) && fm(r, s) && fm(s, r) && (t.push(r.i / n), t.push(i.i / n), t.push(s.i / n), vm(i), vm(i.next), i = e = s), i = i.next } while (i !== e); return Zf(i) } function tm(e, t, n, i, r, s) { let a = e; do { let e = a.next.next; for (; e !== a.prev;) { if (a.i !== e.i && lm(a, e)) { let o = mm(a, e); return a = Zf(a, a.next), o = Zf(o, o.next), Kf(a, t, n, i, r, s), void Kf(o, t, n, i, r, s) } e = e.next } a = a.next } while (a !== e) } function nm(e, t) { return e.x - t.x } function im(e, t) { if (t = function (e, t) { let n = t; const i = e.x, r = e.y; let s, a = -1 / 0; do { if (r <= n.y && r >= n.next.y && n.next.y !== n.y) { const e = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y); if (e <= i && e > a) { if (a = e, e === i) { if (r === n.y) return n; if (r === n.next.y) return n.next } s = n.x < n.next.x ? n : n.next } } n = n.next } while (n !== t); if (!s) return null; if (i === a) return s; const o = s, l = s.x, c = s.y; let u, h = 1 / 0; n = s; do { i >= n.x && n.x >= l && i !== n.x && om(r < c ? i : a, r, l, c, r < c ? a : i, r, n.x, n.y) && (u = Math.abs(r - n.y) / (i - n.x), fm(n, e) && (u < h || u === h && (n.x > s.x || n.x === s.x && rm(s, n))) && (s = n, h = u)), n = n.next } while (n !== o); return s }(e, t), t) { const n = mm(t, e); Zf(t, t.next), Zf(n, n.next) } } function rm(e, t) { return cm(e.prev, e, t.prev) < 0 && cm(t.next, e, e.next) < 0 } function sm(e, t, n, i, r) { return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1 } function am(e) { let t = e, n = e; do { (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next } while (t !== e); return n } function om(e, t, n, i, r, s, a, o) { return (r - a) * (t - o) - (e - a) * (s - o) >= 0 && (e - a) * (i - o) - (n - a) * (t - o) >= 0 && (n - a) * (s - o) - (r - a) * (i - o) >= 0 } function lm(e, t) { return e.next.i !== t.i && e.prev.i !== t.i && !function (e, t) { let n = e; do { if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && hm(n, n.next, e, t)) return !0; n = n.next } while (n !== e); return !1 }(e, t) && (fm(e, t) && fm(t, e) && function (e, t) { let n = e, i = !1; const r = (e.x + t.x) / 2, s = (e.y + t.y) / 2; do { n.y > s != n.next.y > s && n.next.y !== n.y && r < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next } while (n !== e); return i }(e, t) && (cm(e.prev, e, t.prev) || cm(e, t.prev, t)) || um(e, t) && cm(e.prev, e, e.next) > 0 && cm(t.prev, t, t.next) > 0) } function cm(e, t, n) { return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y) } function um(e, t) { return e.x === t.x && e.y === t.y } function hm(e, t, n, i) { const r = pm(cm(e, t, n)), s = pm(cm(e, t, i)), a = pm(cm(n, i, e)), o = pm(cm(n, i, t)); return r !== s && a !== o || !(0 !== r || !dm(e, n, t)) || !(0 !== s || !dm(e, i, t)) || !(0 !== a || !dm(n, e, i)) || !(0 !== o || !dm(n, t, i)) } function dm(e, t, n) { return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y) } function pm(e) { return e > 0 ? 1 : e < 0 ? -1 : 0 } function fm(e, t) { return cm(e.prev, e, e.next) < 0 ? cm(e, t, e.next) >= 0 && cm(e, e.prev, t) >= 0 : cm(e, t, e.prev) < 0 || cm(e, e.next, t) < 0 } function mm(e, t) { const n = new ym(e.i, e.x, e.y), i = new ym(t.i, t.x, t.y), r = e.next, s = t.prev; return e.next = t, t.prev = e, n.next = r, r.prev = n, i.next = n, n.prev = i, s.next = i, i.prev = s, i } function gm(e, t, n, i) { const r = new ym(e, t, n); return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r } function vm(e) { e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ) } function ym(e, t, n) { this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 } class xm { static area(e) { const t = e.length; let n = 0; for (let i = t - 1, r = 0; r < t; i = r++)n += e[i].x * e[r].y - e[r].x * e[i].y; return .5 * n } static isClockWise(e) { return xm.area(e) < 0 } static triangulateShape(e, t) { const n = [], i = [], r = []; _m(e), wm(n, e); let s = e.length; t.forEach(_m); for (let e = 0; e < t.length; e++)i.push(s), s += t[e].length, wm(n, t[e]); const a = function (e, t, n = 2) { const i = t && t.length, r = i ? t[0] * n : e.length; let s = Yf(e, 0, r, n, !0); const a = []; if (!s || s.next === s.prev) return a; let o, l, c, u, h, d, p; if (i && (s = function (e, t, n, i) { const r = []; let s, a, o, l, c; for (s = 0, a = t.length; s < a; s++)o = t[s] * i, l = s < a - 1 ? t[s + 1] * i : e.length, c = Yf(e, o, l, i, !1), c === c.next && (c.steiner = !0), r.push(am(c)); for (r.sort(nm), s = 0; s < r.length; s++)im(r[s], n), n = Zf(n, n.next); return n }(e, t, s, n)), e.length > 80 * n) { o = c = e[0], l = u = e[1]; for (let t = n; t < r; t += n)h = e[t], d = e[t + 1], h < o && (o = h), d < l && (l = d), h > c && (c = h), d > u && (u = d); p = Math.max(c - o, u - l), p = 0 !== p ? 1 / p : 0 } return Kf(s, a, n, o, l, p), a }(n, i); for (let e = 0; e < a.length; e += 3)r.push(a.slice(e, e + 3)); return r } } function _m(e) { const t = e.length; t > 2 && e[t - 1].equals(e[0]) && e.pop() } function wm(e, t) { for (let n = 0; n < t.length; n++)e.push(t[n].x), e.push(t[n].y) } class bm extends lu { constructor(e = new Xf([new ul(.5, .5), new ul(-.5, .5), new ul(-.5, -.5), new ul(.5, -.5)]), t = {}) { super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: e, options: t }, e = Array.isArray(e) ? e : [e]; const n = this, i = [], r = []; for (let t = 0, n = e.length; t < n; t++)s(e[t]); function s(e) { const s = [], a = void 0 !== t.curveSegments ? t.curveSegments : 12, o = void 0 !== t.steps ? t.steps : 1; let l = void 0 !== t.depth ? t.depth : 1, c = void 0 === t.bevelEnabled || t.bevelEnabled, u = void 0 !== t.bevelThickness ? t.bevelThickness : .2, h = void 0 !== t.bevelSize ? t.bevelSize : u - .1, d = void 0 !== t.bevelOffset ? t.bevelOffset : 0, p = void 0 !== t.bevelSegments ? t.bevelSegments : 3; const f = t.extrudePath, m = void 0 !== t.UVGenerator ? t.UVGenerator : Sm; void 0 !== t.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = t.amount); let g, v, y, x, _, w = !1; f && (g = f.getSpacedPoints(o), w = !0, c = !1, v = f.computeFrenetFrames(o, !1), y = new Rl, x = new Rl, _ = new Rl), c || (p = 0, u = 0, h = 0, d = 0); const b = e.extractPoints(a); let S = b.shape; const E = b.holes; if (!xm.isClockWise(S)) { S = S.reverse(); for (let e = 0, t = E.length; e < t; e++) { const t = E[e]; xm.isClockWise(t) && (E[e] = t.reverse()) } } const M = xm.triangulateShape(S, E), T = S; for (let e = 0, t = E.length; e < t; e++) { const t = E[e]; S = S.concat(t) } function C(e, t, n) { return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(n).add(e) } const D = S.length, L = M.length; function A(e, t, n) { let i, r, s; const a = e.x - t.x, o = e.y - t.y, l = n.x - e.x, c = n.y - e.y, u = a * a + o * o, h = a * c - o * l; if (Math.abs(h) > Number.EPSILON) { const h = Math.sqrt(u), d = Math.sqrt(l * l + c * c), p = t.x - o / h, f = t.y + a / h, m = ((n.x - c / d - p) * c - (n.y + l / d - f) * l) / (a * c - o * l); i = p + a * m - e.x, r = f + o * m - e.y; const g = i * i + r * r; if (g <= 2) return new ul(i, r); s = Math.sqrt(g / 2) } else { let e = !1; a > Number.EPSILON ? l > Number.EPSILON && (e = !0) : a < -Number.EPSILON ? l < -Number.EPSILON && (e = !0) : Math.sign(o) === Math.sign(c) && (e = !0), e ? (i = -o, r = a, s = Math.sqrt(u)) : (i = a, r = o, s = Math.sqrt(u / 2)) } return new ul(i / s, r / s) } const P = []; for (let e = 0, t = T.length, n = t - 1, i = e + 1; e < t; e++, n++, i++)n === t && (n = 0), i === t && (i = 0), P[e] = A(T[e], T[n], T[i]); const R = []; let O, I = P.concat(); for (let e = 0, t = E.length; e < t; e++) { const t = E[e]; O = []; for (let e = 0, n = t.length, i = n - 1, r = e + 1; e < n; e++, i++, r++)i === n && (i = 0), r === n && (r = 0), O[e] = A(t[e], t[i], t[r]); R.push(O), I = I.concat(O) } for (let e = 0; e < p; e++) { const t = e / p, n = u * Math.cos(t * Math.PI / 2), i = h * Math.sin(t * Math.PI / 2) + d; for (let e = 0, t = T.length; e < t; e++) { const t = C(T[e], P[e], i); k(t.x, t.y, -n) } for (let e = 0, t = E.length; e < t; e++) { const t = E[e]; O = R[e]; for (let e = 0, r = t.length; e < r; e++) { const r = C(t[e], O[e], i); k(r.x, r.y, -n) } } } const F = h + d; for (let e = 0; e < D; e++) { const t = c ? C(S[e], I[e], F) : S[e]; w ? (x.copy(v.normals[0]).multiplyScalar(t.x), y.copy(v.binormals[0]).multiplyScalar(t.y), _.copy(g[0]).add(x).add(y), k(_.x, _.y, _.z)) : k(t.x, t.y, 0) } for (let e = 1; e <= o; e++)for (let t = 0; t < D; t++) { const n = c ? C(S[t], I[t], F) : S[t]; w ? (x.copy(v.normals[e]).multiplyScalar(n.x), y.copy(v.binormals[e]).multiplyScalar(n.y), _.copy(g[e]).add(x).add(y), k(_.x, _.y, _.z)) : k(n.x, n.y, l / o * e) } for (let e = p - 1; e >= 0; e--) { const t = e / p, n = u * Math.cos(t * Math.PI / 2), i = h * Math.sin(t * Math.PI / 2) + d; for (let e = 0, t = T.length; e < t; e++) { const t = C(T[e], P[e], i); k(t.x, t.y, l + n) } for (let e = 0, t = E.length; e < t; e++) { const t = E[e]; O = R[e]; for (let e = 0, r = t.length; e < r; e++) { const r = C(t[e], O[e], i); w ? k(r.x, r.y + g[o - 1].y, g[o - 1].x + n) : k(r.x, r.y, l + n) } } } function z(e, t) { let n = e.length; for (; --n >= 0;) { const i = n; let r = n - 1; r < 0 && (r = e.length - 1); for (let e = 0, n = o + 2 * p; e < n; e++) { const n = D * e, s = D * (e + 1); B(t + i + n, t + r + n, t + r + s, t + i + s) } } } function k(e, t, n) { s.push(e), s.push(t), s.push(n) } function N(e, t, r) { H(e), H(t), H(r); const s = i.length / 3, a = m.generateTopUV(n, i, s - 3, s - 2, s - 1); U(a[0]), U(a[1]), U(a[2]) } function B(e, t, r, s) { H(e), H(t), H(s), H(t), H(r), H(s); const a = i.length / 3, o = m.generateSideWallUV(n, i, a - 6, a - 3, a - 2, a - 1); U(o[0]), U(o[1]), U(o[3]), U(o[1]), U(o[2]), U(o[3]) } function H(e) { i.push(s[3 * e + 0]), i.push(s[3 * e + 1]), i.push(s[3 * e + 2]) } function U(e) { r.push(e.x), r.push(e.y) } !function () { const e = i.length / 3; if (c) { let e = 0, t = D * e; for (let e = 0; e < L; e++) { const n = M[e]; N(n[2] + t, n[1] + t, n[0] + t) } e = o + 2 * p, t = D * e; for (let e = 0; e < L; e++) { const n = M[e]; N(n[0] + t, n[1] + t, n[2] + t) } } else { for (let e = 0; e < L; e++) { const t = M[e]; N(t[2], t[1], t[0]) } for (let e = 0; e < L; e++) { const t = M[e]; N(t[0] + D * o, t[1] + D * o, t[2] + D * o) } } n.addGroup(e, i.length / 3 - e, 0) }(), function () { const e = i.length / 3; let t = 0; z(T, t), t += T.length; for (let e = 0, n = E.length; e < n; e++) { const n = E[e]; z(n, t), t += n.length } n.addGroup(e, i.length / 3 - e, 1) }() } this.setAttribute("position", new eu(i, 3)), this.setAttribute("uv", new eu(r, 2)), this.computeVertexNormals() } toJSON() { const e = super.toJSON(); return function (e, t, n) { if (n.shapes = [], Array.isArray(e)) for (let t = 0, i = e.length; t < i; t++) { const i = e[t]; n.shapes.push(i.uuid) } else n.shapes.push(e.uuid); return void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON()), n }(this.parameters.shapes, this.parameters.options, e) } static fromJSON(e, t) { const n = []; for (let i = 0, r = e.shapes.length; i < r; i++) { const r = t[e.shapes[i]]; n.push(r) } const i = e.options.extrudePath; return void 0 !== i && (e.options.extrudePath = (new Wf[i.type]).fromJSON(i)), new bm(n, e.options) } } const Sm = { generateTopUV: function (e, t, n, i, r) { const s = t[3 * n], a = t[3 * n + 1], o = t[3 * i], l = t[3 * i + 1], c = t[3 * r], u = t[3 * r + 1]; return [new ul(s, a), new ul(o, l), new ul(c, u)] }, generateSideWallUV: function (e, t, n, i, r, s) { const a = t[3 * n], o = t[3 * n + 1], l = t[3 * n + 2], c = t[3 * i], u = t[3 * i + 1], h = t[3 * i + 2], d = t[3 * r], p = t[3 * r + 1], f = t[3 * r + 2], m = t[3 * s], g = t[3 * s + 1], v = t[3 * s + 2]; return Math.abs(o - u) < Math.abs(a - c) ? [new ul(a, 1 - l), new ul(c, 1 - h), new ul(d, 1 - f), new ul(m, 1 - v)] : [new ul(o, 1 - l), new ul(u, 1 - h), new ul(p, 1 - f), new ul(g, 1 - v)] } }; class Em extends lu { constructor(e = new Xf([new ul(0, .5), new ul(-.5, -.5), new ul(.5, -.5)]), t = 12) { super(), this.type = "ShapeGeometry", this.parameters = { shapes: e, curveSegments: t }; const n = [], i = [], r = [], s = []; let a = 0, o = 0; if (!1 === Array.isArray(e)) l(e); else for (let t = 0; t < e.length; t++)l(e[t]), this.addGroup(a, o, t), a += o, o = 0; function l(e) { const a = i.length / 3, l = e.extractPoints(t); let c = l.shape; const u = l.holes; !1 === xm.isClockWise(c) && (c = c.reverse()); for (let e = 0, t = u.length; e < t; e++) { const t = u[e]; !0 === xm.isClockWise(t) && (u[e] = t.reverse()) } const h = xm.triangulateShape(c, u); for (let e = 0, t = u.length; e < t; e++) { const t = u[e]; c = c.concat(t) } for (let e = 0, t = c.length; e < t; e++) { const t = c[e]; i.push(t.x, t.y, 0), r.push(0, 0, 1), s.push(t.x, t.y) } for (let e = 0, t = h.length; e < t; e++) { const t = h[e], i = t[0] + a, r = t[1] + a, s = t[2] + a; n.push(i, r, s), o += 3 } } this.setIndex(n), this.setAttribute("position", new eu(i, 3)), this.setAttribute("normal", new eu(r, 3)), this.setAttribute("uv", new eu(s, 2)) } toJSON() { const e = super.toJSON(); return function (e, t) { if (t.shapes = [], Array.isArray(e)) for (let n = 0, i = e.length; n < i; n++) { const i = e[n]; t.shapes.push(i.uuid) } else t.shapes.push(e.uuid); return t }(this.parameters.shapes, e) } static fromJSON(e, t) { const n = []; for (let i = 0, r = e.shapes.length; i < r; i++) { const r = t[e.shapes[i]]; n.push(r) } return new Em(n, e.curveSegments) } } class Mm extends $c { constructor(e) { super(), this.type = "ShadowMaterial", this.color = new _l(0), this.transparent = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this } } Mm.prototype.isShadowMaterial = !0; class Tm extends Ru { constructor(e) { super(e), this.type = "RawShaderMaterial" } } Tm.prototype.isRawShaderMaterial = !0; class Cm extends $c { constructor(e) { super(), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new _l(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new _l(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new ul(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this } } Cm.prototype.isMeshStandardMaterial = !0; class Dm extends Cm { constructor(e) { super(), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new ul(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function () { return il(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1) }, set: function (e) { this.ior = (1 + .4 * e) / (1 - .4 * e) } }), this.sheenColor = new _l(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new _l(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new _l(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._transmission = 0, this.setValues(e) } get sheen() { return this._sheen } set sheen(e) { this._sheen > 0 != e > 0 && this.version++, this._sheen = e } get clearcoat() { return this._clearcoat } set clearcoat(e) { this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e } get transmission() { return this._transmission } set transmission(e) { this._transmission > 0 != e > 0 && this.version++, this._transmission = e } copy(e) { return super.copy(e), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this } } Dm.prototype.isMeshPhysicalMaterial = !0; class Lm extends $c { constructor(e) { super(), this.type = "MeshPhongMaterial", this.color = new _l(16777215), this.specular = new _l(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new _l(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new ul(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this } } Lm.prototype.isMeshPhongMaterial = !0; class Am extends $c { constructor(e) { super(), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new _l(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new _l(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new ul(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this } } Am.prototype.isMeshToonMaterial = !0; class Pm extends $c { constructor(e) { super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new ul(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this } } Pm.prototype.isMeshNormalMaterial = !0; class Rm extends $c { constructor(e) { super(), this.type = "MeshLambertMaterial", this.color = new _l(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new _l(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this } } Rm.prototype.isMeshLambertMaterial = !0; class Om extends $c { constructor(e) { super(), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new _l(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new ul(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this } } Om.prototype.isMeshMatcapMaterial = !0; class Im extends lf { constructor(e) { super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e) } copy(e) { return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this } } Im.prototype.isLineDashedMaterial = !0; const Fm = { ShadowMaterial: Mm, SpriteMaterial: Ap, RawShaderMaterial: Tm, ShaderMaterial: Ru, PointsMaterial: xf, MeshPhysicalMaterial: Dm, MeshStandardMaterial: Cm, MeshPhongMaterial: Lm, MeshToonMaterial: Am, MeshNormalMaterial: Pm, MeshLambertMaterial: Rm, MeshDepthMaterial: up, MeshDistanceMaterial: hp, MeshBasicMaterial: Xc, MeshMatcapMaterial: Om, LineDashedMaterial: Im, LineBasicMaterial: lf, Material: $c }; $c.fromType = function (e) { return new Fm[e] }; const zm = { arraySlice: function (e, t, n) { return zm.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n) }, convertArray: function (e, t, n) { return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e) }, isTypedArray: function (e) { return ArrayBuffer.isView(e) && !(e instanceof DataView) }, getKeyframeOrder: function (e) { const t = e.length, n = new Array(t); for (let e = 0; e !== t; ++e)n[e] = e; return n.sort((function (t, n) { return e[t] - e[n] })), n }, sortedArray: function (e, t, n) { const i = e.length, r = new e.constructor(i); for (let s = 0, a = 0; a !== i; ++s) { const i = n[s] * t; for (let n = 0; n !== t; ++n)r[a++] = e[i + n] } return r }, flattenJSON: function (e, t, n, i) { let r = 1, s = e[0]; for (; void 0 !== s && void 0 === s[i];)s = e[r++]; if (void 0 === s) return; let a = s[i]; if (void 0 !== a) if (Array.isArray(a)) do { a = s[i], void 0 !== a && (t.push(s.time), n.push.apply(n, a)), s = e[r++] } while (void 0 !== s); else if (void 0 !== a.toArray) do { a = s[i], void 0 !== a && (t.push(s.time), a.toArray(n, n.length)), s = e[r++] } while (void 0 !== s); else do { a = s[i], void 0 !== a && (t.push(s.time), n.push(a)), s = e[r++] } while (void 0 !== s) }, subclip: function (e, t, n, i, r = 30) { const s = e.clone(); s.name = t; const a = []; for (let e = 0; e < s.tracks.length; ++e) { const t = s.tracks[e], o = t.getValueSize(), l = [], c = []; for (let e = 0; e < t.times.length; ++e) { const s = t.times[e] * r; if (!(s < n || s >= i)) { l.push(t.times[e]); for (let n = 0; n < o; ++n)c.push(t.values[e * o + n]) } } 0 !== l.length && (t.times = zm.convertArray(l, t.times.constructor), t.values = zm.convertArray(c, t.values.constructor), a.push(t)) } s.tracks = a; let o = 1 / 0; for (let e = 0; e < s.tracks.length; ++e)o > s.tracks[e].times[0] && (o = s.tracks[e].times[0]); for (let e = 0; e < s.tracks.length; ++e)s.tracks[e].shift(-1 * o); return s.resetDuration(), s }, makeClipAdditive: function (e, t = 0, n = e, i = 30) { i <= 0 && (i = 30); const r = n.tracks.length, s = t / i; for (let t = 0; t < r; ++t) { const i = n.tracks[t], r = i.ValueTypeName; if ("bool" === r || "string" === r) continue; const a = e.tracks.find((function (e) { return e.name === i.name && e.ValueTypeName === r })); if (void 0 === a) continue; let o = 0; const l = i.getValueSize(); i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o = l / 3); let c = 0; const u = a.getValueSize(); a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = u / 3); const h = i.times.length - 1; let d; if (s <= i.times[0]) { const e = o, t = l - o; d = zm.arraySlice(i.values, e, t) } else if (s >= i.times[h]) { const e = h * l + o, t = e + l - o; d = zm.arraySlice(i.values, e, t) } else { const e = i.createInterpolant(), t = o, n = l - o; e.evaluate(s), d = zm.arraySlice(e.resultBuffer, t, n) } "quaternion" === r && (new Pl).fromArray(d).normalize().conjugate().toArray(d); const p = a.times.length; for (let e = 0; e < p; ++e) { const t = e * u + c; if ("quaternion" === r) Pl.multiplyQuaternionsFlat(a.values, t, d, 0, a.values, t); else { const e = u - 2 * c; for (let n = 0; n < e; ++n)a.values[t + n] -= d[n] } } } return e.blendMode = 2501, e } }; class km { constructor(e, t, n, i) { this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {} } evaluate(e) { const t = this.parameterPositions; let n = this._cachedIndex, i = t[n], r = t[n - 1]; e: { t: { let s; n: { i: if (!(e < i)) { for (let s = n + 2; ;) { if (void 0 === i) { if (e < r) break i; return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, e, r) } if (n === s) break; if (r = i, i = t[++n], e < i) break t } s = t.length; break n } if (e >= r) break e; { const a = t[1]; e < a && (n = 2, r = a); for (let s = n - 2; ;) { if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, e, i); if (n === s) break; if (i = r, r = t[--n - 1], e >= r) break t } s = n, n = 0 } } for (; n < s;) { const i = n + s >>> 1; e < t[i] ? s = i : n = i + 1 } if (i = t[n], r = t[n - 1], void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, e, i); if (void 0 === i) return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, r, e) } this._cachedIndex = n, this.intervalChanged_(n, r, i) } return this.interpolate_(n, r, e, i) } getSettings_() { return this.settings || this.DefaultSettings_ } copySampleValue_(e) { const t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = e * i; for (let e = 0; e !== i; ++e)t[e] = n[r + e]; return t } interpolate_() { throw new Error("call to abstract method") } intervalChanged_() { } } km.prototype.beforeStart_ = km.prototype.copySampleValue_, km.prototype.afterEnd_ = km.prototype.copySampleValue_; class Nm extends km { constructor(e, t, n, i) { super(e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: Uo, endingEnd: Uo } } intervalChanged_(e, t, n) { const i = this.parameterPositions; let r = e - 2, s = e + 1, a = i[r], o = i[s]; if (void 0 === a) switch (this.getSettings_().endingStart) { case Vo: r = e, a = 2 * t - n; break; case Go: r = i.length - 2, a = t + i[r] - i[r + 1]; break; default: r = e, a = n }if (void 0 === o) switch (this.getSettings_().endingEnd) { case Vo: s = e, o = 2 * n - t; break; case Go: s = 1, o = n + i[1] - i[0]; break; default: s = e - 1, o = t }const l = .5 * (n - t), c = this.valueSize; this._weightPrev = l / (t - a), this._weightNext = l / (o - n), this._offsetPrev = r * c, this._offsetNext = s * c } interpolate_(e, t, n, i) { const r = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = e * a, l = o - a, c = this._offsetPrev, u = this._offsetNext, h = this._weightPrev, d = this._weightNext, p = (n - t) / (i - t), f = p * p, m = f * p, g = -h * m + 2 * h * f - h * p, v = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1, y = (-1 - d) * m + (1.5 + d) * f + .5 * p, x = d * m - d * f; for (let e = 0; e !== a; ++e)r[e] = g * s[c + e] + v * s[l + e] + y * s[o + e] + x * s[u + e]; return r } } class Bm extends km { constructor(e, t, n, i) { super(e, t, n, i) } interpolate_(e, t, n, i) { const r = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = e * a, l = o - a, c = (n - t) / (i - t), u = 1 - c; for (let e = 0; e !== a; ++e)r[e] = s[l + e] * u + s[o + e] * c; return r } } class Hm extends km { constructor(e, t, n, i) { super(e, t, n, i) } interpolate_(e) { return this.copySampleValue_(e - 1) } } class Um { constructor(e, t, n, i) { if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e); this.name = e, this.times = zm.convertArray(t, this.TimeBufferType), this.values = zm.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation) } static toJSON(e) { const t = e.constructor; let n; if (t.toJSON !== this.toJSON) n = t.toJSON(e); else { n = { name: e.name, times: zm.convertArray(e.times, Array), values: zm.convertArray(e.values, Array) }; const t = e.getInterpolation(); t !== e.DefaultInterpolation && (n.interpolation = t) } return n.type = e.ValueTypeName, n } InterpolantFactoryMethodDiscrete(e) { return new Hm(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodLinear(e) { return new Bm(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodSmooth(e) { return new Nm(this.times, this.values, this.getValueSize(), e) } setInterpolation(e) { let t; switch (e) { case No: t = this.InterpolantFactoryMethodDiscrete; break; case Bo: t = this.InterpolantFactoryMethodLinear; break; case Ho: t = this.InterpolantFactoryMethodSmooth }if (void 0 === t) { const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (void 0 === this.createInterpolant) { if (e === this.DefaultInterpolation) throw new Error(t); this.setInterpolation(this.DefaultInterpolation) } return console.warn("THREE.KeyframeTrack:", t), this } return this.createInterpolant = t, this } getInterpolation() { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return No; case this.InterpolantFactoryMethodLinear: return Bo; case this.InterpolantFactoryMethodSmooth: return Ho } } getValueSize() { return this.values.length / this.times.length } shift(e) { if (0 !== e) { const t = this.times; for (let n = 0, i = t.length; n !== i; ++n)t[n] += e } return this } scale(e) { if (1 !== e) { const t = this.times; for (let n = 0, i = t.length; n !== i; ++n)t[n] *= e } return this } trim(e, t) { const n = this.times, i = n.length; let r = 0, s = i - 1; for (; r !== i && n[r] < e;)++r; for (; -1 !== s && n[s] > t;)--s; if (++s, 0 !== r || s !== i) { r >= s && (s = Math.max(s, 1), r = s - 1); const e = this.getValueSize(); this.times = zm.arraySlice(n, r, s), this.values = zm.arraySlice(this.values, r * e, s * e) } return this } validate() { let e = !0; const t = this.getValueSize(); t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1); const n = this.times, i = this.values, r = n.length; 0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1); let s = null; for (let t = 0; t !== r; t++) { const i = n[t]; if ("number" == typeof i && isNaN(i)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, t, i), e = !1; break } if (null !== s && s > i) { console.error("THREE.KeyframeTrack: Out of order keys.", this, t, i, s), e = !1; break } s = i } if (void 0 !== i && zm.isTypedArray(i)) for (let t = 0, n = i.length; t !== n; ++t) { const n = i[t]; if (isNaN(n)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, t, n), e = !1; break } } return e } optimize() { const e = zm.arraySlice(this.times), t = zm.arraySlice(this.values), n = this.getValueSize(), i = this.getInterpolation() === Ho, r = e.length - 1; let s = 1; for (let a = 1; a < r; ++a) { let r = !1; const o = e[a]; if (o !== e[a + 1] && (1 !== a || o !== e[0])) if (i) r = !0; else { const e = a * n, i = e - n, s = e + n; for (let a = 0; a !== n; ++a) { const n = t[e + a]; if (n !== t[i + a] || n !== t[s + a]) { r = !0; break } } } if (r) { if (a !== s) { e[s] = e[a]; const i = a * n, r = s * n; for (let e = 0; e !== n; ++e)t[r + e] = t[i + e] } ++s } } if (r > 0) { e[s] = e[r]; for (let e = r * n, i = s * n, a = 0; a !== n; ++a)t[i + a] = t[e + a]; ++s } return s !== e.length ? (this.times = zm.arraySlice(e, 0, s), this.values = zm.arraySlice(t, 0, s * n)) : (this.times = e, this.values = t), this } clone() { const e = zm.arraySlice(this.times, 0), t = zm.arraySlice(this.values, 0), n = new (0, this.constructor)(this.name, e, t); return n.createInterpolant = this.createInterpolant, n } } Um.prototype.TimeBufferType = Float32Array, Um.prototype.ValueBufferType = Float32Array, Um.prototype.DefaultInterpolation = Bo; class Vm extends Um { } Vm.prototype.ValueTypeName = "bool", Vm.prototype.ValueBufferType = Array, Vm.prototype.DefaultInterpolation = No, Vm.prototype.InterpolantFactoryMethodLinear = void 0, Vm.prototype.InterpolantFactoryMethodSmooth = void 0; class Gm extends Um { } Gm.prototype.ValueTypeName = "color"; class jm extends Um { } jm.prototype.ValueTypeName = "number"; class Wm extends km { constructor(e, t, n, i) { super(e, t, n, i) } interpolate_(e, t, n, i) { const r = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = (n - t) / (i - t); let l = e * a; for (let e = l + a; l !== e; l += 4)Pl.slerpFlat(r, 0, s, l - a, s, l, o); return r } } class qm extends Um { InterpolantFactoryMethodLinear(e) { return new Wm(this.times, this.values, this.getValueSize(), e) } } qm.prototype.ValueTypeName = "quaternion", qm.prototype.DefaultInterpolation = Bo, qm.prototype.InterpolantFactoryMethodSmooth = void 0; class $m extends Um { } $m.prototype.ValueTypeName = "string", $m.prototype.ValueBufferType = Array, $m.prototype.DefaultInterpolation = No, $m.prototype.InterpolantFactoryMethodLinear = void 0, $m.prototype.InterpolantFactoryMethodSmooth = void 0; class Xm extends Um { } Xm.prototype.ValueTypeName = "vector"; class Ym { constructor(e, t = -1, n, i = 2500) { this.name = e, this.tracks = n, this.duration = t, this.blendMode = i, this.uuid = nl(), this.duration < 0 && this.resetDuration() } static parse(e) { const t = [], n = e.tracks, i = 1 / (e.fps || 1); for (let e = 0, r = n.length; e !== r; ++e)t.push(Zm(n[e]).scale(i)); const r = new this(e.name, e.duration, t, e.blendMode); return r.uuid = e.uuid, r } static toJSON(e) { const t = [], n = e.tracks, i = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid, blendMode: e.blendMode }; for (let e = 0, i = n.length; e !== i; ++e)t.push(Um.toJSON(n[e])); return i } static CreateFromMorphTargetSequence(e, t, n, i) { const r = t.length, s = []; for (let e = 0; e < r; e++) { let a = [], o = []; a.push((e + r - 1) % r, e, (e + 1) % r), o.push(0, 1, 0); const l = zm.getKeyframeOrder(a); a = zm.sortedArray(a, 1, l), o = zm.sortedArray(o, 1, l), i || 0 !== a[0] || (a.push(r), o.push(o[0])), s.push(new jm(".morphTargetInfluences[" + t[e].name + "]", a, o).scale(1 / n)) } return new this(e, -1, s) } static findByName(e, t) { let n = e; if (!Array.isArray(e)) { const t = e; n = t.geometry && t.geometry.animations || t.animations } for (let e = 0; e < n.length; e++)if (n[e].name === t) return n[e]; return null } static CreateClipsFromMorphTargetSequences(e, t, n) { const i = {}, r = /^([\w-]*?)([\d]+)$/; for (let t = 0, n = e.length; t < n; t++) { const n = e[t], s = n.name.match(r); if (s && s.length > 1) { const e = s[1]; let t = i[e]; t || (i[e] = t = []), t.push(n) } } const s = []; for (const e in i) s.push(this.CreateFromMorphTargetSequence(e, i[e], t, n)); return s } static parseAnimation(e, t) { if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; const n = function (e, t, n, i, r) { if (0 !== n.length) { const s = [], a = []; zm.flattenJSON(n, s, a, i), 0 !== s.length && r.push(new e(t, s, a)) } }, i = [], r = e.name || "default", s = e.fps || 30, a = e.blendMode; let o = e.length || -1; const l = e.hierarchy || []; for (let e = 0; e < l.length; e++) { const r = l[e].keys; if (r && 0 !== r.length) if (r[0].morphTargets) { const e = {}; let t; for (t = 0; t < r.length; t++)if (r[t].morphTargets) for (let n = 0; n < r[t].morphTargets.length; n++)e[r[t].morphTargets[n]] = -1; for (const n in e) { const e = [], s = []; for (let i = 0; i !== r[t].morphTargets.length; ++i) { const i = r[t]; e.push(i.time), s.push(i.morphTarget === n ? 1 : 0) } i.push(new jm(".morphTargetInfluence[" + n + "]", e, s)) } o = e.length * s } else { const s = ".bones[" + t[e].name + "]"; n(Xm, s + ".position", r, "pos", i), n(qm, s + ".quaternion", r, "rot", i), n(Xm, s + ".scale", r, "scl", i) } } return 0 === i.length ? null : new this(r, o, i, a) } resetDuration() { let e = 0; for (let t = 0, n = this.tracks.length; t !== n; ++t) { const n = this.tracks[t]; e = Math.max(e, n.times[n.times.length - 1]) } return this.duration = e, this } trim() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].trim(0, this.duration); return this } validate() { let e = !0; for (let t = 0; t < this.tracks.length; t++)e = e && this.tracks[t].validate(); return e } optimize() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].optimize(); return this } clone() { const e = []; for (let t = 0; t < this.tracks.length; t++)e.push(this.tracks[t].clone()); return new this.constructor(this.name, this.duration, e, this.blendMode) } toJSON() { return this.constructor.toJSON(this) } } function Zm(e) { if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); const t = function (e) { switch (e.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return jm; case "vector": case "vector2": case "vector3": case "vector4": return Xm; case "color": return Gm; case "quaternion": return qm; case "bool": case "boolean": return Vm; case "string": return $m }throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e) }(e.type); if (void 0 === e.times) { const t = [], n = []; zm.flattenJSON(e.keys, t, n, "value"), e.times = t, e.values = n } return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation) } const Km = { enabled: !1, files: {}, add: function (e, t) { !1 !== this.enabled && (this.files[e] = t) }, get: function (e) { if (!1 !== this.enabled) return this.files[e] }, remove: function (e) { delete this.files[e] }, clear: function () { this.files = {} } }; const Jm = new class { constructor(e, t, n) { const i = this; let r, s = !1, a = 0, o = 0; const l = []; this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function (e) { o++, !1 === s && void 0 !== i.onStart && i.onStart(e, a, o), s = !0 }, this.itemEnd = function (e) { a++, void 0 !== i.onProgress && i.onProgress(e, a, o), a === o && (s = !1, void 0 !== i.onLoad && i.onLoad()) }, this.itemError = function (e) { void 0 !== i.onError && i.onError(e) }, this.resolveURL = function (e) { return r ? r(e) : e }, this.setURLModifier = function (e) { return r = e, this }, this.addHandler = function (e, t) { return l.push(e, t), this }, this.removeHandler = function (e) { const t = l.indexOf(e); return -1 !== t && l.splice(t, 2), this }, this.getHandler = function (e) { for (let t = 0, n = l.length; t < n; t += 2) { const n = l[t], i = l[t + 1]; if (n.global && (n.lastIndex = 0), n.test(e)) return i } return null } } }; class Qm { constructor(e) { this.manager = void 0 !== e ? e : Jm, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {} } load() { } loadAsync(e, t) { const n = this; return new Promise((function (i, r) { n.load(e, i, t, r) })) } parse() { } setCrossOrigin(e) { return this.crossOrigin = e, this } setWithCredentials(e) { return this.withCredentials = e, this } setPath(e) { return this.path = e, this } setResourcePath(e) { return this.resourcePath = e, this } setRequestHeader(e) { return this.requestHeader = e, this } } const eg = {}; class tg extends Qm { constructor(e) { super(e) } load(e, t, n, i) { void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); const r = Km.get(e); if (void 0 !== r) return this.manager.itemStart(e), setTimeout((() => { t && t(r), this.manager.itemEnd(e) }), 0), r; if (void 0 !== eg[e]) return void eg[e].push({ onLoad: t, onProgress: n, onError: i }); eg[e] = [], eg[e].push({ onLoad: t, onProgress: n, onError: i }); const s = new Request(e, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }), a = this.mimeType, o = this.responseType; fetch(s).then((t => { if (200 === t.status || 0 === t.status) { if (0 === t.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === t.body || void 0 === t.body.getReader) return t; const n = eg[e], i = t.body.getReader(), r = t.headers.get("Content-Length"), s = r ? parseInt(r) : 0, a = 0 !== s; let o = 0; const l = new ReadableStream({ start(e) { !function t() { i.read().then((({ done: i, value: r }) => { if (i) e.close(); else { o += r.byteLength; const i = new ProgressEvent("progress", { lengthComputable: a, loaded: o, total: s }); for (let e = 0, t = n.length; e < t; e++) { const t = n[e]; t.onProgress && t.onProgress(i) } e.enqueue(r), t() } })) }() } }); return new Response(l) } throw Error(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`) })).then((e => { switch (o) { case "arraybuffer": return e.arrayBuffer(); case "blob": return e.blob(); case "document": return e.text().then((e => (new DOMParser).parseFromString(e, a))); case "json": return e.json(); default: if (void 0 === a) return e.text(); { const t = /charset="?([^;"\s]*)"?/i.exec(a), n = t && t[1] ? t[1].toLowerCase() : void 0, i = new TextDecoder(n); return e.arrayBuffer().then((e => i.decode(e))) } } })).then((t => { Km.add(e, t); const n = eg[e]; delete eg[e]; for (let e = 0, i = n.length; e < i; e++) { const i = n[e]; i.onLoad && i.onLoad(t) } })).catch((t => { const n = eg[e]; if (void 0 === n) throw this.manager.itemError(e), t; delete eg[e]; for (let e = 0, i = n.length; e < i; e++) { const i = n[e]; i.onError && i.onError(t) } this.manager.itemError(e) })).finally((() => { this.manager.itemEnd(e) })), this.manager.itemStart(e) } setResponseType(e) { return this.responseType = e, this } setMimeType(e) { return this.mimeType = e, this } } class ng extends Qm { constructor(e) { super(e) } load(e, t, n, i) { void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); const r = this, s = Km.get(e); if (void 0 !== s) return r.manager.itemStart(e), setTimeout((function () { t && t(s), r.manager.itemEnd(e) }), 0), s; const a = pl("img"); function o() { c(), Km.add(e, this), t && t(this), r.manager.itemEnd(e) } function l(t) { c(), i && i(t), r.manager.itemError(e), r.manager.itemEnd(e) } function c() { a.removeEventListener("load", o, !1), a.removeEventListener("error", l, !1) } return a.addEventListener("load", o, !1), a.addEventListener("error", l, !1), "data:" !== e.slice(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(e), a.src = e, a } } class ig extends Qm { constructor(e) { super(e) } load(e, t, n, i) { const r = new ku, s = new ng(this.manager); s.setCrossOrigin(this.crossOrigin), s.setPath(this.path); let a = 0; function o(n) { s.load(e[n], (function (e) { r.images[n] = e, a++, 6 === a && (r.needsUpdate = !0, t && t(r)) }), void 0, i) } for (let t = 0; t < e.length; ++t)o(t); return r } } class rg extends Qm { constructor(e) { super(e) } load(e, t, n, i) { const r = new Tl, s = new ng(this.manager); return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(e, (function (e) { r.image = e, r.needsUpdate = !0, void 0 !== t && t(r) }), n, i), r } } class sg extends Ic { constructor(e, t = 1) { super(), this.type = "Light", this.color = new _l(e), this.intensity = t } dispose() { } copy(e) { return super.copy(e), this.color.copy(e.color), this.intensity = e.intensity, this } toJSON(e) { const t = super.toJSON(e); return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t } } sg.prototype.isLight = !0; (class extends sg { constructor(e, t, n) { super(e, n), this.type = "HemisphereLight", this.position.copy(Ic.DefaultUp), this.updateMatrix(), this.groundColor = new _l(t) } copy(e) { return sg.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this } }).prototype.isHemisphereLight = !0; const ag = new cc, og = new Rl, lg = new Rl; class cg { constructor(e) { this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new ul(512, 512), this.map = null, this.mapPass = null, this.matrix = new cc, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Wu, this._frameExtents = new ul(1, 1), this._viewportCount = 1, this._viewports = [new Cl(0, 0, 1, 1)] } getViewportCount() { return this._viewportCount } getFrustum() { return this._frustum } updateMatrices(e) { const t = this.camera, n = this.matrix; og.setFromMatrixPosition(e.matrixWorld), t.position.copy(og), lg.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(lg), t.updateMatrixWorld(), ag.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(ag), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(t.projectionMatrix), n.multiply(t.matrixWorldInverse) } getViewport(e) { return this._viewports[e] } getFrameExtents() { return this._frameExtents } dispose() { this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose() } copy(e) { return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this } clone() { return (new this.constructor).copy(this) } toJSON() { const e = {}; return 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e } } class ug extends cg { constructor() { super(new Iu(50, 1, .5, 500)), this.focus = 1 } updateMatrices(e) { const t = this.camera, n = 2 * tl * e.angle * this.focus, i = this.mapSize.width / this.mapSize.height, r = e.distance || t.far; n === t.fov && i === t.aspect && r === t.far || (t.fov = n, t.aspect = i, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e) } copy(e) { return super.copy(e), this.focus = e.focus, this } } ug.prototype.isSpotLightShadow = !0; class hg extends sg { constructor(e, t, n = 0, i = Math.PI / 3, r = 0, s = 1) { super(e, t), this.type = "SpotLight", this.position.copy(Ic.DefaultUp), this.updateMatrix(), this.target = new Ic, this.distance = n, this.angle = i, this.penumbra = r, this.decay = s, this.shadow = new ug } get power() { return this.intensity * Math.PI } set power(e) { this.intensity = e / Math.PI } dispose() { this.shadow.dispose() } copy(e) { return super.copy(e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } hg.prototype.isSpotLight = !0; const dg = new cc, pg = new Rl, fg = new Rl; class mg extends cg { constructor() { super(new Iu(90, 1, .5, 500)), this._frameExtents = new ul(4, 2), this._viewportCount = 6, this._viewports = [new Cl(2, 1, 1, 1), new Cl(0, 1, 1, 1), new Cl(3, 1, 1, 1), new Cl(1, 1, 1, 1), new Cl(3, 0, 1, 1), new Cl(1, 0, 1, 1)], this._cubeDirections = [new Rl(1, 0, 0), new Rl(-1, 0, 0), new Rl(0, 0, 1), new Rl(0, 0, -1), new Rl(0, 1, 0), new Rl(0, -1, 0)], this._cubeUps = [new Rl(0, 1, 0), new Rl(0, 1, 0), new Rl(0, 1, 0), new Rl(0, 1, 0), new Rl(0, 0, 1), new Rl(0, 0, -1)] } updateMatrices(e, t = 0) { const n = this.camera, i = this.matrix, r = e.distance || n.far; r !== n.far && (n.far = r, n.updateProjectionMatrix()), pg.setFromMatrixPosition(e.matrixWorld), n.position.copy(pg), fg.copy(n.position), fg.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(fg), n.updateMatrixWorld(), i.makeTranslation(-pg.x, -pg.y, -pg.z), dg.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(dg) } } mg.prototype.isPointLightShadow = !0; class gg extends sg { constructor(e, t, n = 0, i = 1) { super(e, t), this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new mg } get power() { return 4 * this.intensity * Math.PI } set power(e) { this.intensity = e / (4 * Math.PI) } dispose() { this.shadow.dispose() } copy(e) { return super.copy(e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this } } gg.prototype.isPointLight = !0; class vg extends cg { constructor() { super(new rh(-5, 5, 5, -5, .5, 500)) } } vg.prototype.isDirectionalLightShadow = !0; class yg extends sg { constructor(e, t) { super(e, t), this.type = "DirectionalLight", this.position.copy(Ic.DefaultUp), this.updateMatrix(), this.target = new Ic, this.shadow = new vg } dispose() { this.shadow.dispose() } copy(e) { return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } yg.prototype.isDirectionalLight = !0; (class extends sg { constructor(e, t) { super(e, t), this.type = "AmbientLight" } }).prototype.isAmbientLight = !0; (class extends sg { constructor(e, t, n = 10, i = 10) { super(e, t), this.type = "RectAreaLight", this.width = n, this.height = i } get power() { return this.intensity * this.width * this.height * Math.PI } set power(e) { this.intensity = e / (this.width * this.height * Math.PI) } copy(e) { return super.copy(e), this.width = e.width, this.height = e.height, this } toJSON(e) { const t = super.toJSON(e); return t.object.width = this.width, t.object.height = this.height, t } }).prototype.isRectAreaLight = !0; class xg { constructor() { this.coefficients = []; for (let e = 0; e < 9; e++)this.coefficients.push(new Rl) } set(e) { for (let t = 0; t < 9; t++)this.coefficients[t].copy(e[t]); return this } zero() { for (let e = 0; e < 9; e++)this.coefficients[e].set(0, 0, 0); return this } getAt(e, t) { const n = e.x, i = e.y, r = e.z, s = this.coefficients; return t.copy(s[0]).multiplyScalar(.282095), t.addScaledVector(s[1], .488603 * i), t.addScaledVector(s[2], .488603 * r), t.addScaledVector(s[3], .488603 * n), t.addScaledVector(s[4], n * i * 1.092548), t.addScaledVector(s[5], i * r * 1.092548), t.addScaledVector(s[6], .315392 * (3 * r * r - 1)), t.addScaledVector(s[7], n * r * 1.092548), t.addScaledVector(s[8], .546274 * (n * n - i * i)), t } getIrradianceAt(e, t) { const n = e.x, i = e.y, r = e.z, s = this.coefficients; return t.copy(s[0]).multiplyScalar(.886227), t.addScaledVector(s[1], 1.023328 * i), t.addScaledVector(s[2], 1.023328 * r), t.addScaledVector(s[3], 1.023328 * n), t.addScaledVector(s[4], .858086 * n * i), t.addScaledVector(s[5], .858086 * i * r), t.addScaledVector(s[6], .743125 * r * r - .247708), t.addScaledVector(s[7], .858086 * n * r), t.addScaledVector(s[8], .429043 * (n * n - i * i)), t } add(e) { for (let t = 0; t < 9; t++)this.coefficients[t].add(e.coefficients[t]); return this } addScaledSH(e, t) { for (let n = 0; n < 9; n++)this.coefficients[n].addScaledVector(e.coefficients[n], t); return this } scale(e) { for (let t = 0; t < 9; t++)this.coefficients[t].multiplyScalar(e); return this } lerp(e, t) { for (let n = 0; n < 9; n++)this.coefficients[n].lerp(e.coefficients[n], t); return this } equals(e) { for (let t = 0; t < 9; t++)if (!this.coefficients[t].equals(e.coefficients[t])) return !1; return !0 } copy(e) { return this.set(e.coefficients) } clone() { return (new this.constructor).copy(this) } fromArray(e, t = 0) { const n = this.coefficients; for (let i = 0; i < 9; i++)n[i].fromArray(e, t + 3 * i); return this } toArray(e = [], t = 0) { const n = this.coefficients; for (let i = 0; i < 9; i++)n[i].toArray(e, t + 3 * i); return e } static getBasisAt(e, t) { const n = e.x, i = e.y, r = e.z; t[0] = .282095, t[1] = .488603 * i, t[2] = .488603 * r, t[3] = .488603 * n, t[4] = 1.092548 * n * i, t[5] = 1.092548 * i * r, t[6] = .315392 * (3 * r * r - 1), t[7] = 1.092548 * n * r, t[8] = .546274 * (n * n - i * i) } } xg.prototype.isSphericalHarmonics3 = !0; class _g extends sg { constructor(e = new xg, t = 1) { super(void 0, t), this.sh = e } copy(e) { return super.copy(e), this.sh.copy(e.sh), this } fromJSON(e) { return this.intensity = e.intensity, this.sh.fromArray(e.sh), this } toJSON(e) { const t = super.toJSON(e); return t.object.sh = this.sh.toArray(), t } } _g.prototype.isLightProbe = !0; class wg { static decodeText(e) { if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e); let t = ""; for (let n = 0, i = e.length; n < i; n++)t += String.fromCharCode(e[n]); try { return decodeURIComponent(escape(t)) } catch (e) { return t } } static extractUrlBase(e) { const t = e.lastIndexOf("/"); return -1 === t ? "./" : e.slice(0, t + 1) } static resolveURL(e, t) { return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e) } } (class extends lu { constructor() { super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0 } copy(e) { return super.copy(e), this.instanceCount = e.instanceCount, this } clone() { return (new this.constructor).copy(this) } toJSON() { const e = super.toJSON(this); return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e } }).prototype.isInstancedBufferGeometry = !0; class bg extends Qm { constructor(e) { super(e), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" } } setOptions(e) { return this.options = e, this } load(e, t, n, i) { void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); const r = this, s = Km.get(e); if (void 0 !== s) return r.manager.itemStart(e), setTimeout((function () { t && t(s), r.manager.itemEnd(e) }), 0), s; const a = {}; a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", a.headers = this.requestHeader, fetch(e, a).then((function (e) { return e.blob() })).then((function (e) { return createImageBitmap(e, Object.assign(r.options, { colorSpaceConversion: "none" })) })).then((function (n) { Km.add(e, n), t && t(n), r.manager.itemEnd(e) })).catch((function (t) { i && i(t), r.manager.itemError(e), r.manager.itemEnd(e) })), r.manager.itemStart(e) } } let Sg; bg.prototype.isImageBitmapLoader = !0; class Eg extends Qm { constructor(e) { super(e) } load(e, t, n, i) { const r = this, s = new tg(this.manager); s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (function (n) { try { const e = n.slice(0); (void 0 === Sg && (Sg = new (window.AudioContext || window.webkitAudioContext)), Sg).decodeAudioData(e, (function (e) { t(e) })) } catch (t) { i ? i(t) : console.error(t), r.manager.itemError(e) } }), n, i) } } (class extends _g { constructor(e, t, n = 1) { super(void 0, n); const i = (new _l).set(e), r = (new _l).set(t), s = new Rl(i.r, i.g, i.b), a = new Rl(r.r, r.g, r.b), o = Math.sqrt(Math.PI), l = o * Math.sqrt(.75); this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o), this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l) } }).prototype.isHemisphereLightProbe = !0, class extends _g { constructor(e, t = 1) { super(void 0, t); const n = (new _l).set(e); this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI)) } }.prototype.isAmbientLightProbe = !0; class Mg { constructor(e = !0) { this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 } start() { this.startTime = Tg(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 } stop() { this.getElapsedTime(), this.running = !1, this.autoStart = !1 } getElapsedTime() { return this.getDelta(), this.elapsedTime } getDelta() { let e = 0; if (this.autoStart && !this.running) return this.start(), 0; if (this.running) { const t = Tg(); e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e } return e } } function Tg() { return ("undefined" == typeof performance ? Date : performance).now() } class Cg { constructor(e, t, n) { let i, r, s; switch (this.binding = e, this.valueSize = n, t) { case "quaternion": i = this._slerp, r = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5; break; case "string": case "bool": i = this._select, r = this._select, s = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n); break; default: i = this._lerp, r = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n) }this._mixBufferRegion = i, this._mixBufferRegionAdditive = r, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0 } accumulate(e, t) { const n = this.buffer, i = this.valueSize, r = e * i + i; let s = this.cumulativeWeight; if (0 === s) { for (let e = 0; e !== i; ++e)n[r + e] = n[e]; s = t } else { s += t; const e = t / s; this._mixBufferRegion(n, r, 0, e, i) } this.cumulativeWeight = s } accumulateAdditive(e) { const t = this.buffer, n = this.valueSize, i = n * this._addIndex; 0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t, i, 0, e, n), this.cumulativeWeightAdditive += e } apply(e) { const t = this.valueSize, n = this.buffer, i = e * t + t, r = this.cumulativeWeight, s = this.cumulativeWeightAdditive, a = this.binding; if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) { const e = t * this._origIndex; this._mixBufferRegion(n, i, e, 1 - r, t) } s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t); for (let e = t, r = t + t; e !== r; ++e)if (n[e] !== n[e + t]) { a.setValue(n, i); break } } saveOriginalState() { const e = this.binding, t = this.buffer, n = this.valueSize, i = n * this._origIndex; e.getValue(t, i); for (let e = n, r = i; e !== r; ++e)t[e] = t[i + e % n]; this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0 } restoreOriginalState() { const e = 3 * this.valueSize; this.binding.setValue(this.buffer, e) } _setAdditiveIdentityNumeric() { const e = this._addIndex * this.valueSize, t = e + this.valueSize; for (let n = e; n < t; n++)this.buffer[n] = 0 } _setAdditiveIdentityQuaternion() { this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1 } _setAdditiveIdentityOther() { const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize; for (let n = 0; n < this.valueSize; n++)this.buffer[t + n] = this.buffer[e + n] } _select(e, t, n, i, r) { if (i >= .5) for (let i = 0; i !== r; ++i)e[t + i] = e[n + i] } _slerp(e, t, n, i) { Pl.slerpFlat(e, t, e, t, e, n, i) } _slerpAdditive(e, t, n, i, r) { const s = this._workIndex * r; Pl.multiplyQuaternionsFlat(e, s, e, t, e, n), Pl.slerpFlat(e, t, e, t, e, s, i) } _lerp(e, t, n, i, r) { const s = 1 - i; for (let a = 0; a !== r; ++a) { const r = t + a; e[r] = e[r] * s + e[n + a] * i } } _lerpAdditive(e, t, n, i, r) { for (let s = 0; s !== r; ++s) { const r = t + s; e[r] = e[r] + e[n + s] * i } } } const Dg = new RegExp("[\\[\\]\\.:\\/]", "g"), Lg = "[^\\[\\]\\.:\\/]", Ag = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", Pg = /((?:WC+[\/:])*)/.source.replace("WC", Lg), Rg = /(WCOD+)?/.source.replace("WCOD", Ag), Og = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Lg), Ig = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Lg), Fg = new RegExp("^" + Pg + Rg + Og + Ig + "$"), zg = ["material", "materials", "bones"]; class kg { constructor(e, t, n) { this.path = t, this.parsedPath = n || kg.parseTrackName(t), this.node = kg.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } static create(e, t, n) { return e && e.isAnimationObjectGroup ? new kg.Composite(e, t, n) : new kg(e, t, n) } static sanitizeNodeName(e) { return e.replace(/\s/g, "_").replace(Dg, "") } static parseTrackName(e) { const t = Fg.exec(e); if (null === t) throw new Error("PropertyBinding: Cannot parse trackName: " + e); const n = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] }, i = n.nodeName && n.nodeName.lastIndexOf("."); if (void 0 !== i && -1 !== i) { const e = n.nodeName.substring(i + 1); -1 !== zg.indexOf(e) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = e) } if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e); return n } static findNode(e, t) { if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e; if (e.skeleton) { const n = e.skeleton.getBoneByName(t); if (void 0 !== n) return n } if (e.children) { const n = function (e) { for (let i = 0; i < e.length; i++) { const r = e[i]; if (r.name === t || r.uuid === t) return r; const s = n(r.children); if (s) return s } return null }, i = n(e.children); if (i) return i } return null } _getValue_unavailable() { } _setValue_unavailable() { } _getValue_direct(e, t) { e[t] = this.targetObject[this.propertyName] } _getValue_array(e, t) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i)e[t++] = n[i] } _getValue_arrayElement(e, t) { e[t] = this.resolvedProperty[this.propertyIndex] } _getValue_toArray(e, t) { this.resolvedProperty.toArray(e, t) } _setValue_direct(e, t) { this.targetObject[this.propertyName] = e[t] } _setValue_direct_setNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0 } _setValue_direct_setMatrixWorldNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_array(e, t) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i)n[i] = e[t++] } _setValue_array_setNeedsUpdate(e, t) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i)n[i] = e[t++]; this.targetObject.needsUpdate = !0 } _setValue_array_setMatrixWorldNeedsUpdate(e, t) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i)n[i] = e[t++]; this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_arrayElement(e, t) { this.resolvedProperty[this.propertyIndex] = e[t] } _setValue_arrayElement_setNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0 } _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_fromArray(e, t) { this.resolvedProperty.fromArray(e, t) } _setValue_fromArray_setNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0 } _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0 } _getValue_unbound(e, t) { this.bind(), this.getValue(e, t) } _setValue_unbound(e, t) { this.bind(), this.setValue(e, t) } bind() { let e = this.node; const t = this.parsedPath, n = t.objectName, i = t.propertyName; let r = t.propertyIndex; if (e || (e = kg.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found."); if (n) { let i = t.objectIndex; switch (n) { case "materials": if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); e = e.material.materials; break; case "bones": if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); e = e.skeleton.bones; for (let t = 0; t < e.length; t++)if (e[t].name === i) { i = t; break } break; default: if (void 0 === e[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); e = e[n] }if (void 0 !== i) { if (void 0 === e[i]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e); e = e[i] } } const s = e[i]; if (void 0 === s) { const n = t.nodeName; return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", e) } let a = this.Versioning.None; this.targetObject = e, void 0 !== e.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate); let o = this.BindingType.Direct; if (void 0 !== r) { if ("morphTargetInfluences" === i) { if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); if (!e.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this); if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); void 0 !== e.morphTargetDictionary[r] && (r = e.morphTargetDictionary[r]) } o = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r } else void 0 !== s.fromArray && void 0 !== s.toArray ? (o = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (o = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i; this.getValue = this.GetterByBindingType[o], this.setValue = this.SetterByBindingTypeAndVersioning[o][a] } unbind() { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } } kg.Composite = class { constructor(e, t, n) { const i = n || kg.parseTrackName(t); this._targetGroup = e, this._bindings = e.subscribe_(t, i) } getValue(e, t) { this.bind(); const n = this._targetGroup.nCachedObjects_, i = this._bindings[n]; void 0 !== i && i.getValue(e, t) } setValue(e, t) { const n = this._bindings; for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)n[i].setValue(e, t) } bind() { const e = this._bindings; for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)e[t].bind() } unbind() { const e = this._bindings; for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)e[t].unbind() } }, kg.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, kg.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, kg.prototype.GetterByBindingType = [kg.prototype._getValue_direct, kg.prototype._getValue_array, kg.prototype._getValue_arrayElement, kg.prototype._getValue_toArray], kg.prototype.SetterByBindingTypeAndVersioning = [[kg.prototype._setValue_direct, kg.prototype._setValue_direct_setNeedsUpdate, kg.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [kg.prototype._setValue_array, kg.prototype._setValue_array_setNeedsUpdate, kg.prototype._setValue_array_setMatrixWorldNeedsUpdate], [kg.prototype._setValue_arrayElement, kg.prototype._setValue_arrayElement_setNeedsUpdate, kg.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [kg.prototype._setValue_fromArray, kg.prototype._setValue_fromArray_setNeedsUpdate, kg.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]]; class Ng { constructor(e, t, n = null, i = t.blendMode) { this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = i; const r = t.tracks, s = r.length, a = new Array(s), o = { endingStart: Uo, endingEnd: Uo }; for (let e = 0; e !== s; ++e) { const t = r[e].createInterpolant(null); a[e] = t, t.settings = o } this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0 } play() { return this._mixer._activateAction(this), this } stop() { return this._mixer._deactivateAction(this), this.reset() } reset() { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() } isRunning() { return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this) } isScheduled() { return this._mixer._isActiveAction(this) } startAt(e) { return this._startTime = e, this } setLoop(e, t) { return this.loop = e, this.repetitions = t, this } setEffectiveWeight(e) { return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading() } getEffectiveWeight() { return this._effectiveWeight } fadeIn(e) { return this._scheduleFading(e, 0, 1) } fadeOut(e) { return this._scheduleFading(e, 1, 0) } crossFadeFrom(e, t, n) { if (e.fadeOut(t), this.fadeIn(t), n) { const n = this._clip.duration, i = e._clip.duration, r = i / n, s = n / i; e.warp(1, r, t), this.warp(s, 1, t) } return this } crossFadeTo(e, t, n) { return e.crossFadeFrom(this, t, n) } stopFading() { const e = this._weightInterpolant; return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } setEffectiveTimeScale(e) { return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping() } getEffectiveTimeScale() { return this._effectiveTimeScale } setDuration(e) { return this.timeScale = this._clip.duration / e, this.stopWarping() } syncWith(e) { return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping() } halt(e) { return this.warp(this._effectiveTimeScale, 0, e) } warp(e, t, n) { const i = this._mixer, r = i.time, s = this.timeScale; let a = this._timeScaleInterpolant; null === a && (a = i._lendControlInterpolant(), this._timeScaleInterpolant = a); const o = a.parameterPositions, l = a.sampleValues; return o[0] = r, o[1] = r + n, l[0] = e / s, l[1] = t / s, this } stopWarping() { const e = this._timeScaleInterpolant; return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } getMixer() { return this._mixer } getClip() { return this._clip } getRoot() { return this._localRoot || this._mixer._root } _update(e, t, n, i) { if (!this.enabled) return void this._updateWeight(e); const r = this._startTime; if (null !== r) { const i = (e - r) * n; if (i < 0 || 0 === n) return; this._startTime = null, t = n * i } t *= this._updateTimeScale(e); const s = this._updateTime(t), a = this._updateWeight(e); if (a > 0) { const e = this._interpolants, t = this._propertyBindings; if (2501 === this.blendMode) for (let n = 0, i = e.length; n !== i; ++n)e[n].evaluate(s), t[n].accumulateAdditive(a); else for (let n = 0, r = e.length; n !== r; ++n)e[n].evaluate(s), t[n].accumulate(i, a) } } _updateWeight(e) { let t = 0; if (this.enabled) { t = this.weight; const n = this._weightInterpolant; if (null !== n) { const i = n.evaluate(e)[0]; t *= i, e > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1)) } } return this._effectiveWeight = t, t } _updateTimeScale(e) { let t = 0; if (!this.paused) { t = this.timeScale; const n = this._timeScaleInterpolant; null !== n && (t *= n.evaluate(e)[0], e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t)) } return this._effectiveTimeScale = t, t } _updateTime(e) { const t = this._clip.duration, n = this.loop; let i = this.time + e, r = this._loopCount; const s = 2202 === n; if (0 === e) return -1 === r ? i : s && 1 == (1 & r) ? t - i : i; if (2200 === n) { -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1)); e: { if (i >= t) i = t; else { if (!(i < 0)) { this.time = i; break e } i = 0 } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = i, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 }) } } else { if (-1 === r && (e >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)), i >= t || i < 0) { const n = Math.floor(i / t); i -= t * n, r += Math.abs(n); const a = this.repetitions - r; if (a <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = e > 0 ? t : 0, this.time = i, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e > 0 ? 1 : -1 }); else { if (1 === a) { const t = e < 0; this._setEndings(t, !t, s) } else this._setEndings(!1, !1, s); this._loopCount = r, this.time = i, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: n }) } } else this.time = i; if (s && 1 == (1 & r)) return t - i } return i } _setEndings(e, t, n) { const i = this._interpolantSettings; n ? (i.endingStart = Vo, i.endingEnd = Vo) : (i.endingStart = e ? this.zeroSlopeAtStart ? Vo : Uo : Go, i.endingEnd = t ? this.zeroSlopeAtEnd ? Vo : Uo : Go) } _scheduleFading(e, t, n) { const i = this._mixer, r = i.time; let s = this._weightInterpolant; null === s && (s = i._lendControlInterpolant(), this._weightInterpolant = s); const a = s.parameterPositions, o = s.sampleValues; return a[0] = r, o[0] = t, a[1] = r + e, o[1] = n, this } } (class extends Ko { constructor(e) { super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 } _bindAction(e, t) { const n = e._localRoot || this._root, i = e._clip.tracks, r = i.length, s = e._propertyBindings, a = e._interpolants, o = n.uuid, l = this._bindingsByRootAndName; let c = l[o]; void 0 === c && (c = {}, l[o] = c); for (let e = 0; e !== r; ++e) { const r = i[e], l = r.name; let u = c[l]; if (void 0 !== u) ++u.referenceCount, s[e] = u; else { if (u = s[e], void 0 !== u) { null === u._cacheIndex && (++u.referenceCount, this._addInactiveBinding(u, o, l)); continue } const i = t && t._propertyBindings[e].binding.parsedPath; u = new Cg(kg.create(n, l, i), r.ValueTypeName, r.getValueSize()), ++u.referenceCount, this._addInactiveBinding(u, o, l), s[e] = u } a[e].resultBuffer = u.buffer } } _activateAction(e) { if (!this._isActiveAction(e)) { if (null === e._cacheIndex) { const t = (e._localRoot || this._root).uuid, n = e._clip.uuid, i = this._actionsByClip[n]; this._bindAction(e, i && i.knownActions[0]), this._addInactiveAction(e, n, t) } const t = e._propertyBindings; for (let e = 0, n = t.length; e !== n; ++e) { const n = t[e]; 0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState()) } this._lendAction(e) } } _deactivateAction(e) { if (this._isActiveAction(e)) { const t = e._propertyBindings; for (let e = 0, n = t.length; e !== n; ++e) { const n = t[e]; 0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n)) } this._takeBackAction(e) } } _initMemoryManager() { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; const e = this; this.stats = { actions: { get total() { return e._actions.length }, get inUse() { return e._nActiveActions } }, bindings: { get total() { return e._bindings.length }, get inUse() { return e._nActiveBindings } }, controlInterpolants: { get total() { return e._controlInterpolants.length }, get inUse() { return e._nActiveControlInterpolants } } } } _isActiveAction(e) { const t = e._cacheIndex; return null !== t && t < this._nActiveActions } _addInactiveAction(e, t, n) { const i = this._actions, r = this._actionsByClip; let s = r[t]; if (void 0 === s) s = { knownActions: [e], actionByRoot: {} }, e._byClipCacheIndex = 0, r[t] = s; else { const t = s.knownActions; e._byClipCacheIndex = t.length, t.push(e) } e._cacheIndex = i.length, i.push(e), s.actionByRoot[n] = e } _removeInactiveAction(e) { const t = this._actions, n = t[t.length - 1], i = e._cacheIndex; n._cacheIndex = i, t[i] = n, t.pop(), e._cacheIndex = null; const r = e._clip.uuid, s = this._actionsByClip, a = s[r], o = a.knownActions, l = o[o.length - 1], c = e._byClipCacheIndex; l._byClipCacheIndex = c, o[c] = l, o.pop(), e._byClipCacheIndex = null, delete a.actionByRoot[(e._localRoot || this._root).uuid], 0 === o.length && delete s[r], this._removeInactiveBindingsForAction(e) } _removeInactiveBindingsForAction(e) { const t = e._propertyBindings; for (let e = 0, n = t.length; e !== n; ++e) { const n = t[e]; 0 == --n.referenceCount && this._removeInactiveBinding(n) } } _lendAction(e) { const t = this._actions, n = e._cacheIndex, i = this._nActiveActions++, r = t[i]; e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r } _takeBackAction(e) { const t = this._actions, n = e._cacheIndex, i = --this._nActiveActions, r = t[i]; e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r } _addInactiveBinding(e, t, n) { const i = this._bindingsByRootAndName, r = this._bindings; let s = i[t]; void 0 === s && (s = {}, i[t] = s), s[n] = e, e._cacheIndex = r.length, r.push(e) } _removeInactiveBinding(e) { const t = this._bindings, n = e.binding, i = n.rootNode.uuid, r = n.path, s = this._bindingsByRootAndName, a = s[i], o = t[t.length - 1], l = e._cacheIndex; o._cacheIndex = l, t[l] = o, t.pop(), delete a[r], 0 === Object.keys(a).length && delete s[i] } _lendBinding(e) { const t = this._bindings, n = e._cacheIndex, i = this._nActiveBindings++, r = t[i]; e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r } _takeBackBinding(e) { const t = this._bindings, n = e._cacheIndex, i = --this._nActiveBindings, r = t[i]; e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r } _lendControlInterpolant() { const e = this._controlInterpolants, t = this._nActiveControlInterpolants++; let n = e[t]; return void 0 === n && (n = new Bm(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = t, e[t] = n), n } _takeBackControlInterpolant(e) { const t = this._controlInterpolants, n = e.__cacheIndex, i = --this._nActiveControlInterpolants, r = t[i]; e.__cacheIndex = i, t[i] = e, r.__cacheIndex = n, t[n] = r } clipAction(e, t, n) { const i = t || this._root, r = i.uuid; let s = "string" == typeof e ? Ym.findByName(i, e) : e; const a = null !== s ? s.uuid : e, o = this._actionsByClip[a]; let l = null; if (void 0 === n && (n = null !== s ? s.blendMode : 2500), void 0 !== o) { const e = o.actionByRoot[r]; if (void 0 !== e && e.blendMode === n) return e; l = o.knownActions[0], null === s && (s = l._clip) } if (null === s) return null; const c = new Ng(this, s, t, n); return this._bindAction(c, l), this._addInactiveAction(c, a, r), c } existingAction(e, t) { const n = t || this._root, i = n.uuid, r = "string" == typeof e ? Ym.findByName(n, e) : e, s = r ? r.uuid : e, a = this._actionsByClip[s]; return void 0 !== a && a.actionByRoot[i] || null } stopAllAction() { const e = this._actions; for (let t = this._nActiveActions - 1; t >= 0; --t)e[t].stop(); return this } update(e) { e *= this.timeScale; const t = this._actions, n = this._nActiveActions, i = this.time += e, r = Math.sign(e), s = this._accuIndex ^= 1; for (let a = 0; a !== n; ++a)t[a]._update(i, e, r, s); const a = this._bindings, o = this._nActiveBindings; for (let e = 0; e !== o; ++e)a[e].apply(s); return this } setTime(e) { this.time = 0; for (let e = 0; e < this._actions.length; e++)this._actions[e].time = 0; return this.update(e) } getRoot() { return this._root } uncacheClip(e) { const t = this._actions, n = e.uuid, i = this._actionsByClip, r = i[n]; if (void 0 !== r) { const e = r.knownActions; for (let n = 0, i = e.length; n !== i; ++n) { const i = e[n]; this._deactivateAction(i); const r = i._cacheIndex, s = t[t.length - 1]; i._cacheIndex = null, i._byClipCacheIndex = null, s._cacheIndex = r, t[r] = s, t.pop(), this._removeInactiveBindingsForAction(i) } delete i[n] } } uncacheRoot(e) { const t = e.uuid, n = this._actionsByClip; for (const e in n) { const i = n[e].actionByRoot[t]; void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i)) } const i = this._bindingsByRootAndName[t]; if (void 0 !== i) for (const e in i) { const t = i[e]; t.restoreOriginalState(), this._removeInactiveBinding(t) } } uncacheAction(e, t) { const n = this.existingAction(e, t); null !== n && (this._deactivateAction(n), this._removeInactiveAction(n)) } }).prototype._controlInterpolantsResultBuffer = new Float32Array(1); class Bg { constructor(e) { "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e } clone() { return new Bg(void 0 === this.value.clone ? this.value : this.value.clone()) } } (class extends Cp { constructor(e, t, n = 1) { super(e, t), this.meshPerAttribute = n } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } clone(e) { const t = super.clone(e); return t.meshPerAttribute = this.meshPerAttribute, t } toJSON(e) { const t = super.toJSON(e); return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t } }).prototype.isInstancedInterleavedBuffer = !0; class Hg { constructor(e, t, n = 0, i = 1 / 0) { this.ray = new lc(e, t), this.near = n, this.far = i, this.camera = null, this.layers = new _c, this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} } } set(e, t) { this.ray.set(e, t) } setFromCamera(e, t) { t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type) } intersectObject(e, t = !0, n = []) { return Vg(e, this, n, t), n.sort(Ug), n } intersectObjects(e, t = !0, n = []) { for (let i = 0, r = e.length; i < r; i++)Vg(e[i], this, n, t); return n.sort(Ug), n } } function Ug(e, t) { return e.distance - t.distance } function Vg(e, t, n, i) { if (e.layers.test(t.layers) && e.raycast(t, n), !0 === i) { const i = e.children; for (let e = 0, r = i.length; e < r; e++)Vg(i[e], t, n, !0) } } const Gg = new ul; class jg { constructor(e = new ul(1 / 0, 1 / 0), t = new ul(-1 / 0, -1 / 0)) { this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromPoints(e) { this.makeEmpty(); for (let t = 0, n = e.length; t < n; t++)this.expandByPoint(e[t]); return this } setFromCenterAndSize(e, t) { const n = Gg.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(n), this.max.copy(e).add(n), this } clone() { return (new this.constructor).copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y } getCenter(e) { return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } containsPoint(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y) } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y } getParameter(e, t) { return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y)) } intersectsBox(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y) } clampPoint(e, t) { return t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return Gg.copy(e).clamp(this.min, this.max).sub(e).length() } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } jg.prototype.isBox2 = !0; const Wg = new Rl, qg = new cc, $g = new cc; function Xg(e) { const t = []; !0 === e.isBone && t.push(e); for (let n = 0; n < e.children.length; n++)t.push.apply(t, Xg(e.children[n])); return t } const Yg = new Float32Array(1); new Int32Array(Yg.buffer), Cf.create = function (e, t) { return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(Cf.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e }, $f.prototype.fromPoints = function (e) { return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e) }, class extends vf { constructor(e = 10, t = 10, n = 4473924, i = 8947848) { n = new _l(n), i = new _l(i); const r = t / 2, s = e / t, a = e / 2, o = [], l = []; for (let e = 0, c = 0, u = -a; e <= t; e++, u += s) { o.push(-a, 0, u, a, 0, u), o.push(u, 0, -a, u, 0, a); const t = e === r ? n : i; t.toArray(l, c), c += 3, t.toArray(l, c), c += 3, t.toArray(l, c), c += 3, t.toArray(l, c), c += 3 } const c = new lu; c.setAttribute("position", new eu(o, 3)), c.setAttribute("color", new eu(l, 3)), super(c, new lf({ vertexColors: !0, toneMapped: !1 })), this.type = "GridHelper" } }.prototype.setColors = function () { console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.") }, class extends vf { constructor(e) { const t = Xg(e), n = new lu, i = [], r = [], s = new _l(0, 0, 1), a = new _l(0, 1, 0); for (let e = 0; e < t.length; e++) { const n = t[e]; n.parent && n.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(s.r, s.g, s.b), r.push(a.r, a.g, a.b)) } n.setAttribute("position", new eu(i, 3)), n.setAttribute("color", new eu(r, 3)), super(n, new lf({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1 } updateMatrixWorld(e) { const t = this.bones, n = this.geometry, i = n.getAttribute("position"); $g.copy(this.root.matrixWorld).invert(); for (let e = 0, n = 0; e < t.length; e++) { const r = t[e]; r.parent && r.parent.isBone && (qg.multiplyMatrices($g, r.matrixWorld), Wg.setFromMatrixPosition(qg), i.setXYZ(n, Wg.x, Wg.y, Wg.z), qg.multiplyMatrices($g, r.parent.matrixWorld), Wg.setFromMatrixPosition(qg), i.setXYZ(n + 1, Wg.x, Wg.y, Wg.z), n += 2) } n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e) } }.prototype.update = function () { console.error("THREE.SkeletonHelper: update() no longer needs to be called.") }, Qm.prototype.extractUrlBase = function (e) { return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), wg.extractUrlBase(e) }, Qm.Handlers = { add: function () { console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.") }, get: function () { console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.") } }, jg.prototype.center = function (e) { return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e) }, jg.prototype.empty = function () { return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, jg.prototype.isIntersectionBox = function (e) { return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, jg.prototype.size = function (e) { return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e) }, Fl.prototype.center = function (e) { return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e) }, Fl.prototype.empty = function () { return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, Fl.prototype.isIntersectionBox = function (e) { return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, Fl.prototype.isIntersectionSphere = function (e) { return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e) }, Fl.prototype.size = function (e) { return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e) }, xc.prototype.toVector3 = function () { console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead") }, ec.prototype.empty = function () { return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, Wu.prototype.setFromMatrix = function (e) { return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(e) }, hl.prototype.flattenToArrayOffset = function (e, t) { return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t) }, hl.prototype.multiplyVector3 = function (e) { return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this) }, hl.prototype.multiplyVector3Array = function () { console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.") }, hl.prototype.applyToBufferAttribute = function (e) { return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), e.applyMatrix3(this) }, hl.prototype.applyToVector3Array = function () { console.error("THREE.Matrix3: .applyToVector3Array() has been removed.") }, hl.prototype.getInverse = function (e) { return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(e).invert() }, cc.prototype.extractPosition = function (e) { return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e) }, cc.prototype.flattenToArrayOffset = function (e, t) { return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t) }, cc.prototype.getPosition = function () { return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new Rl).setFromMatrixColumn(this, 3) }, cc.prototype.setRotationFromQuaternion = function (e) { return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e) }, cc.prototype.multiplyToArray = function () { console.warn("THREE.Matrix4: .multiplyToArray() has been removed.") }, cc.prototype.multiplyVector3 = function (e) { return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, cc.prototype.multiplyVector4 = function (e) { return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, cc.prototype.multiplyVector3Array = function () { console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.") }, cc.prototype.rotateAxis = function (e) { console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this) }, cc.prototype.crossVector = function (e) { return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, cc.prototype.translate = function () { console.error("THREE.Matrix4: .translate() has been removed.") }, cc.prototype.rotateX = function () { console.error("THREE.Matrix4: .rotateX() has been removed.") }, cc.prototype.rotateY = function () { console.error("THREE.Matrix4: .rotateY() has been removed.") }, cc.prototype.rotateZ = function () { console.error("THREE.Matrix4: .rotateZ() has been removed.") }, cc.prototype.rotateByAxis = function () { console.error("THREE.Matrix4: .rotateByAxis() has been removed.") }, cc.prototype.applyToBufferAttribute = function (e) { return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, cc.prototype.applyToVector3Array = function () { console.error("THREE.Matrix4: .applyToVector3Array() has been removed.") }, cc.prototype.makeFrustum = function (e, t, n, i, r, s) { return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, i, n, r, s) }, cc.prototype.getInverse = function (e) { return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(e).invert() }, Vu.prototype.isIntersectionLine = function (e) { return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e) }, Pl.prototype.multiplyVector3 = function (e) { return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this) }, Pl.prototype.inverse = function () { return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert() }, lc.prototype.isIntersectionBox = function (e) { return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, lc.prototype.isIntersectionPlane = function (e) { return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e) }, lc.prototype.isIntersectionSphere = function (e) { return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e) }, Wc.prototype.area = function () { return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea() }, Wc.prototype.barycoordFromPoint = function (e, t) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t) }, Wc.prototype.midpoint = function (e) { return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e) }, Wc.prototypenormal = function (e) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e) }, Wc.prototype.plane = function (e) { return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e) }, Wc.barycoordFromPoint = function (e, t, n, i, r) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Wc.getBarycoord(e, t, n, i, r) }, Wc.normal = function (e, t, n, i) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Wc.getNormal(e, t, n, i) }, Xf.prototype.extractAllPoints = function (e) { return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e) }, Xf.prototype.extrude = function (e) { return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new bm(this, e) }, Xf.prototype.makeGeometry = function (e) { return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Em(this, e) }, ul.prototype.fromAttribute = function (e, t, n) { return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n) }, ul.prototype.distanceToManhattan = function (e) { return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e) }, ul.prototype.lengthManhattan = function () { return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, Rl.prototype.setEulerFromRotationMatrix = function () { console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.") }, Rl.prototype.setEulerFromQuaternion = function () { console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.") }, Rl.prototype.getPositionFromMatrix = function (e) { return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e) }, Rl.prototype.getScaleFromMatrix = function (e) { return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e) }, Rl.prototype.getColumnFromMatrix = function (e, t) { return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e) }, Rl.prototype.applyProjection = function (e) { return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e) }, Rl.prototype.fromAttribute = function (e, t, n) { return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n) }, Rl.prototype.distanceToManhattan = function (e) { return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e) }, Rl.prototype.lengthManhattan = function () { return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, Cl.prototype.fromAttribute = function (e, t, n) { return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n) }, Cl.prototype.lengthManhattan = function () { return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, Ic.prototype.getChildByName = function (e) { return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e) }, Ic.prototype.renderDepth = function () { console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.") }, Ic.prototype.translate = function (e, t) { return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e) }, Ic.prototype.getWorldRotation = function () { console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.") }, Ic.prototype.applyMatrix = function (e) { return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e) }, Object.defineProperties(Ic.prototype, { eulerOrder: { get: function () { return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order }, set: function (e) { console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e } }, useQuaternion: { get: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") }, set: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") } } }), Tu.prototype.setDrawMode = function () { console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") }, Object.defineProperties(Tu.prototype, { drawMode: { get: function () { return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0 }, set: function () { console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") } } }), Zp.prototype.initBones = function () { console.error("THREE.SkinnedMesh: initBones() has been removed.") }, Iu.prototype.setLens = function (e, t) { console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e) }, Object.defineProperties(sg.prototype, { onlyShadow: { set: function () { console.warn("THREE.Light: .onlyShadow has been removed.") } }, shadowCameraFov: { set: function (e) { console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e } }, shadowCameraLeft: { set: function (e) { console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e } }, shadowCameraRight: { set: function (e) { console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e } }, shadowCameraTop: { set: function (e) { console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e } }, shadowCameraBottom: { set: function (e) { console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e } }, shadowCameraNear: { set: function (e) { console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e } }, shadowCameraFar: { set: function (e) { console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e } }, shadowCameraVisible: { set: function () { console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.") } }, shadowBias: { set: function (e) { console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e } }, shadowDarkness: { set: function () { console.warn("THREE.Light: .shadowDarkness has been removed.") } }, shadowMapWidth: { set: function (e) { console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e } }, shadowMapHeight: { set: function (e) { console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e } } }), Object.defineProperties(Kc.prototype, { length: { get: function () { return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length } }, dynamic: { get: function () { return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === Xo }, set: function () { console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(Xo) } } }), Kc.prototype.setDynamic = function (e) { return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? Xo : $o), this }, Kc.prototype.copyIndicesArray = function () { console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.") }, Kc.prototype.setArray = function () { console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") }, lu.prototype.addIndex = function (e) { console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e) }, lu.prototype.addAttribute = function (e, t) { return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : this.setAttribute(e, t) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(e, new Kc(arguments[1], arguments[2]))) }, lu.prototype.addDrawCall = function (e, t, n) { void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t) }, lu.prototype.clearDrawCalls = function () { console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups() }, lu.prototype.computeOffsets = function () { console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.") }, lu.prototype.removeAttribute = function (e) { return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(e) }, lu.prototype.applyMatrix = function (e) { return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e) }, Object.defineProperties(lu.prototype, { drawcalls: { get: function () { return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups } }, offsets: { get: function () { return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups } } }), Cp.prototype.setDynamic = function (e) { return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? Xo : $o), this }, Cp.prototype.setArray = function () { console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") }, bm.prototype.getArrays = function () { console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.") }, bm.prototype.addShapeList = function () { console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.") }, bm.prototype.addShape = function () { console.error("THREE.ExtrudeGeometry: .addShape() has been removed.") }, Tp.prototype.dispose = function () { console.error("THREE.Scene: .dispose() has been removed.") }, Bg.prototype.onUpdate = function () { return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this }, Object.defineProperties($c.prototype, { wrapAround: { get: function () { console.warn("THREE.Material: .wrapAround has been removed.") }, set: function () { console.warn("THREE.Material: .wrapAround has been removed.") } }, overdraw: { get: function () { console.warn("THREE.Material: .overdraw has been removed.") }, set: function () { console.warn("THREE.Material: .overdraw has been removed.") } }, wrapRGB: { get: function () { return console.warn("THREE.Material: .wrapRGB has been removed."), new _l } }, shading: { get: function () { console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.") }, set: function (e) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === e } }, stencilMask: { get: function () { return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask }, set: function (e) { console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = e } }, vertexTangents: { get: function () { console.warn("THREE." + this.type + ": .vertexTangents has been removed.") }, set: function () { console.warn("THREE." + this.type + ": .vertexTangents has been removed.") } } }), Object.defineProperties(Ru.prototype, { derivatives: { get: function () { return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives }, set: function (e) { console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e } } }), Sp.prototype.clearTarget = function (e, t, n, i) { console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, n, i) }, Sp.prototype.animate = function (e) { console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e) }, Sp.prototype.getCurrentRenderTarget = function () { return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget() }, Sp.prototype.getMaxAnisotropy = function () { return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy() }, Sp.prototype.getPrecision = function () { return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision }, Sp.prototype.resetGLState = function () { return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset() }, Sp.prototype.supportsFloatTextures = function () { return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float") }, Sp.prototype.supportsHalfFloatTextures = function () { return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float") }, Sp.prototype.supportsStandardDerivatives = function () { return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives") }, Sp.prototype.supportsCompressedTextureS3TC = function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc") }, Sp.prototype.supportsCompressedTexturePVRTC = function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc") }, Sp.prototype.supportsBlendMinMax = function () { return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax") }, Sp.prototype.supportsVertexTextures = function () { return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures }, Sp.prototype.supportsInstancedArrays = function () { return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays") }, Sp.prototype.enableScissorTest = function (e) { console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e) }, Sp.prototype.initMaterial = function () { console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.") }, Sp.prototype.addPrePlugin = function () { console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.") }, Sp.prototype.addPostPlugin = function () { console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.") }, Sp.prototype.updateShadowMap = function () { console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.") }, Sp.prototype.setFaceCulling = function () { console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.") }, Sp.prototype.allocTextureUnit = function () { console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.") }, Sp.prototype.setTexture = function () { console.warn("THREE.WebGLRenderer: .setTexture() has been removed.") }, Sp.prototype.setTexture2D = function () { console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.") }, Sp.prototype.setTextureCube = function () { console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.") }, Sp.prototype.getActiveMipMapLevel = function () { return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel() }, Object.defineProperties(Sp.prototype, { shadowMapEnabled: { get: function () { return this.shadowMap.enabled }, set: function (e) { console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e } }, shadowMapType: { get: function () { return this.shadowMap.type }, set: function (e) { console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e } }, shadowMapCullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") } }, context: { get: function () { return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext() } }, vr: { get: function () { return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr } }, gammaInput: { get: function () { return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1 }, set: function () { console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.") } }, gammaOutput: { get: function () { return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1 }, set: function (e) { console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === e ? Wo : jo } }, toneMappingWhitePoint: { get: function () { return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1 }, set: function () { console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.") } }, gammaFactor: { get: function () { return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2 }, set: function () { console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.") } } }), Object.defineProperties(dp.prototype, { cullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") } }, renderReverseSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") } }, renderSingleSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") } } }), Object.defineProperties(Dl.prototype, { wrapS: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e } }, wrapT: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e } }, magFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e } }, minFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e } }, anisotropy: { get: function () { return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e } }, offset: { get: function () { return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e } }, repeat: { get: function () { return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e } }, format: { get: function () { return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e } }, type: { get: function () { return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e } }, generateMipmaps: { get: function () { return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e } } }), class extends Ic { constructor(e) { super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [] } getOutput() { return this.gain } setNodeSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this } setMediaElementSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this } setMediaStreamSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this } setBuffer(e) { return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this } play(e = 0) { if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing."); if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control."); this._startedAt = this.context.currentTime + e; const t = this.context.createBufferSource(); return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect() } pause() { if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this; console.warn("THREE.Audio: this Audio has no playback control.") } stop() { if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this; console.warn("THREE.Audio: this Audio has no playback control.") } connect() { if (this.filters.length > 0) { this.source.connect(this.filters[0]); for (let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].connect(this.filters[e]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this._connected = !0, this } disconnect() { if (this.filters.length > 0) { this.source.disconnect(this.filters[0]); for (let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].disconnect(this.filters[e]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this._connected = !1, this } getFilters() { return this.filters } setFilters(e) { return e || (e = []), !0 === this._connected ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this } setDetune(e) { if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this } getDetune() { return this.detune } getFilter() { return this.getFilters()[0] } setFilter(e) { return this.setFilters(e ? [e] : []) } setPlaybackRate(e) { if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this; console.warn("THREE.Audio: this Audio has no playback control.") } getPlaybackRate() { return this.playbackRate } onEnded() { this.isPlaying = !1 } getLoop() { return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop } setLoop(e) { if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this; console.warn("THREE.Audio: this Audio has no playback control.") } setLoopStart(e) { return this.loopStart = e, this } setLoopEnd(e) { return this.loopEnd = e, this } getVolume() { return this.gain.gain.value } setVolume(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } }.prototype.load = function (e) { console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."); const t = this; return (new Eg).load(e, (function (e) { t.setBuffer(e) })), this }, zu.prototype.updateCubeMap = function (e, t) { return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t) }, zu.prototype.clear = function (e, t, n, i) { return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(e, t, n, i) }, bl.crossOrigin = void 0, bl.loadTexture = function (e, t, n, i) { console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."); const r = new rg; r.setCrossOrigin(this.crossOrigin); const s = r.load(e, n, void 0, i); return t && (s.mapping = t), s }, bl.loadTextureCube = function (e, t, n, i) { console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."); const r = new ig; r.setCrossOrigin(this.crossOrigin); const s = r.load(e, n, void 0, i); return t && (s.mapping = t), s }, bl.loadCompressedTexture = function () { console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.") }, bl.loadCompressedTextureCube = function () { console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.") }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: "138" } })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "138"); const Zg = { uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } }, vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}", fragmentShader: "\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\t\t}" }; class Kg { constructor() { this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1 } setSize() { } render() { console.error("THREE.Pass: .render() must be implemented in derived pass.") } } const Jg = new rh(-1, 1, 1, -1, 0, 1), Qg = new lu; Qg.setAttribute("position", new eu([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), Qg.setAttribute("uv", new eu([0, 2, 0, 0, 2, 0], 2)); class ev { constructor(e) { this._mesh = new Tu(Qg, e) } dispose() { this._mesh.geometry.dispose() } render(e) { e.render(this._mesh, Jg) } get material() { return this._mesh.material } set material(e) { this._mesh.material = e } } class tv extends Kg { constructor(e, t) { super(), this.textureID = void 0 !== t ? t : "tDiffuse", e instanceof Ru ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = Pu.clone(e.uniforms), this.material = new Ru({ defines: Object.assign({}, e.defines), uniforms: this.uniforms, vertexShader: e.vertexShader, fragmentShader: e.fragmentShader })), this.fsQuad = new ev(this.material) } render(e, t, n) { this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e)) } } class nv extends Kg { constructor(e, t) { super(), this.scene = e, this.camera = t, this.clear = !0, this.needsSwap = !1, this.inverse = !1 } render(e, t, n) { const i = e.getContext(), r = e.state; let s, a; r.buffers.color.setMask(!1), r.buffers.depth.setMask(!1), r.buffers.color.setLocked(!0), r.buffers.depth.setLocked(!0), this.inverse ? (s = 0, a = 1) : (s = 1, a = 0), r.buffers.stencil.setTest(!0), r.buffers.stencil.setOp(i.REPLACE, i.REPLACE, i.REPLACE), r.buffers.stencil.setFunc(i.ALWAYS, s, 4294967295), r.buffers.stencil.setClear(a), r.buffers.stencil.setLocked(!0), e.setRenderTarget(n), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(t), this.clear && e.clear(), e.render(this.scene, this.camera), r.buffers.color.setLocked(!1), r.buffers.depth.setLocked(!1), r.buffers.stencil.setLocked(!1), r.buffers.stencil.setFunc(i.EQUAL, 1, 4294967295), r.buffers.stencil.setOp(i.KEEP, i.KEEP, i.KEEP), r.buffers.stencil.setLocked(!0) } } class iv extends Kg { constructor() { super(), this.needsSwap = !1 } render(e) { e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1) } } class rv { constructor(e, t) { if (this.renderer = e, void 0 === t) { const n = { minFilter: So, magFilter: So, format: Po }, i = e.getSize(new ul); this._pixelRatio = e.getPixelRatio(), this._width = i.width, this._height = i.height, (t = new Dl(this._width * this._pixelRatio, this._height * this._pixelRatio, n)).texture.name = "EffectComposer.rt1" } else this._pixelRatio = 1, this._width = t.width, this._height = t.height; this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], void 0 === Zg && console.error("THREE.EffectComposer relies on CopyShader"), void 0 === tv && console.error("THREE.EffectComposer relies on ShaderPass"), this.copyPass = new tv(Zg), this.clock = new Mg } swapBuffers() { const e = this.readBuffer; this.readBuffer = this.writeBuffer, this.writeBuffer = e } addPass(e) { this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio) } insertPass(e, t) { this.passes.splice(t, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio) } removePass(e) { const t = this.passes.indexOf(e); -1 !== t && this.passes.splice(t, 1) } isLastEnabledPass(e) { for (let t = e + 1; t < this.passes.length; t++)if (this.passes[t].enabled) return !1; return !0 } render(e) { void 0 === e && (e = this.clock.getDelta()); const t = this.renderer.getRenderTarget(); let n = !1; for (let t = 0, i = this.passes.length; t < i; t++) { const i = this.passes[t]; if (!1 !== i.enabled) { if (i.renderToScreen = this.renderToScreen && this.isLastEnabledPass(t), i.render(this.renderer, this.writeBuffer, this.readBuffer, e, n), i.needsSwap) { if (n) { const t = this.renderer.getContext(), n = this.renderer.state.buffers.stencil; n.setFunc(t.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), n.setFunc(t.EQUAL, 1, 4294967295) } this.swapBuffers() } void 0 !== nv && (i instanceof nv ? n = !0 : i instanceof iv && (n = !1)) } } this.renderer.setRenderTarget(t) } reset(e) { if (void 0 === e) { const t = this.renderer.getSize(new ul); this._pixelRatio = this.renderer.getPixelRatio(), this._width = t.width, this._height = t.height, (e = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio) } this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2 } setSize(e, t) { this._width = e, this._height = t; const n = this._width * this._pixelRatio, i = this._height * this._pixelRatio; this.renderTarget1.setSize(n, i), this.renderTarget2.setSize(n, i); for (let e = 0; e < this.passes.length; e++)this.passes[e].setSize(n, i) } setPixelRatio(e) { this._pixelRatio = e, this.setSize(this._width, this._height) } } new rh(-1, 1, 1, -1, 0, 1); const sv = new lu; sv.setAttribute("position", new eu([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), sv.setAttribute("uv", new eu([0, 2, 0, 0, 2, 0], 2)); class av extends Kg { constructor(e, t, n, i, r) { super(), this.scene = e, this.camera = t, this.overrideMaterial = n, this.clearColor = i, this.clearAlpha = void 0 !== r ? r : 0, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new _l } render(e, t, n) { const i = e.autoClear; let r, s; e.autoClear = !1, void 0 !== this.overrideMaterial && (s = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (e.getClearColor(this._oldClearColor), r = e.getClearAlpha(), e.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : n), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor && e.setClearColor(this._oldClearColor, r), void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = s), e.autoClear = i } } class ov { constructor(e, t) { this.renderer = e, this.composer = t, this.bgColor = this.renderer.getClearColor(new _l) } init(e, t) { const n = { vertexShader: "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main(){\n    vUv = uv;\n    gl_Position = vec4(position, 1.0);\n}", fragmentShader: "precision highp float;\n#define GLSLIFY 1\n// float random(vec2 co){\n//     highp float a = 12.9898;\n//     highp float b = 78.233;\n//     highp float c = 43758.5453;\n//     highp float dt= dot(co.xy ,vec2(a,b));\n//     highp float sn= mod(dt,3.14);\n//     return fract(sin(sn) * c);\n// }\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nvec3 noiseColorStatic = vec3(0.6196078431372549);\nuniform float time;\nuniform vec2 resolution;\nuniform sampler2D tDiffuse;\n//uniform vec3 noiseColor;\nuniform float noiseOpacity;\nvarying vec2 vUv;\n\nvoid main(){\n    vec4 renderColor = texture2D( tDiffuse, vUv );\n    float noise = random(fract(gl_FragCoord.xy / resolution * time));\n    gl_FragColor = vec4((renderColor.rgb + (vec3(noise) * noiseColorStatic * noiseOpacity)) - (renderColor.rgb * (vec3(noise) * noiseColorStatic * noiseOpacity)), 1.0);\n}", uniforms: { time: { value: 1 }, resolution: { value: new ul(e, t) }, noiseOpacity: { value: .07 }, tDiffuse: { value: null } } }; this.customPass = new tv(n), this.customPass.renderToScreen = !0, this.composer.addPass(this.customPass) } colorAnimationIn(e, t) { const n = { r: this.bgColor.r, g: this.bgColor.g, b: this.bgColor.b, opacity: 0 }; Ci.to(n, { r: .1843137254901961, g: .1843137254901961, b: .1843137254901961, opacity: .066, duration: e, ease: t, onUpdate: () => { this.bgColor = this.bgColor.setRGB(n.r, n.g, n.b), this.customPass.uniforms.noiseOpacity.value = n.opacity, this.renderer.setClearColor(this.bgColor) } }) } colorAnimationOut(e, t, n) { const i = { r: this.bgColor.r, g: this.bgColor.g, b: this.bgColor.b, opacity: .066 }; Ci.to(i, { r: 1, g: 1, b: 1, opacity: 0, duration: e, ease: t, onUpdate: () => { this.bgColor = this.bgColor.setRGB(i.r, i.g, i.b), this.customPass.uniforms.noiseOpacity.value = i.opacity, this.renderer.setClearColor(this.bgColor) }, onComplete: () => { this.customPass.renderToScreen = !1, this.composer.removePass(this.customPass), n() } }) } update(e) { this.customPass.uniforms.time.value = e / 1e3 } resize(e, t) { this.customPass.uniforms.resolution.value.set(e, t) } addGUI() { const e = new GUI; e.domElement.classList.add("guiStyle-noise"); const t = e.addFolder("Noise"); this.GUIObj = { bgColor: this.bgColor, noiseColor: "0x" + this.customPass.uniforms.noiseColor.value.getHexString(), noiseOpacity: this.customPass.uniforms.noiseOpacity.value }, t.addColor(this.GUIObj, "bgColor").onChange((e => { this.bgColor = e, this.renderer.setClearColor(e) })), t.addColor(this.GUIObj, "noiseColor").onChange((e => { this.customPass.uniforms.noiseColor.value.setStyle(e) })), t.add(this.GUIObj, "noiseOpacity", 0, 1).onChange((e => { this.customPass.uniforms.noiseOpacity.value = e })), t.open() } } const lv = "precision mediump float;\n#define GLSLIFY 1\n\nattribute vec3 position;\nattribute vec2 uv;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nvarying vec2 vUv;\n\nvoid main(){\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}"; class cv { constructor(e) { this.scene = e } init(e, t, n, i = !1) { this.rootHeight = t, this.textureMovie = n; const r = new Xu(e, t); this.videoTexture = new Tf(this.textureMovie), this.material = new Tm({ vertexShader: lv, fragmentShader: "precision mediump float;\n#define GLSLIFY 1\n// resolution.x resolution.y ratedRes.x ratedRes.y\nuniform vec4 movieParam_01;\n// baseOpacity absOpacity scrollPosition edgeRadius\nuniform vec4 movieParam_02;\nuniform sampler2D textureMovie;\nuniform vec2 introParam;\nvarying vec2 vUv;\n\nfloat drawRect(vec2 p, vec2 c, vec2 size, float edge){\n\tvec2 d=abs(p-c)-size;\n\tfloat l=length(max(d,0.))+min(max(d.x,d.y),0.);\n\treturn step(l-edge,0.);\n}\n\nvoid main(){\n    vec2 resizedHorizontal = vec2((movieParam_01.z >= movieParam_01.y) ? vUv.x : (vUv.x / (movieParam_01.w / movieParam_01.x)) + ((movieParam_01.w - movieParam_01.x) / movieParam_01.w / 2.0), (movieParam_01.z >= movieParam_01.y) ? (vUv.y / (movieParam_01.z / movieParam_01.y)) + ((movieParam_01.z - movieParam_01.y) / movieParam_01.z / 2.0) : vUv.y);\n    vec2 resizedVertical = vec2((movieParam_01.w >= movieParam_01.x) ? (vUv.x / (movieParam_01.w / movieParam_01.x)) + ((movieParam_01.w - movieParam_01.x) / movieParam_01.w / 2.0) : vUv.x, (movieParam_01.w >= movieParam_01.x) ? vUv.y : (vUv.y / (movieParam_01.z / movieParam_01.y)) + ((movieParam_01.z - movieParam_01.y) / movieParam_01.z / 2.0));\n    vec2 resizedUV;\n    resizedUV = mix(resizedHorizontal, resizedVertical, step(vec2(movieParam_01.y), vec2(movieParam_01.x)));\n\n    //resizedUV.y -= scrollPosition / movieParam_01.y;\n    vec3 noColor = vec3(0.0);\n    vec3 texColor = texture2D( textureMovie, resizedUV).rgb;\n    vec3 distColor = mix(texColor, noColor, step(resizedUV.y, 0.0));\n\n    vec2 nowPosition = (gl_FragCoord.xy*2.0 - movieParam_01.x)/movieParam_01.y;\n    float resValue = (movieParam_01.x/movieParam_01.y);\n    float valueX = ((resValue < 1.0)?0.25:0.125);\n    float sizeX = valueX + ((0.5 - valueX) * introParam.y);\n    float valueY = valueX * resValue * ((resValue < 0.5)?1.3332:1.3332);\n    float sizeY = valueY + ((0.5 - valueY) * introParam.y);\n    vec2 rectSize = vec2(sizeX, sizeY);\n    vec2 rectPos = vec2(0.5, -1.0 + (introParam.x * 1.5));\n    float rectValue = drawRect(vUv, rectPos, rectSize, 0.01 * (1.0 - introParam.y));\n\n    gl_FragColor = vec4(distColor, ((vUv.y * movieParam_02.x) - (movieParam_02.z / movieParam_01.y)) * movieParam_02.y * rectValue);\n}", transparent: !0, alphaTest: .5, uniforms: { movieParam_01: { value: new Cl(e, t, e * (n.videoHeight / n.videoWidth), t * (n.videoWidth / n.videoHeight)) }, movieParam_02: { value: new Cl(.86, 0, 0, .1) }, introParam: { value: new ul(0, 0) }, textureMovie: { value: this.videoTexture } } }), this.material.uniformsNeedUpdate = !0, this.plane = new Tu(r, this.material), this.scene.add(this.plane), i ? (this.material.uniforms.movieParam_02.value.y = 1, this.material.uniforms.introParam.value.set(1, 1), this.scrollChange(window.pageYOffset)) : (this.videoPlayFlg = !0, this.fadeFlg = !1), this.videoPlayFlg ? this.replay() : this.pause() } maskAnimation(e, t, n, i, r, s = null) { this.material.uniforms.movieParam_02.value.y = 1, Ci.to(this.material.uniforms.introParam.value, { x: 1, duration: e, ease: t }), Ci.to(this.material.uniforms.introParam.value, { y: 1, duration: n, ease: i, delay: r, onComplete: () => { s && s() } }) } fadeAnimation(e, t, n = null) { this.fadeFlg = !1, this.material.uniforms.introParam.value.x = 1, this.material.uniforms.introParam.value.y = 1, Ci.to(this.material.uniforms.movieParam_02.value, { y: 1, duration: e, ease: t, onComplete: () => { n && n() } }) } fadeOutDestroy(e, t, n = null) { Ci.to(this.material.uniforms.movieParam_02.value, { y: 0, duration: e, ease: t, onComplete: () => { this.destroy(), this.scene = void 0, n && n() } }) } destroy(e = !1) { this.gui && (this.gui.destroy(), this.gui = void 0), this.scene.remove(this.plane), this.material.dispose(), this.textureMovie.pause(), this.videoTexture.dispose(), this.plane = void 0, this.material = void 0, this.textureMovie = void 0, this.videoTexture = void 0, this.rootHeight = void 0, this.playPromise = void 0, e || (this.videoPlayFlg = void 0, this.fadeFlg = void 0) } fadeIn(e, t, n, i = null) { this.fadeFlg = !1, this.scrollChange(e), Ci.to(this.material.uniforms.movieParam_02.value, { y: 1, duration: t, ease: n, onComplete: () => { i && i() } }) } fadeOut(e, t, n = null) { this.fadeFlg = !0, Ci.to(this.material.uniforms.movieParam_02.value, { y: 0, duration: e, ease: t, onComplete: () => { this.pause(), n && n() } }) } scrollChange(e) { this.fadeFlg || (this.material.uniforms.movieParam_02.value.z = e, e >= this.rootHeight ? this.videoPlayFlg && this.pause() : this.videoPlayFlg || this.replay()) } pause() { this.videoPlayFlg = !1, void 0 !== this.playPromise && this.playPromise.then((() => { this.textureMovie.pause() })), this.plane.visible = !1 } replay() { this.videoPlayFlg = !0, this.playPromise = this.textureMovie.play(), this.plane.visible = !0 } resize(e, t) { let n = this.textureMovie; this.destroy(!0), this.init(e, t, n, !0), n = void 0 } addGUI() { this.gui = new GUI; const e = this.gui.addFolder("Movie"); this.GUIObj = { movieOpacity: this.material.uniforms.OpacityVec.value.x }, e.add(this.GUIObj, "movieOpacity", 0, 1).onChange((e => { this.material.uniforms.OpacityVec.value.x = e })), e.open() } } class uv { constructor(e, t, n) { this.renderer = e, this.scene = t, this.drawScene = new Tp, this.camera = n, this.pauseFlg = !1 } init(e, t, n = null, i = null) { if (this.rootWidth = e, this.rootHeight = t, this.bufferSizeRate = .5, window.LIG.isIOS) this.buffer_draw = new Dl(e * this.bufferSizeRate, t * this.bufferSizeRate, { depthBuffer: !1, stencilBuffer: !1, minFilter: So, magFilter: So, type: Lo }), this.buffer_01 = new Dl(e * this.bufferSizeRate, t * this.bufferSizeRate, { depthBuffer: !1, stencilBuffer: !1, minFilter: So, magFilter: So, type: Lo }), this.buffer_02 = new Dl(e * this.bufferSizeRate, t * this.bufferSizeRate, { depthBuffer: !1, stencilBuffer: !1, minFilter: So, magFilter: So, type: Lo }); else { const n = this.renderer.capabilities.drawBuffers; this.buffer_draw = new Dl(e * this.bufferSizeRate, t * this.bufferSizeRate, { depthBuffer: !1, stencilBuffer: !1, minFilter: So, magFilter: So, type: n ? Do : Mo }), this.buffer_01 = new Dl(e * this.bufferSizeRate, t * this.bufferSizeRate, { depthBuffer: !1, stencilBuffer: !1, minFilter: So, magFilter: So, type: n ? Do : Mo }), this.buffer_02 = new Dl(e * this.bufferSizeRate, t * this.bufferSizeRate, { depthBuffer: !1, stencilBuffer: !1, minFilter: So, magFilter: So, type: n ? Do : Mo }) } const r = new Xu(this.rootWidth, this.rootHeight); this.drawMaterial = new Tm({ vertexShader: lv, fragmentShader: "precision highp float;\n#define GLSLIFY 1\nfloat blendLighten(float base, float blend) {\n\treturn max(blend,base);\n}\n\nvec3 blendLighten(vec3 base, vec3 blend) {\n\treturn vec3(blendLighten(base.r,blend.r),blendLighten(base.g,blend.g),blendLighten(base.b,blend.b));\n}\n\nvec3 blendLighten(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLighten(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_0 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_0;\n  vec3 i1 = min( g_0.xyz, l.zxy );\n  vec3 i2 = max( g_0.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n// #pragma glslify: hsl2rgb = require(glsl-hsl2rgb)\n\nuniform float time;\n// rotation_speed all_alpha scene_bias Education_alpha\nuniform vec4 drawParam_01;\n// Strategy_alpha Technology_alpha Marketing_alpha Design_alpha\nuniform vec4 drawParam_02;\nuniform float aspect;\n\nvarying vec2 vUv;\n\nfloat PI = 3.141592653589793;\nfloat PI2 = PI * 2.0;\nfloat ratedTime = drawParam_01.x * time;\n\nvec3 bgColor = vec3(0.1843137254901961);\nvec3 rgbEducation = vec3(0.9450980392156862, 0.592156862745098, 0.3254901960784313);\nvec3 rgbStrategy = vec3(0.49019607843137236, 0.3921568627450982, 0.776470588235294);\nvec3 rgbTechnology = vec3(0.2666666666666666, 0.6901960784313724, 0.6901960784313725);\nvec3 rgbMarketing = vec3(0.3294117647058823, 0.6745098039215687, 0.42745098039215673);\nvec3 rgbDesign = vec3(0.819607843137255, 0.349019607843137, 0.48235294117646965);\n\nfloat startRad = radians(90.0);\nfloat rateRad = radians(360.0 / 5.0);\nfloat finishRadius = 0.4;\n\nfloat topOpacity = 1.0 - smoothstep(0.0, 0.25, drawParam_01.z);\nfloat circleOpacity = smoothstep(0.25, 0.5, drawParam_01.z);\nfloat circleRadiusBias = 1.0 - smoothstep(0.5, 1.0, drawParam_01.z);\nfloat circleNoiseBias = 1.0 - smoothstep(0.8, 1.0, drawParam_01.z);\nfloat circleFadeBias = 1.0 - smoothstep(0.9, 1.0, drawParam_01.z);\n\nfloat atan2(in float y, in float x){\n  return x == 0.0 ? sign(y)*PI/2.0 : atan(y, x);\n}\nfloat cross(vec2 a, vec2 b) {\n  return a.x * b.y - a.y * b.x;\n}\nfloat saturate(float f){\n   return clamp(f,0.,1.);\n}\n\nvec3 makeColorRGB(vec2 grPosition, vec2 grGoal, vec3 targetColor, float targetOpacity) {\n  float rad = atan2(grGoal.y, grGoal.x);\n  vec2 Vector = vec2(cos(rad), sin(rad));\n\n  float RemoveArea = fract((atan(grPosition.y,grPosition.x)/PI2 + 1.) - (atan(grGoal.y,grGoal.x)/PI2 + 1.));\n  //時計回り\n  // float point_01 = (1.0 - step(0.5, RemoveArea)) * (1.0 - step(RemoveArea, 0.0));\n  //反半時計回り\n  float point_02 = (1.0 - step(1.0, RemoveArea)) * (1.0 - step(RemoveArea, 0.5));\n  float CrossDistance = (0.0 < point_02) ? 0.0 : abs(cross(grPosition, Vector));\n\n  vec2 rotatedGrPosition = grPosition + (grGoal);\n  float t = max(dot(rotatedGrPosition, grGoal), 0.0) / mix(1.0, aspect, abs(grGoal.x)) / 2.0;\n  float clampedVal = clamp(t * (1.0 - CrossDistance), 0.0, 1.0);\n  return (targetColor * (clampedVal * targetOpacity)) + (bgColor * (1.0 - (clampedVal * targetOpacity)));\n}\n\nvec3 drawTopVisual(vec2 grPosition){\n  vec2 grGoal_Education = vec2(cos(startRad + ratedTime), sin(startRad + ratedTime));\n  vec3 EducationDist = makeColorRGB(grPosition, grGoal_Education, rgbEducation, drawParam_01.w);\n  vec2 grGoal_Strategy = vec2(cos(startRad + ratedTime + (rateRad * 1.0)), sin(startRad + ratedTime + (rateRad * 1.0)));\n  vec3 StrategyDist = makeColorRGB(grPosition, grGoal_Strategy, rgbStrategy, drawParam_02.x);\n  vec2 grGoal_Technology = vec2(cos(startRad + ratedTime + (rateRad * 2.0)), sin(startRad + ratedTime + (rateRad * 2.0)));\n  vec3 TechnologyDist = makeColorRGB(grPosition, grGoal_Technology, rgbTechnology, drawParam_02.y);\n  vec2 grGoal_Marketing = vec2(cos(startRad + ratedTime + (rateRad * 3.0)), sin(startRad + ratedTime + (rateRad * 3.0)));\n  vec3 MarketingDist = makeColorRGB(grPosition, grGoal_Marketing, rgbMarketing, drawParam_02.z);\n  vec2 grGoal_Design = vec2(cos(startRad + ratedTime + (rateRad * 4.0)), sin(startRad + ratedTime + (rateRad * 4.0)));\n  vec3 DesignDist = makeColorRGB(grPosition, grGoal_Design, rgbDesign, drawParam_02.w);\n\n  return blendLighten(blendLighten(blendLighten(blendLighten(EducationDist, StrategyDist), TechnologyDist), MarketingDist), DesignDist);\n}\n\nvec3 makeCircleColor(float radius, vec2 uv, vec2 center, vec3 targetColor){\n  float lightness = clamp((radius - length(uv - center)) * (1.0 / radius), 0.0, 1.0);\n  float drawOpacity = lightness * lightness;\n  return (targetColor * drawOpacity) + (bgColor * (1.0 - drawOpacity));\n}\n\nvec3 drawCicleRadius(vec2 center, vec2 uv){\n  float noiseVal_01 = snoise(vec3(uv.x * aspect * 0.14, uv.y * 0.22, time * 0.1)) * 0.4 * circleNoiseBias;\n  float noiseVal_02 = snoise(vec3(uv.x * aspect * 0.23, uv.y * 0.15, time * 0.3)) * 0.5 * circleNoiseBias;\n  float noiseVal_03 = snoise(vec3(uv.x * aspect * 0.13, uv.y * 0.2, time * 0.2)) * 0.35 * circleNoiseBias;\n  float noiseVal_04 = snoise(vec3(uv.x * aspect * 0.15, uv.y * 0.16, time * 0.25)) * 0.55 * circleNoiseBias;\n  float noiseVal_05 = snoise(vec3(uv.x * aspect * 0.22, uv.y * 0.3, time * 0.16)) * 0.45 * circleNoiseBias;\n  float noisedTime_01 = time + ((snoise(vec3(uv.x * aspect * 0.13, uv.y * 0.13, time * 0.05)) * 2.0)) * circleNoiseBias;\n  float noisedTime_02 = time + ((snoise(vec3(uv.x * aspect * 0.1, uv.y * 0.08, time * 0.03)) * 3.0)) * circleNoiseBias;\n  float noisedTime_03 = time + ((snoise(vec3(uv.x * aspect * 0.2, uv.y * 0.1, time * 0.04)) * 1.5)) * circleNoiseBias;\n  float noisedTime_04 = time + ((snoise(vec3(uv.x * aspect * 0.15, uv.y * 0.21, time * 0.02)) * 2.5)) * circleNoiseBias;\n  float noisedTime_05 = time + ((snoise(vec3(uv.x * aspect * 0.16, uv.y * 0.18, time * 0.035)) * 3.2)) * circleNoiseBias;\n\n  vec2 center_Technology = vec2(cos(startRad + noisedTime_01), sin(startRad + noisedTime_01)) * (finishRadius + (0.5 * circleRadiusBias) + noiseVal_01);\n  vec2 center_Strategy = vec2(cos(startRad + noisedTime_02 + (rateRad * 1.0)), sin(startRad + noisedTime_02 + (rateRad * 1.0))) * (finishRadius + (0.5 * circleRadiusBias) + noiseVal_02);\n  vec2 center_Marketing = vec2(cos(startRad + noisedTime_03 + (rateRad * 2.0)), sin(startRad + noisedTime_03 + (rateRad * 2.0))) * (finishRadius + (0.5 * circleRadiusBias) + noiseVal_03);\n  vec2 center_Education = vec2(cos(startRad + noisedTime_04 + (rateRad * 3.0)), sin(startRad + noisedTime_04 + (rateRad * 3.0))) * (finishRadius + (0.5 * circleRadiusBias) + noiseVal_04);\n  vec2 center_Design = vec2(cos(startRad + noisedTime_05 + (rateRad * 4.0)), sin(startRad + noisedTime_05 + (rateRad * 4.0))) * (finishRadius + (0.5 * circleRadiusBias) + noiseVal_05);\n\n  vec3 c_educationColor = makeCircleColor(0.5 + (0.5 * circleRadiusBias), center, center_Education, rgbEducation);\n  vec3 c_strategyColor = makeCircleColor(0.5 + (0.5 * circleRadiusBias), center, center_Strategy, rgbStrategy);\n  vec3 c_technologyColor = makeCircleColor(0.5 + (0.5 * circleRadiusBias), center, center_Technology, rgbTechnology);\n  vec3 c_marketingColor = makeCircleColor(0.5 + (0.5 * circleRadiusBias), center, center_Marketing, rgbMarketing);\n  vec3 c_designColor = makeCircleColor(0.5 + (0.5 * circleRadiusBias), center, center_Design, rgbDesign);\n  return blendLighten(blendLighten(blendLighten(blendLighten(c_educationColor, c_strategyColor), c_technologyColor), c_marketingColor), c_designColor);\n}\n\nvoid main(){\n  vec2 uv = vec2(vUv.x * aspect, vUv.y);\n  vec2 grPosition = (uv - vec2(aspect * 0.5, 0.5)) * vec2(2.0);\n\n  gl_FragColor = (drawParam_01.z >= 1.0) ? vec4(bgColor, 1.0) : (drawParam_01.z > 0.25) ? vec4(drawCicleRadius(grPosition, uv), circleOpacity * circleFadeBias) : vec4(drawTopVisual(grPosition), topOpacity);\n}", transparent: !0, alphaTest: .5, uniforms: { time: { value: 0 }, drawParam_01: { value: new Cl(1.4, 1, 0, 0) }, drawParam_02: { value: new Cl(0, 0, 0, 0) }, aspect: { value: this.clamp(this.rootWidth / this.rootHeight, .5, 2) } } }), this.drawMaterial.uniformsNeedUpdate = !0, this.blurMaterial = new Tm({ vertexShader: lv, fragmentShader: "precision highp float;\n#define GLSLIFY 1\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_0 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_0;\n  vec3 i1 = min( g_0.xyz, l.zxy );\n  vec3 i2 = max( g_0.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n// opacity scene_bias\nuniform vec2 distParam;\nuniform sampler2D drawBuffer;\nuniform sampler2D beforeBuffer;\nvarying vec2 vUv;\n\nvec4 noiseParam = vec4(0.9, 1.3, 0.3, 0.15);\nfloat noiseValue = 1.0 - smoothstep(0.25, 0.5, distParam.y);\n\nvoid main(){\n    float noiseVal = snoise(vec3(vUv.x * noiseParam.r, vUv.y * noiseParam.g, noiseParam.b));\n\n    vec4 drawColor = texture2D( drawBuffer, vUv + (noiseVal * noiseParam.a * noiseValue));\n    vec4 beforeColor = texture2D( beforeBuffer, vUv);\n    gl_FragColor =  vec4(mix( drawColor, beforeColor, 0.965).rgb, distParam.x);\n}", transparent: !0, alphaTest: .5, uniforms: { distParam: { value: new ul(1, 1) }, drawBuffer: { type: "t", value: this.buffer_draw.texture }, beforeBuffer: { type: "t", value: null } } }), this.blurMaterial.uniformsNeedUpdate = !0, this.drawPlane = new Tu(r, this.drawMaterial), this.distPlane = new Tu(r, this.blurMaterial), this.drawScene.add(this.drawPlane), this.scene.add(this.distPlane), null !== n && (this.drawMaterial.uniforms.drawParam_01.value.z = n, this.drawMaterial.uniforms.drawParam_01.value.w = 1, this.drawMaterial.uniforms.drawParam_02.value.set(1, 1, 1, 1), this.blurMaterial.uniforms.distParam.value.x = i) } destroy(e = !1) { this.gui && (this.gui.destroy(), this.gui = void 0), this.drawScene.remove(this.drawPlane), this.scene.remove(this.distPlane), this.drawMaterial.dispose(), this.blurMaterial.dispose(), this.buffer_draw.dispose(), this.buffer_01.dispose(), this.buffer_02.dispose(), this.drawPlane = void 0, this.distPlane = void 0, this.drawMaterial = void 0, this.blurMaterial = void 0, this.rootWidth = void 0, this.rootHeight = void 0, this.opacityObj = void 0, this.buffer_draw = void 0, this.buffer_01 = void 0, this.buffer_02 = void 0, e || (this.pauseFlg = void 0) } removeAll() { this.destroy(), this.renderer = void 0, this.scene = void 0, this.drawScene = void 0, this.camera = void 0 } update(e) { this.pauseFlg || (this.drawMaterial.uniforms.time.value = e / 1e3, this.renderer.setRenderTarget(this.buffer_draw), this.renderer.render(this.drawScene, this.camera), this.buffSwitch ? (this.renderer.setRenderTarget(this.buffer_02), this.renderer.render(this.scene, this.camera), this.blurMaterial.uniforms.beforeBuffer.value = this.buffer_02.texture) : (this.renderer.setRenderTarget(this.buffer_01), this.renderer.render(this.scene, this.camera), this.blurMaterial.uniforms.beforeBuffer.value = this.buffer_01.texture), this.buffSwitch = !this.buffSwitch, this.renderer.setRenderTarget(null)) } resize(e, t) { const n = this.drawMaterial.uniforms.drawParam_01.value.z, i = this.blurMaterial.uniforms.distParam.value.x; this.destroy(!0), this.init(e, t, n, i) } transitionIn(e, t, n = null) { Ci.to(this.drawMaterial.uniforms.drawParam_01.value, { w: 1, duration: e, ease: "power1.out" }), Ci.to(this.drawMaterial.uniforms.drawParam_02.value, { y: 1, duration: e, delay: t, ease: "power1.out" }), Ci.to(this.drawMaterial.uniforms.drawParam_02.value, { w: 1, duration: e, delay: 2 * t, ease: "power1.out" }), Ci.to(this.drawMaterial.uniforms.drawParam_02.value, { z: 1, duration: e, delay: 3 * t, ease: "power1.out" }), Ci.to(this.drawMaterial.uniforms.drawParam_02.value, { x: 1, duration: e, delay: 4 * t, ease: "power1.out" }), Ci.to(this.drawMaterial.uniforms.drawParam_01.value, { x: 1, duration: e + 4 * t, ease: "power1.out", onComplete: () => { n && n() } }) } fadeIn(e, t, n, i = null) { this.pauseFlg = !1, this.distPlane.visible = !0, this.drawPlane.visible = !0, this.drawMaterial.uniforms.time.value = n / 1e3, Ci.to(this.blurMaterial.uniforms.distParam.value, { x: 1, duration: e, ease: t, onComplete: () => { i && i() } }) } fadeOut(e, t, n = null) { Ci.to(this.blurMaterial.uniforms.distParam.value, { x: 0, duration: e, ease: t, onComplete: () => { this.pauseFlg = !0, this.distPlane.visible = !1, this.drawPlane.visible = !1, n && n() } }) } fadeOutDestroy(e, t, n = null) { Ci.to(this.blurMaterial.uniforms.distParam.value, { x: 0, duration: e, ease: t, onComplete: () => { this.destroy(), n && n() } }) } scrollValue(e) { this.drawMaterial.uniforms.drawParam_01.value.z = e } clamp(e, t, n) { return Math.min(Math.max(e, t), n) } } class hv { constructor(e, t, n) { this.mouseOverAnimation = e => { let t; this.opacityObj.opacity = this.drawMaterial.uniforms.drawParam_01.value.x, Ci.to(this.opacityObj, { opacity: 1, duration: 1.2, ease: "power3.out", overwrite: !0, onUpdate: () => { this.drawMaterial.uniforms.drawParam_01.value.x = this.opacityObj.opacity } }), e.target.classList.contains("js_hover_overview") ? (t = this.hslBg, this.drawMaterial.uniforms.drawParam_02.value.z = 1, this.radiusObj.radius = this.drawMaterial.uniforms.drawParam_02.value.y, Ci.to(this.radiusObj, { radius: .7, duration: 1.2, ease: "expo.out", overwrite: !0, onUpdate: () => { this.drawMaterial.uniforms.drawParam_02.value.y = this.radiusObj.radius } })) : e.target.classList.contains("js_hover_strategy") ? t = this.hslStrategy : e.target.classList.contains("js_hover_technology") ? t = this.hslTechnology : e.target.classList.contains("js_hover_design") ? t = this.hslDesign : e.target.classList.contains("js_hover_marketing") ? t = this.hslMarketing : e.target.classList.contains("js_hover_education") && (t = this.hslEducation), this.ColorAnimation = Ci.to(this.nowColor, { x: t.x, y: t.y, z: t.z, duration: .4, ease: "linear", overwrite: !0, onUpdate: () => { this.drawMaterial.uniforms.nowColor.value.setHSL(this.nowColor.x, this.nowColor.y, this.nowColor.z) }, onComplete: () => { t = void 0 } }), e.target.removeEventListener("mouseover", this.mouseOverAnimation), e.target.addEventListener("mouseout", this.mouseOutAnimation) }, this.mouseMoveAnimation = e => { this.nowMouse.set(e.clientX / this.rootWidth, 1 - e.clientY / this.rootHeight) }, this.mouseOutAnimation = e => { e.target.classList.contains("js_hover_overview") && (this.drawMaterial.uniforms.drawParam_02.value.z = 0, this.radiusObj.radius = this.drawMaterial.uniforms.drawParam_02.value.y, Ci.to(this.radiusObj, { radius: 1, duration: .8, ease: "expo.out", overwrite: !0, onUpdate: () => { this.drawMaterial.uniforms.drawParam_02.value.y = this.radiusObj.radius } })), e.target.removeEventListener("mouseout", this.mouseOutAnimation), this.opacityObj.opacity = this.drawMaterial.uniforms.drawParam_01.value.x, Ci.to(this.opacityObj, { opacity: 0, duration: .8, ease: "expo.out", overwrite: !0, onUpdate: () => { this.drawMaterial.uniforms.drawParam_01.value.x = this.opacityObj.opacity } }), e.target.addEventListener("mouseover", this.mouseOverAnimation) }, this.renderer = e, this.scene = t, this.drawScene = new Tp, this.camera = n, this.isRendering = !1, this.overviewBtn = document.body.querySelector(".js_hover_overview"), this.strategyBtn = document.body.querySelector(".js_hover_strategy"), this.technologyBtn = document.body.querySelector(".js_hover_technology"), this.designBtn = document.body.querySelector(".js_hover_design"), this.marketingBtn = document.body.querySelector(".js_hover_marketing"), this.educationBtn = document.body.querySelector(".js_hover_education"), this.mouseDelay = .1, this.opacityObj = { opacity: 0 }, this.radiusObj = { radius: 1 }, this.nowMouse = new ul(0, 0), this.prevMouse = new ul(0, 0), this.nowColor = new Rl(0, 0, .1843137254901961), this.hslBg = new Rl(0, 0, .1843137254901961), this.hslEducation = new Rl(.07172995780590717, .8494623655913978, .6352941176470588), this.hslStrategy = new Rl(.7091836734693877, .4622641509433962, .5843137254901961), this.hslTechnology = new Rl(.5, .4426229508196722, .4784313725490196), this.hslMarketing = new Rl(.3806818181818182, .3464566929133859, .5019607843137255), this.hslDesign = new Rl(.9527777777777778, .5660377358490566, .584313725490196), this.rootWidth = e.domElement.clientWidth, this.rootHeight = e.domElement.clientHeight, this.bufferSizeRate = .25, this.buffer_draw = new Dl(this.rootWidth * this.bufferSizeRate, this.rootHeight * this.bufferSizeRate, { depthBuffer: !1, stencilBuffer: !1, minFilter: _o, magFilter: _o, type: Do }), this.buffer_01 = new Dl(this.rootWidth * this.bufferSizeRate, this.rootHeight * this.bufferSizeRate, { depthBuffer: !1, stencilBuffer: !1, minFilter: _o, magFilter: _o, type: Do }), this.buffer_02 = new Dl(this.rootWidth * this.bufferSizeRate, this.rootHeight * this.bufferSizeRate, { depthBuffer: !1, stencilBuffer: !1, minFilter: _o, magFilter: _o, type: Do }), this.drawMaterial = new Tm({ vertexShader: lv, fragmentShader: "precision highp float;\n#define GLSLIFY 1\nfloat blendLighten(float base, float blend) {\n\treturn max(blend,base);\n}\n\nvec3 blendLighten(vec3 base, vec3 blend) {\n\treturn vec3(blendLighten(base.r,blend.r),blendLighten(base.g,blend.g),blendLighten(base.b,blend.b));\n}\n\nvec3 blendLighten(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLighten(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_0 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_0;\n  vec3 i1 = min( g_0.xyz, l.zxy );\n  vec3 i2 = max( g_0.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n// opacity, accel, radius, accelBrightness\nuniform vec4 drawParam_01;\n// time, circleRadius, isOverview\nuniform vec4 drawParam_02;\nuniform vec3 nowColor;\nuniform vec2 mousePosition;\nuniform float aspect;\n\nvarying vec2 vUv;\n\nvec3 bgColor = vec3(0.1843137254901961);\nvec3 rgbEducation = vec3(0.9450980392156862, 0.592156862745098, 0.3254901960784313);\nvec3 rgbStrategy = vec3(0.49019607843137236, 0.3921568627450982, 0.776470588235294);\nvec3 rgbTechnology = vec3(0.2666666666666666, 0.6901960784313724, 0.6901960784313725);\nvec3 rgbMarketing = vec3(0.3294117647058823, 0.6745098039215687, 0.42745098039215673);\nvec3 rgbDesign = vec3(0.819607843137255, 0.349019607843137, 0.48235294117646965);\nfloat startRad = radians(0.0);\nfloat rateRad = radians(360.0 / 5.0);\n\nvec3 makeColor(float radius, vec2 uv, vec2 center, vec3 targetColor){\n    float lightness = clamp((radius - length(uv - center)) * (1.0 / radius), 0.0, 1.0);\n    float drawOpacity = lightness * lightness;\n    return (targetColor * drawOpacity) + (bgColor * (1.0 - drawOpacity));\n}\n\nvec3 makeCircle(vec2 center, vec2 uv, vec2 mouseCenter){\n    float noiseVal_01 = snoise(vec3(uv.x * aspect * 0.14, uv.y * 0.12, drawParam_02.x * 0.1)) * 0.4;\n    float noiseVal_02 = snoise(vec3(uv.x * aspect * 0.2, uv.y * 0.18, drawParam_02.x * 0.3)) * 0.5;\n    float noiseVal_03 = snoise(vec3(uv.x * aspect * 0.13, uv.y * 0.11, drawParam_02.x * 0.2)) * 0.55;\n    float noiseVal_04 = snoise(vec3(uv.x * aspect * 0.3, uv.y * 0.35, drawParam_02.x * 0.25)) * 0.6;\n    float noiseVal_05 = snoise(vec3(uv.x * aspect * 0.2, uv.y * 0.22, drawParam_02.x * 0.19)) * 0.45;\n    float noisedTime_01 = drawParam_02.x + (snoise(vec3(uv.x * aspect * 0.13, uv.y * 0.13, drawParam_02.x * 0.05)) * 2.0);\n    float noisedTime_02 = drawParam_02.x + (snoise(vec3(uv.x * aspect * 0.1, uv.y * 0.08, drawParam_02.x * 0.03)) * 3.0);\n    float noisedTime_03 = drawParam_02.x + (snoise(vec3(uv.x * aspect * 0.2, uv.y * 0.1, drawParam_02.x * 0.04)) * 1.5);\n    float noisedTime_04 = drawParam_02.x + (snoise(vec3(uv.x * aspect * 0.15, uv.y * 0.21, drawParam_02.x * 0.02)) * 2.5);\n    float noisedTime_05 = drawParam_02.x + (snoise(vec3(uv.x * aspect * 0.25, uv.y * 0.18, drawParam_02.x * 0.035)) * 3.2);\n\n    vec2 center_Education = vec2(cos(startRad + noisedTime_01), sin(startRad + noisedTime_01)) * (drawParam_02.y + noiseVal_01) + mouseCenter;\n    vec2 center_Strategy = vec2(cos(startRad + noisedTime_02 + (rateRad * 1.0)), sin(startRad + noisedTime_02 + (rateRad * 1.0))) * (drawParam_02.y + noiseVal_02) + mouseCenter;\n    vec2 center_Technology = vec2(cos(startRad + noisedTime_03 + (rateRad * 2.0)), sin(startRad + noisedTime_03 + (rateRad * 2.0))) * (drawParam_02.y + noiseVal_03) + mouseCenter;\n    vec2 center_Marketing = vec2(cos(startRad + noisedTime_04 + (rateRad * 3.0)), sin(startRad + noisedTime_04 + (rateRad * 3.0))) * (drawParam_02.y + noiseVal_04) + mouseCenter;\n    vec2 center_Design = vec2(cos(startRad + noisedTime_05 + (rateRad * 4.0)), sin(startRad + noisedTime_05 + (rateRad * 4.0))) * (drawParam_02.y + noiseVal_05) + mouseCenter;\n    vec3 c_educationColor = makeColor(drawParam_01.z * 2.0, center, center_Education, rgbEducation);\n    vec3 c_strategyColor = makeColor(drawParam_01.z * 2.0, center, center_Strategy, rgbStrategy);\n    vec3 c_technologyColor = makeColor(drawParam_01.z * 2.0, center, center_Technology, rgbTechnology);\n    vec3 c_marketingColor = makeColor(drawParam_01.z * 2.0, center, center_Marketing, rgbMarketing);\n    vec3 c_designColor = makeColor(drawParam_01.z * 2.0, center, center_Design, rgbDesign);\n    return blendLighten(blendLighten(blendLighten(blendLighten(c_educationColor, c_strategyColor), c_technologyColor), c_marketingColor), c_designColor);\n}\n\nvec4 makeLocus(vec2 uv, vec2 mouseCenter){\n    float lightness = clamp((drawParam_01.z - length(uv - mouseCenter)) * (1.0 / drawParam_01.z), 0.0, 1.0);\n    float drawOpacity = lightness * max(drawParam_01.y * drawParam_01.w, 1.0) * drawParam_01.x;\n    return vec4(nowColor, drawOpacity * drawOpacity);\n}\n\nvoid main(){\n    vec2 uv = vec2(vUv.x * aspect, vUv.y);\n    vec2 center = (uv - vec2(aspect * 0.5, 0.5)) * vec2(2.0);\n    vec2 mouseCenter = vec2(mousePosition.x * aspect, mousePosition.y);\n    vec2 mouseCircleCenter = (mouseCenter - vec2(aspect * 0.5, 0.5)) * vec2(2.0);\n\n    gl_FragColor = (drawParam_02.z > 0.0) ? vec4(makeCircle(center, uv, mouseCircleCenter), drawParam_01.x) : makeLocus(uv, mouseCenter);\n    // gl_FragColor = CircleColor;\n}", transparent: !0, uniforms: { drawParam_01: { value: new Cl(0, 0, .7, 50) }, drawParam_02: { value: new Cl(0, 1.5, 0, 0) }, nowColor: { value: (new _l).setHSL(this.nowColor.x, this.nowColor.y, this.nowColor.z) }, mousePosition: { value: new ul(.5, .5) }, aspect: { value: this.rootWidth / this.rootHeight } } }), this.drawMaterial.uniformsNeedUpdate = !0, this.blurMaterial = new Tm({ vertexShader: lv, fragmentShader: "precision highp float;\n#define GLSLIFY 1\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_0 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_0;\n  vec3 i1 = min( g_0.xyz, l.zxy );\n  vec3 i2 = max( g_0.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nuniform float time;\nuniform vec4 noiseParam;\nuniform sampler2D drawBuffer;\nuniform sampler2D beforeBuffer;\nuniform float aspect;\nvarying vec2 vUv;\n\nvec3 tex(vec2 uv);\nhighp float random(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\n#ifndef TAU\n  #define TAU 6.28318530718\n#endif\n\n//Use last part of hash function to generate new random radius and angle\nvec2 mult(inout vec2 r) {\n  r = fract(r * vec2(12.9898,78.233));\n  return sqrt(r.x + .001) * vec2(sin(r.y * TAU), cos(r.y * TAU));\n}\n\nvec3 blur(vec2 uv, float radius, float aspect, float offset) {\n  vec2 circle = vec2(radius);\n  circle.x *= aspect;\n  vec2 rnd = vec2(random(vec2(uv + offset)));\n\n  vec3 acc = vec3(0.0);\n  for (int i = 0; i < 10; i++) {\n    acc += tex(uv + circle * mult(rnd)).xyz;\n  }\n  return acc / float(10);\n}\n\nvec3 blur(vec2 uv, float radius, float aspect) {\n  return blur(uv, radius, aspect, 0.0);\n}\n\nvec3 blur(vec2 uv, float radius) {\n  return blur(uv, radius, 1.0);\n}\n\nvec3 tex(vec2 uv) {\n  return texture2D(drawBuffer, uv).rgb;\n}\n\nvoid main(){\n    float noiseVal = snoise(vec3(vUv.x * noiseParam.r, vUv.y * noiseParam.g, time * noiseParam.b));\n    vec4 drawColor = texture2D( drawBuffer, vUv);\n    drawColor = vec4(blur(vUv + (noiseVal * noiseParam.a), 0.003, aspect, 0.0), drawColor.a);\n\n    vec4 beforeColor = texture2D( beforeBuffer, vUv);\n    // beforeColor = vec4(blur(vUv, 0.01, aspect, 0.0), beforeColor.a);\n\n    vec4 distColor =  mix(drawColor, beforeColor, 0.94);\n    distColor.a = min(distColor.a, 1.0);\n    gl_FragColor = distColor;\n}", transparent: !0, uniforms: { time: { value: 0 }, noiseParam: { value: new Cl(2, 2, .2, .02) }, drawBuffer: { type: "t", value: this.buffer_draw.texture }, beforeBuffer: { type: "t", value: null }, aspect: { value: this.rootWidth / this.rootHeight } } }), this.blurMaterial.uniformsNeedUpdate = !0 } init(e, t) { this.rootWidth = e, this.rootHeight = t, this.buffer_draw.setSize(this.rootWidth, this.rootHeight), this.buffer_01.setSize(this.rootWidth, this.rootHeight), this.buffer_02.setSize(this.rootWidth, this.rootHeight), this.drawMaterial.uniforms.aspect.value = this.rootWidth / this.rootHeight, this.blurMaterial.uniforms.aspect.value = this.rootWidth / this.rootHeight; const n = new Xu(this.rootWidth, this.rootHeight); this.drawPlane = new Tu(n, this.drawMaterial), this.distPlane = new Tu(n, this.blurMaterial), this.drawScene.add(this.drawPlane), this.scene.add(this.distPlane), this.isRendering = !0, this.addOverEvent() } addOverEvent() { this.overviewBtn.addEventListener("mouseover", this.mouseOverAnimation), this.strategyBtn.addEventListener("mouseover", this.mouseOverAnimation), this.technologyBtn.addEventListener("mouseover", this.mouseOverAnimation), this.designBtn.addEventListener("mouseover", this.mouseOverAnimation), this.marketingBtn.addEventListener("mouseover", this.mouseOverAnimation), this.educationBtn.addEventListener("mouseover", this.mouseOverAnimation), window.addEventListener("mousemove", this.mouseMoveAnimation) } removeListeners(e) { e.removeEventListener("mouseout", this.mouseOutAnimation), e.removeEventListener("mouseover", this.mouseOverAnimation) } removeHoverEvent() { this.removeListeners(this.overviewBtn), this.removeListeners(this.strategyBtn), this.removeListeners(this.technologyBtn), this.removeListeners(this.designBtn), this.removeListeners(this.marketingBtn), this.removeListeners(this.educationBtn) } fadeOutDestroy(e, t, n) { this.removeHoverEvent(), Ci.killTweensOf(this.opacityObj), Ci.killTweensOf(this.radiusObj), this.opacityObj.opacity = this.drawMaterial.uniforms.drawParam_01.value.x, Ci.to(this.opacityObj, { opacity: 0, duration: e, ease: t, overwrite: !0, onUpdate: () => { this.drawMaterial.uniforms.drawParam_01.value.x = this.opacityObj.opacity }, onComplete: () => { this.destroy(), n() } }) } destroy() { this.gui && (this.gui.destroy(), this.gui = void 0), window.removeEventListener("mousemove", this.mouseMoveAnimation), this.renderer.setRenderTarget(this.buffer_draw), this.renderer.clear(), this.renderer.setRenderTarget(this.buffer_01), this.renderer.clear(), this.renderer.setRenderTarget(this.buffer_02), this.renderer.clear(), this.drawScene.remove(this.drawPlane), this.scene.remove(this.distPlane), this.drawPlane = void 0, this.distPlane = void 0, this.isRendering = !1 } update(e) { this.blurMaterial.uniforms.time.value = e / 1e3, this.drawMaterial.uniforms.drawParam_02.value.x = 10 + e / 1e3, this.drawMaterial.uniforms.mousePosition.value.lerp(this.nowMouse, this.mouseDelay), this.drawMaterial.uniforms.drawParam_01.value.y = Math.sqrt(Math.pow(this.prevMouse.x - this.drawMaterial.uniforms.mousePosition.value.x, 2) + Math.pow(this.prevMouse.y - this.drawMaterial.uniforms.mousePosition.value.y, 2)), this.prevMouse.set(this.drawMaterial.uniforms.mousePosition.value.x, this.drawMaterial.uniforms.mousePosition.value.y), this.renderer.setRenderTarget(this.buffer_draw), this.renderer.render(this.drawScene, this.camera), this.buffSwitch ? (this.renderer.setRenderTarget(this.buffer_02), this.renderer.render(this.scene, this.camera), this.blurMaterial.uniforms.beforeBuffer.value = this.buffer_02.texture) : (this.renderer.setRenderTarget(this.buffer_01), this.renderer.render(this.scene, this.camera), this.blurMaterial.uniforms.beforeBuffer.value = this.buffer_01.texture), this.buffSwitch = !this.buffSwitch, this.renderer.setRenderTarget(null) } resize(e, t) { this.destroy(), this.init(e, t) } addGUI() { this.gui = new GUI; const e = this.gui.addFolder("Menu"); this.GUIObj = { mouse_delay: this.mouseDelay, shape_radius: this.drawMaterial.uniforms.drawParam_01.value.z, accel_brightness: this.drawMaterial.uniforms.drawParam_01.value.w, noiseScale_X: this.blurMaterial.uniforms.noiseParam.value.x, noiseScale_Y: this.blurMaterial.uniforms.noiseParam.value.y, noiseTimeScale: this.blurMaterial.uniforms.noiseParam.value.z, noiseStrength: this.blurMaterial.uniforms.noiseParam.value.w }, e.add(this.GUIObj, "mouse_delay", 0, 1).onChange((e => { this.mouseDelay = e })), e.add(this.GUIObj, "shape_radius", 0, 2).onChange((e => { this.drawMaterial.uniforms.drawParam_01.value.z = e })), e.add(this.GUIObj, "accel_brightness", 1, 100).onChange((e => { this.drawMaterial.uniforms.drawParam_01.value.w = e })), e.add(this.GUIObj, "noiseScale_X", 0, 5).onChange((e => { this.blurMaterial.uniforms.noiseParam.value.x = e })), e.add(this.GUIObj, "noiseScale_Y", 0, 5).onChange((e => { this.blurMaterial.uniforms.noiseParam.value.y = e })), e.add(this.GUIObj, "noiseTimeScale", .1, 3).onChange((e => { this.blurMaterial.uniforms.noiseParam.value.z = e })), e.add(this.GUIObj, "noiseStrength", 0, 1).onChange((e => { this.blurMaterial.uniforms.noiseParam.value.w = e })), e.open() } } var dv; function pv(e) { return e.isPerspectiveCamera } function fv(e) { return e.isOrthographicCamera } !function (e) { e[e.NONE = 0] = "NONE", e[e.ROTATE = 1] = "ROTATE", e[e.TRUCK = 2] = "TRUCK", e[e.OFFSET = 3] = "OFFSET", e[e.DOLLY = 4] = "DOLLY", e[e.ZOOM = 5] = "ZOOM", e[e.TOUCH_ROTATE = 6] = "TOUCH_ROTATE", e[e.TOUCH_TRUCK = 7] = "TOUCH_TRUCK", e[e.TOUCH_OFFSET = 8] = "TOUCH_OFFSET", e[e.TOUCH_DOLLY = 9] = "TOUCH_DOLLY", e[e.TOUCH_ZOOM = 10] = "TOUCH_ZOOM", e[e.TOUCH_DOLLY_TRUCK = 11] = "TOUCH_DOLLY_TRUCK", e[e.TOUCH_DOLLY_OFFSET = 12] = "TOUCH_DOLLY_OFFSET", e[e.TOUCH_ZOOM_TRUCK = 13] = "TOUCH_ZOOM_TRUCK", e[e.TOUCH_ZOOM_OFFSET = 14] = "TOUCH_ZOOM_OFFSET" }(dv || (dv = {})); const mv = 2 * Math.PI, gv = Math.PI / 2; function vv(e, t = 1e-5) { return Math.abs(e) < t } function yv(e, t, n = 1e-5) { return vv(e - t, n) } function xv(e, t) { return Math.round(e / t) * t } function _v(e) { return isFinite(e) ? e : e < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE } function wv(e) { return Math.abs(e) < Number.MAX_VALUE ? e : e * (1 / 0) } function bv(e, t) { t.set(0, 0), e.forEach((e => { t.x += e.clientX, t.y += e.clientY })), t.x /= e.length, t.y /= e.length } function Sv(e, t) { return !!fv(e) && (console.warn(`${t} is not supported in OrthographicCamera`), !0) } function Ev(e) { return e.invert ? e.invert() : e.inverse(), e } const Mv = "undefined" != typeof window, Tv = Mv && /Mac/.test(navigator.platform), Cv = !(Mv && "PointerEvent" in window), Dv = Object.freeze(dv), Lv = 1 / 8; let Av, Pv, Rv, Ov, Iv, Fv, zv, kv, Nv, Bv, Hv, Uv, Vv, Gv, jv, Wv, qv, $v, Xv, Yv; class Zv extends class { constructor() { this._listeners = {} } addEventListener(e, t) { const n = this._listeners; void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t) } removeEventListener(e, t) { const n = this._listeners[e]; if (void 0 !== n) { const e = n.indexOf(t); -1 !== e && n.splice(e, 1) } } removeAllEventListeners(e) { e ? Array.isArray(this._listeners[e]) && (this._listeners[e].length = 0) : this._listeners = {} } dispatchEvent(e) { const t = this._listeners[e.type]; if (void 0 !== t) { e.target = this; const n = t.slice(0); for (let t = 0, i = n.length; t < i; t++)n[t].call(this, e) } } }{ constructor(e, t) { if (super(), this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minDistance = 0, this.maxDistance = 1 / 0, this.infinityDolly = !1, this.minZoom = .01, this.maxZoom = 1 / 0, this.dampingFactor = .05, this.draggingDampingFactor = .25, this.azimuthRotateSpeed = 1, this.polarRotateSpeed = 1, this.dollySpeed = 1, this.truckSpeed = 2, this.dollyToCursor = !1, this.dragToOffset = !1, this.verticalDragToForward = !1, this.boundaryFriction = 0, this.restThreshold = .01, this.colliderMeshes = [], this.cancel = () => { }, this._enabled = !0, this._state = dv.NONE, this._viewport = null, this._dollyControlAmount = 0, this._hasRested = !0, this._boundaryEnclosesCamera = !1, this._needsUpdate = !0, this._updatedLastTime = !1, this._elementRect = new DOMRect, this._activePointers = [], this._truckInternal = (e, t, n) => { if (pv(this._camera)) { const i = Fv.copy(this._camera.position).sub(this._target), r = this._camera.getEffectiveFOV() * Av.MathUtils.DEG2RAD, s = i.length() * Math.tan(.5 * r), a = this.truckSpeed * e * s / this._elementRect.height, o = this.truckSpeed * t * s / this._elementRect.height; this.verticalDragToForward ? (n ? this.setFocalOffset(this._focalOffsetEnd.x + a, this._focalOffsetEnd.y, this._focalOffsetEnd.z, !0) : this.truck(a, 0, !0), this.forward(-o, !0)) : n ? this.setFocalOffset(this._focalOffsetEnd.x + a, this._focalOffsetEnd.y + o, this._focalOffsetEnd.z, !0) : this.truck(a, o, !0) } else if (fv(this._camera)) { const i = this._camera, r = e * (i.right - i.left) / i.zoom / this._elementRect.width, s = t * (i.top - i.bottom) / i.zoom / this._elementRect.height; n ? this.setFocalOffset(this._focalOffsetEnd.x + r, this._focalOffsetEnd.y + s, this._focalOffsetEnd.z, !0) : this.truck(r, s, !0) } }, this._rotateInternal = (e, t) => { const n = mv * this.azimuthRotateSpeed * e / this._elementRect.height, i = mv * this.polarRotateSpeed * t / this._elementRect.height; this.rotate(n, i, !0) }, this._dollyInternal = (e, t, n) => { const i = Math.pow(.95, -e * this.dollySpeed), r = this._sphericalEnd.radius * i, s = this._sphericalEnd.radius, a = s * (e >= 0 ? -1 : 1); this.dollyTo(r), this.infinityDolly && (r < this.minDistance || this.maxDistance === this.minDistance) && (this._camera.getWorldDirection(Fv), this._targetEnd.add(Fv.normalize().multiplyScalar(a)), this._target.add(Fv.normalize().multiplyScalar(a))), this.dollyToCursor && (this._dollyControlAmount += this._sphericalEnd.radius - s, this.infinityDolly && (r < this.minDistance || this.maxDistance === this.minDistance) && (this._dollyControlAmount -= a), this._dollyControlCoord.set(t, n)) }, this._zoomInternal = (e, t, n) => { const i = Math.pow(.95, e * this.dollySpeed); this.zoomTo(this._zoom * i), this.dollyToCursor && (this._dollyControlAmount = this._zoomEnd, this._dollyControlCoord.set(t, n)) }, void 0 === Av && console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."), this._camera = e, this._yAxisUpSpace = (new Av.Quaternion).setFromUnitVectors(this._camera.up, Rv), this._yAxisUpSpaceInverse = Ev(this._yAxisUpSpace.clone()), this._state = dv.NONE, this._domElement = t, this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none", this._target = new Av.Vector3, this._targetEnd = this._target.clone(), this._focalOffset = new Av.Vector3, this._focalOffsetEnd = this._focalOffset.clone(), this._spherical = (new Av.Spherical).setFromVector3(Fv.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)), this._sphericalEnd = this._spherical.clone(), this._zoom = this._camera.zoom, this._zoomEnd = this._zoom, this._nearPlaneCorners = [new Av.Vector3, new Av.Vector3, new Av.Vector3, new Av.Vector3], this._updateNearPlaneCorners(), this._boundary = new Av.Box3(new Av.Vector3(-1 / 0, -1 / 0, -1 / 0), new Av.Vector3(1 / 0, 1 / 0, 1 / 0)), this._target0 = this._target.clone(), this._position0 = this._camera.position.clone(), this._zoom0 = this._zoom, this._focalOffset0 = this._focalOffset.clone(), this._dollyControlAmount = 0, this._dollyControlCoord = new Av.Vector2, this.mouseButtons = { left: dv.ROTATE, middle: dv.DOLLY, right: dv.TRUCK, wheel: pv(this._camera) ? dv.DOLLY : fv(this._camera) ? dv.ZOOM : dv.NONE, shiftLeft: dv.NONE }, this.touches = { one: dv.TOUCH_ROTATE, two: pv(this._camera) ? dv.TOUCH_DOLLY_TRUCK : fv(this._camera) ? dv.TOUCH_ZOOM_TRUCK : dv.NONE, three: dv.TOUCH_TRUCK }, this._domElement) { const e = new Av.Vector2, t = new Av.Vector2, n = new Av.Vector2, i = e => { if (!this._enabled) return; const t = { pointerId: e.pointerId, clientX: e.clientX, clientY: e.clientY }; switch (this._activePointers.push(t), e.button) { case Av.MOUSE.LEFT: this._state = e.shiftKey ? this.mouseButtons.shiftLeft : this.mouseButtons.left; break; case Av.MOUSE.MIDDLE: this._state = this.mouseButtons.middle; break; case Av.MOUSE.RIGHT: this._state = this.mouseButtons.right }if ("touch" === e.pointerType) switch (this._activePointers.length) { case 1: this._state = this.touches.one; break; case 2: this._state = this.touches.two; break; case 3: this._state = this.touches.three }this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", c), this._domElement.ownerDocument.addEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.addEventListener("pointerup", c), m() }, r = e => { if (!this._enabled) return; const t = { pointerId: 0, clientX: e.clientX, clientY: e.clientY }; switch (this._activePointers.push(t), e.button) { case Av.MOUSE.LEFT: this._state = e.shiftKey ? this.mouseButtons.shiftLeft : this.mouseButtons.left; break; case Av.MOUSE.MIDDLE: this._state = this.mouseButtons.middle; break; case Av.MOUSE.RIGHT: this._state = this.mouseButtons.right }this._domElement.ownerDocument.removeEventListener("mousemove", o), this._domElement.ownerDocument.removeEventListener("mouseup", u), this._domElement.ownerDocument.addEventListener("mousemove", o), this._domElement.ownerDocument.addEventListener("mouseup", u), m() }, s = e => { if (this._enabled) { switch (e.preventDefault(), Array.prototype.forEach.call(e.changedTouches, (e => { const t = { pointerId: e.identifier, clientX: e.clientX, clientY: e.clientY }; this._activePointers.push(t) })), this._activePointers.length) { case 1: this._state = this.touches.one; break; case 2: this._state = this.touches.two; break; case 3: this._state = this.touches.three }this._domElement.ownerDocument.removeEventListener("touchmove", l, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("touchend", h), this._domElement.ownerDocument.addEventListener("touchmove", l, { passive: !1 }), this._domElement.ownerDocument.addEventListener("touchend", h), m() } }, a = e => { e.cancelable && e.preventDefault(); const t = e.pointerId, n = this._findPointerById(t); n && (n.clientX = e.clientX, n.clientY = e.clientY, g()) }, o = e => { const t = this._findPointerById(0); t && (t.clientX = e.clientX, t.clientY = e.clientY, g()) }, l = e => { e.cancelable && e.preventDefault(), Array.prototype.forEach.call(e.changedTouches, (e => { const t = e.identifier, n = this._findPointerById(t); n && (n.clientX = e.clientX, n.clientY = e.clientY) })), g() }, c = e => { const t = e.pointerId, n = this._findPointerById(t); if (n && this._activePointers.splice(this._activePointers.indexOf(n), 1), "touch" === e.pointerType) switch (this._activePointers.length) { case 0: this._state = dv.NONE; break; case 1: this._state = this.touches.one; break; case 2: this._state = this.touches.two; break; case 3: this._state = this.touches.three } else this._state = dv.NONE; v() }, u = () => { const e = this._findPointerById(0); e && this._activePointers.splice(this._activePointers.indexOf(e), 1), this._state = dv.NONE, v() }, h = e => { switch (Array.prototype.forEach.call(e.changedTouches, (e => { const t = e.identifier, n = this._findPointerById(t); n && this._activePointers.splice(this._activePointers.indexOf(n), 1) })), this._activePointers.length) { case 0: this._state = dv.NONE; break; case 1: this._state = this.touches.one; break; case 2: this._state = this.touches.two; break; case 3: this._state = this.touches.three }v() }; let d = -1; const p = e => { if (!this._enabled || this.mouseButtons.wheel === dv.NONE) return; if (e.preventDefault(), this.dollyToCursor || this.mouseButtons.wheel === dv.ROTATE || this.mouseButtons.wheel === dv.TRUCK) { const e = performance.now(); d - e < 1e3 && this._getClientRect(this._elementRect), d = e } const t = Tv ? -1 : -3, n = 1 === e.deltaMode ? e.deltaY / t : e.deltaY / (10 * t), i = this.dollyToCursor ? (e.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, r = this.dollyToCursor ? (e.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0; switch (this.mouseButtons.wheel) { case dv.ROTATE: this._rotateInternal(e.deltaX, e.deltaY); break; case dv.TRUCK: this._truckInternal(e.deltaX, e.deltaY, !1); break; case dv.OFFSET: this._truckInternal(e.deltaX, e.deltaY, !0); break; case dv.DOLLY: this._dollyInternal(-n, i, r); break; case dv.ZOOM: this._zoomInternal(-n, i, r) }this.dispatchEvent({ type: "control" }) }, f = e => { this._enabled && e.preventDefault() }, m = () => { if (this._enabled) { if (bv(this._activePointers, Iv), this._getClientRect(this._elementRect), e.copy(Iv), t.copy(Iv), this._activePointers.length >= 2) { const e = Iv.x - this._activePointers[1].clientX, i = Iv.y - this._activePointers[1].clientY, r = Math.sqrt(e * e + i * i); n.set(0, r); const s = .5 * (this._activePointers[0].clientX + this._activePointers[1].clientX), a = .5 * (this._activePointers[0].clientY + this._activePointers[1].clientY); t.set(s, a) } this.dispatchEvent({ type: "controlstart" }) } }, g = () => { if (!this._enabled) return; bv(this._activePointers, Iv); const i = t.x - Iv.x, r = t.y - Iv.y; switch (t.copy(Iv), this._state) { case dv.ROTATE: case dv.TOUCH_ROTATE: this._rotateInternal(i, r); break; case dv.DOLLY: case dv.ZOOM: { const t = this.dollyToCursor ? (e.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, n = this.dollyToCursor ? (e.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0; this._state === dv.DOLLY ? this._dollyInternal(r * Lv, t, n) : this._zoomInternal(r * Lv, t, n); break } case dv.TOUCH_DOLLY: case dv.TOUCH_ZOOM: case dv.TOUCH_DOLLY_TRUCK: case dv.TOUCH_ZOOM_TRUCK: case dv.TOUCH_DOLLY_OFFSET: case dv.TOUCH_ZOOM_OFFSET: { const e = Iv.x - this._activePointers[1].clientX, s = Iv.y - this._activePointers[1].clientY, a = Math.sqrt(e * e + s * s), o = n.y - a; n.set(0, a); const l = this.dollyToCursor ? (t.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, c = this.dollyToCursor ? (t.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0; this._state === dv.TOUCH_DOLLY || this._state === dv.TOUCH_DOLLY_TRUCK || this._state === dv.TOUCH_DOLLY_OFFSET ? this._dollyInternal(o * Lv, l, c) : this._zoomInternal(o * Lv, l, c), this._state === dv.TOUCH_DOLLY_TRUCK || this._state === dv.TOUCH_ZOOM_TRUCK ? this._truckInternal(i, r, !1) : this._state !== dv.TOUCH_DOLLY_OFFSET && this._state !== dv.TOUCH_ZOOM_OFFSET || this._truckInternal(i, r, !0); break } case dv.TRUCK: case dv.TOUCH_TRUCK: this._truckInternal(i, r, !1); break; case dv.OFFSET: case dv.TOUCH_OFFSET: this._truckInternal(i, r, !0) }this.dispatchEvent({ type: "control" }) }, v = () => { bv(this._activePointers, Iv), t.copy(Iv), 0 === this._activePointers.length && (this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", c), this._domElement.ownerDocument.removeEventListener("touchmove", l, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("touchend", h), this.dispatchEvent({ type: "controlend" })) }; this._domElement.addEventListener("pointerdown", i), Cv && this._domElement.addEventListener("mousedown", r), Cv && this._domElement.addEventListener("touchstart", s), this._domElement.addEventListener("pointercancel", c), this._domElement.addEventListener("wheel", p, { passive: !1 }), this._domElement.addEventListener("contextmenu", f), this._removeAllEventListeners = () => { this._domElement.removeEventListener("pointerdown", i), this._domElement.removeEventListener("mousedown", r), this._domElement.removeEventListener("touchstart", s), this._domElement.removeEventListener("pointercancel", c), this._domElement.removeEventListener("wheel", p, { passive: !1 }), this._domElement.removeEventListener("contextmenu", f), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("mousemove", o), this._domElement.ownerDocument.removeEventListener("touchmove", l, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", c), this._domElement.ownerDocument.removeEventListener("mouseup", u), this._domElement.ownerDocument.removeEventListener("touchend", h) }, this.cancel = () => { this._state !== dv.NONE && (this._state = dv.NONE, this._activePointers.length = 0, v()) } } this.update(0) } static install(e) { Av = e.THREE, Pv = Object.freeze(new Av.Vector3(0, 0, 0)), Rv = Object.freeze(new Av.Vector3(0, 1, 0)), Ov = Object.freeze(new Av.Vector3(0, 0, 1)), Iv = new Av.Vector2, Fv = new Av.Vector3, zv = new Av.Vector3, kv = new Av.Vector3, Nv = new Av.Vector3, Bv = new Av.Vector3, Hv = new Av.Vector3, Uv = new Av.Spherical, Vv = new Av.Spherical, Gv = new Av.Box3, jv = new Av.Box3, Wv = new Av.Sphere, qv = new Av.Quaternion, $v = new Av.Quaternion, Xv = new Av.Matrix4, Yv = new Av.Raycaster } static get ACTION() { return Dv } get camera() { return this._camera } set camera(e) { this._camera = e, this.updateCameraUp(), this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0 } get enabled() { return this._enabled } set enabled(e) { this._enabled = e, e ? (this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none") : (this.cancel(), this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = "") } get active() { return !this._hasRested } get currentAction() { return this._state } get distance() { return this._spherical.radius } set distance(e) { this._spherical.radius === e && this._sphericalEnd.radius === e || (this._spherical.radius = e, this._sphericalEnd.radius = e, this._needsUpdate = !0) } get azimuthAngle() { return this._spherical.theta } set azimuthAngle(e) { this._spherical.theta === e && this._sphericalEnd.theta === e || (this._spherical.theta = e, this._sphericalEnd.theta = e, this._needsUpdate = !0) } get polarAngle() { return this._spherical.phi } set polarAngle(e) { this._spherical.phi === e && this._sphericalEnd.phi === e || (this._spherical.phi = e, this._sphericalEnd.phi = e, this._needsUpdate = !0) } get boundaryEnclosesCamera() { return this._boundaryEnclosesCamera } set boundaryEnclosesCamera(e) { this._boundaryEnclosesCamera = e, this._needsUpdate = !0 } addEventListener(e, t) { super.addEventListener(e, t) } removeEventListener(e, t) { super.removeEventListener(e, t) } rotate(e, t, n = !1) { return this.rotateTo(this._sphericalEnd.theta + e, this._sphericalEnd.phi + t, n) } rotateAzimuthTo(e, t = !1) { return this.rotateTo(e, this._sphericalEnd.phi, t) } rotatePolarTo(e, t = !1) { return this.rotateTo(this._sphericalEnd.theta, e, t) } rotateTo(e, t, n = !1) { const i = Av.MathUtils.clamp(e, this.minAzimuthAngle, this.maxAzimuthAngle), r = Av.MathUtils.clamp(t, this.minPolarAngle, this.maxPolarAngle); this._sphericalEnd.theta = i, this._sphericalEnd.phi = r, this._sphericalEnd.makeSafe(), this._needsUpdate = !0, n || (this._spherical.theta = this._sphericalEnd.theta, this._spherical.phi = this._sphericalEnd.phi); const s = !n || yv(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && yv(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold); return this._createOnRestPromise(s) } dolly(e, t = !1) { return this.dollyTo(this._sphericalEnd.radius - e, t) } dollyTo(e, t = !1) { const n = this._sphericalEnd.radius, i = Av.MathUtils.clamp(e, this.minDistance, this.maxDistance); if (this.colliderMeshes.length >= 1) { const e = this._collisionTest(), t = yv(e, this._spherical.radius); if (!(n > i) && t) return Promise.resolve(); this._sphericalEnd.radius = Math.min(i, e) } else this._sphericalEnd.radius = i; this._needsUpdate = !0, t || (this._spherical.radius = this._sphericalEnd.radius); const r = !t || yv(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold); return this._createOnRestPromise(r) } zoom(e, t = !1) { return this.zoomTo(this._zoomEnd + e, t) } zoomTo(e, t = !1) { this._zoomEnd = Av.MathUtils.clamp(e, this.minZoom, this.maxZoom), this._needsUpdate = !0, t || (this._zoom = this._zoomEnd); const n = !t || yv(this._zoom, this._zoomEnd, this.restThreshold); return this._createOnRestPromise(n) } pan(e, t, n = !1) { return console.warn("`pan` has been renamed to `truck`"), this.truck(e, t, n) } truck(e, t, n = !1) { this._camera.updateMatrix(), Nv.setFromMatrixColumn(this._camera.matrix, 0), Bv.setFromMatrixColumn(this._camera.matrix, 1), Nv.multiplyScalar(e), Bv.multiplyScalar(-t); const i = Fv.copy(Nv).add(Bv), r = zv.copy(this._targetEnd).add(i); return this.moveTo(r.x, r.y, r.z, n) } forward(e, t = !1) { Fv.setFromMatrixColumn(this._camera.matrix, 0), Fv.crossVectors(this._camera.up, Fv), Fv.multiplyScalar(e); const n = zv.copy(this._targetEnd).add(Fv); return this.moveTo(n.x, n.y, n.z, t) } moveTo(e, t, n, i = !1) { const r = Fv.set(e, t, n).sub(this._targetEnd); this._encloseToBoundary(this._targetEnd, r, this.boundaryFriction), this._needsUpdate = !0, i || this._target.copy(this._targetEnd); const s = !i || yv(this._target.x, this._targetEnd.x, this.restThreshold) && yv(this._target.y, this._targetEnd.y, this.restThreshold) && yv(this._target.z, this._targetEnd.z, this.restThreshold); return this._createOnRestPromise(s) } fitToBox(e, t, { paddingLeft: n = 0, paddingRight: i = 0, paddingBottom: r = 0, paddingTop: s = 0 } = {}) { const a = [], o = e.isBox3 ? Gv.copy(e) : Gv.setFromObject(e); o.isEmpty() && (console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"), Promise.resolve()); const l = xv(this._sphericalEnd.theta, gv), c = xv(this._sphericalEnd.phi, gv); a.push(this.rotateTo(l, c, t)); const u = Fv.setFromSpherical(this._sphericalEnd).normalize(), h = qv.setFromUnitVectors(u, Ov); yv(Math.abs(u.y), 1) && h.multiply($v.setFromAxisAngle(Rv, l)); const d = jv.makeEmpty(); zv.copy(o.min).applyQuaternion(h), d.expandByPoint(zv), zv.copy(o.min).setX(o.max.x).applyQuaternion(h), d.expandByPoint(zv), zv.copy(o.min).setY(o.max.y).applyQuaternion(h), d.expandByPoint(zv), zv.copy(o.max).setZ(o.min.z).applyQuaternion(h), d.expandByPoint(zv), zv.copy(o.min).setZ(o.max.z).applyQuaternion(h), d.expandByPoint(zv), zv.copy(o.max).setY(o.min.y).applyQuaternion(h), d.expandByPoint(zv), zv.copy(o.max).setX(o.min.x).applyQuaternion(h), d.expandByPoint(zv), zv.copy(o.max).applyQuaternion(h), d.expandByPoint(zv), h.setFromUnitVectors(Ov, u), d.min.x -= n, d.min.y -= r, d.max.x += i, d.max.y += s; const p = d.getSize(Fv), f = d.getCenter(zv).applyQuaternion(h); if (pv(this._camera)) { const e = this.getDistanceToFitBox(p.x, p.y, p.z); a.push(this.moveTo(f.x, f.y, f.z, t)), a.push(this.dollyTo(e, t)), a.push(this.setFocalOffset(0, 0, 0, t)) } else if (fv(this._camera)) { const e = this._camera, n = e.right - e.left, i = e.top - e.bottom, r = Math.min(n / p.x, i / p.y); a.push(this.moveTo(f.x, f.y, f.z, t)), a.push(this.zoomTo(r, t)), a.push(this.setFocalOffset(0, 0, 0, t)) } return Promise.all(a) } fitTo(e, t, n = {}) { return console.warn("camera-controls: fitTo() has been renamed to fitToBox()"), this.fitToBox(e, t, n) } fitToSphere(e, t) { const n = [], i = e instanceof Av.Sphere ? Wv.copy(e) : function (e, t) { const n = t, i = n.center; Gv.makeEmpty(), e.traverseVisible((e => { e.isMesh && Gv.expandByObject(e) })), Gv.getCenter(i); let r = 0; return e.traverseVisible((e => { if (!e.isMesh) return; const t = e, n = t.geometry.clone(); if (n.applyMatrix4(t.matrixWorld), n.isBufferGeometry) { const e = n.attributes.position; for (let t = 0, n = e.count; t < n; t++)Fv.fromBufferAttribute(e, t), r = Math.max(r, i.distanceToSquared(Fv)) } else { const e = n.attributes.position, t = new Av.Vector3; for (let n = 0, s = e.count; n < s; n++)t.fromBufferAttribute(e, n), r = Math.max(r, i.distanceToSquared(t)) } })), n.radius = Math.sqrt(r), n }(e, Wv); if (n.push(this.moveTo(i.center.x, i.center.y, i.center.z, t)), pv(this._camera)) { const e = this.getDistanceToFitSphere(i.radius); n.push(this.dollyTo(e, t)) } else if (fv(this._camera)) { const e = this._camera.right - this._camera.left, r = this._camera.top - this._camera.bottom, s = 2 * i.radius, a = Math.min(e / s, r / s); n.push(this.zoomTo(a, t)) } return n.push(this.setFocalOffset(0, 0, 0, t)), Promise.all(n) } setLookAt(e, t, n, i, r, s, a = !1) { const o = zv.set(i, r, s), l = Fv.set(e, t, n); this._targetEnd.copy(o), this._sphericalEnd.setFromVector3(l.sub(o).applyQuaternion(this._yAxisUpSpace)), this.normalizeRotations(), this._needsUpdate = !0, a || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd)); const c = !a || yv(this._target.x, this._targetEnd.x, this.restThreshold) && yv(this._target.y, this._targetEnd.y, this.restThreshold) && yv(this._target.z, this._targetEnd.z, this.restThreshold) && yv(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && yv(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && yv(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold); return this._createOnRestPromise(c) } lerpLookAt(e, t, n, i, r, s, a, o, l, c, u, h, d, p = !1) { const f = Fv.set(i, r, s), m = zv.set(e, t, n); Uv.setFromVector3(m.sub(f).applyQuaternion(this._yAxisUpSpace)); const g = kv.set(c, u, h), v = zv.set(a, o, l); Vv.setFromVector3(v.sub(g).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(f.lerp(g, d)); const y = Vv.theta - Uv.theta, x = Vv.phi - Uv.phi, _ = Vv.radius - Uv.radius; this._sphericalEnd.set(Uv.radius + _ * d, Uv.phi + x * d, Uv.theta + y * d), this.normalizeRotations(), this._needsUpdate = !0, p || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd)); const w = !p || yv(this._target.x, this._targetEnd.x, this.restThreshold) && yv(this._target.y, this._targetEnd.y, this.restThreshold) && yv(this._target.z, this._targetEnd.z, this.restThreshold) && yv(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && yv(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && yv(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold); return this._createOnRestPromise(w) } setPosition(e, t, n, i = !1) { return this.setLookAt(e, t, n, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, i) } setTarget(e, t, n, i = !1) { const r = this.getPosition(Fv); return this.setLookAt(r.x, r.y, r.z, e, t, n, i) } setFocalOffset(e, t, n, i = !1) { this._focalOffsetEnd.set(e, t, n), this._needsUpdate = !0, i || this._focalOffset.copy(this._focalOffsetEnd); const r = !i || yv(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && yv(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && yv(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold); return this._createOnRestPromise(r) } setOrbitPoint(e, t, n) { Nv.setFromMatrixColumn(this._camera.matrixWorldInverse, 0), Bv.setFromMatrixColumn(this._camera.matrixWorldInverse, 1), Hv.setFromMatrixColumn(this._camera.matrixWorldInverse, 2); const i = Fv.set(e, t, n), r = i.distanceTo(this._camera.position), s = i.sub(this._camera.position); Nv.multiplyScalar(s.x), Bv.multiplyScalar(s.y), Hv.multiplyScalar(s.z), Fv.copy(Nv).add(Bv).add(Hv), Fv.z = Fv.z + r, this.dollyTo(r, !1), this.setFocalOffset(-Fv.x, Fv.y, -Fv.z, !1), this.moveTo(e, t, n, !1) } setBoundary(e) { if (!e) return this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0), this._boundary.max.set(1 / 0, 1 / 0, 1 / 0), void (this._needsUpdate = !0); this._boundary.copy(e), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._needsUpdate = !0 } setViewport(e, t, n, i) { null !== e ? (this._viewport = this._viewport || new Av.Vector4, "number" == typeof e ? this._viewport.set(e, t, n, i) : this._viewport.copy(e)) : this._viewport = null } getDistanceToFitBox(e, t, n) { if (Sv(this._camera, "getDistanceToFitBox")) return this._spherical.radius; const i = e / t, r = this._camera.getEffectiveFOV() * Av.MathUtils.DEG2RAD, s = this._camera.aspect; return .5 * (i < s ? t : e / s) / Math.tan(.5 * r) + .5 * n } getDistanceToFit(e, t, n) { return console.warn("camera-controls: getDistanceToFit() has been renamed to getDistanceToFitBox()"), this.getDistanceToFitBox(e, t, n) } getDistanceToFitSphere(e) { if (Sv(this._camera, "getDistanceToFitSphere")) return this._spherical.radius; const t = this._camera.getEffectiveFOV() * Av.MathUtils.DEG2RAD, n = 2 * Math.atan(Math.tan(.5 * t) * this._camera.aspect), i = 1 < this._camera.aspect ? t : n; return e / Math.sin(.5 * i) } getTarget(e) { return (e && e.isVector3 ? e : new Av.Vector3).copy(this._targetEnd) } getPosition(e) { return (e && e.isVector3 ? e : new Av.Vector3).setFromSpherical(this._sphericalEnd).applyQuaternion(this._yAxisUpSpaceInverse).add(this._targetEnd) } getFocalOffset(e) { return (e && e.isVector3 ? e : new Av.Vector3).copy(this._focalOffsetEnd) } normalizeRotations() { this._sphericalEnd.theta = this._sphericalEnd.theta % mv, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += mv), this._spherical.theta += mv * Math.round((this._sphericalEnd.theta - this._spherical.theta) / mv) } reset(e = !1) { const t = [this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, e), this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, e), this.zoomTo(this._zoom0, e)]; return Promise.all(t) } saveState() { this._target0.copy(this._target), this._position0.copy(this._camera.position), this._zoom0 = this._zoom } updateCameraUp() { this._yAxisUpSpace.setFromUnitVectors(this._camera.up, Rv), Ev(this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace)) } update(e) { const t = this._state === dv.NONE ? this.dampingFactor : this.draggingDampingFactor, n = Math.min(t * e * 60, 1), i = this._sphericalEnd.theta - this._spherical.theta, r = this._sphericalEnd.phi - this._spherical.phi, s = this._sphericalEnd.radius - this._spherical.radius, a = Fv.subVectors(this._targetEnd, this._target), o = zv.subVectors(this._focalOffsetEnd, this._focalOffset); if (vv(i) && vv(r) && vv(s) && vv(a.x) && vv(a.y) && vv(a.z) && vv(o.x) && vv(o.y) && vv(o.z) ? (this._spherical.copy(this._sphericalEnd), this._target.copy(this._targetEnd), this._focalOffset.copy(this._focalOffsetEnd)) : (this._spherical.set(this._spherical.radius + s * n, this._spherical.phi + r * n, this._spherical.theta + i * n), this._target.add(a.multiplyScalar(n)), this._focalOffset.add(o.multiplyScalar(n)), this._needsUpdate = !0), 0 !== this._dollyControlAmount) { if (pv(this._camera)) { const e = this._camera, t = Fv.setFromSpherical(this._sphericalEnd).applyQuaternion(this._yAxisUpSpaceInverse).normalize().negate(), n = zv.copy(t).cross(e.up).normalize(); 0 === n.lengthSq() && (n.x = 1); const i = kv.crossVectors(n, t), r = this._sphericalEnd.radius * Math.tan(e.getEffectiveFOV() * Av.MathUtils.DEG2RAD * .5), s = (this._sphericalEnd.radius - this._dollyControlAmount - this._sphericalEnd.radius) / this._sphericalEnd.radius, a = Fv.copy(this._targetEnd).add(n.multiplyScalar(this._dollyControlCoord.x * r * e.aspect)).add(i.multiplyScalar(this._dollyControlCoord.y * r)); this._targetEnd.lerp(a, s), this._target.copy(this._targetEnd) } else if (fv(this._camera)) { const e = this._camera, t = Fv.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (e.near + e.far) / (e.near - e.far)).unproject(e), n = zv.set(0, 0, -1).applyQuaternion(e.quaternion), i = n.dot(e.up), r = vv(i) ? -t.dot(e.up) : -t.dot(e.up) / i, s = kv.copy(t).add(n.multiplyScalar(r)); this._targetEnd.lerp(s, 1 - e.zoom / this._dollyControlAmount), this._target.copy(this._targetEnd) } this._dollyControlAmount = 0 } const l = this._collisionTest(); this._spherical.radius = Math.min(this._spherical.radius, l), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), (!vv(this._focalOffset.x) || !vv(this._focalOffset.y) || !vv(this._focalOffset.z)) && (this._camera.updateMatrix(), Nv.setFromMatrixColumn(this._camera.matrix, 0), Bv.setFromMatrixColumn(this._camera.matrix, 1), Hv.setFromMatrixColumn(this._camera.matrix, 2), Nv.multiplyScalar(this._focalOffset.x), Bv.multiplyScalar(-this._focalOffset.y), Hv.multiplyScalar(this._focalOffset.z), Fv.copy(Nv).add(Bv).add(Hv), this._camera.position.add(Fv)), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), Fv.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1); const c = this._zoomEnd - this._zoom; this._zoom += c * n, this._camera.zoom !== this._zoom && (vv(c) && (this._zoom = this._zoomEnd), this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0); const u = this._needsUpdate; return u && !this._updatedLastTime ? (this._hasRested = !1, this.dispatchEvent({ type: "wake" }), this.dispatchEvent({ type: "update" })) : u ? (this.dispatchEvent({ type: "update" }), vv(i, this.restThreshold) && vv(r, this.restThreshold) && vv(s, this.restThreshold) && vv(a.x, this.restThreshold) && vv(a.y, this.restThreshold) && vv(a.z, this.restThreshold) && vv(o.x, this.restThreshold) && vv(o.y, this.restThreshold) && vv(o.z, this.restThreshold) && !this._hasRested && (this._hasRested = !0, this.dispatchEvent({ type: "rest" }))) : !u && this._updatedLastTime && this.dispatchEvent({ type: "sleep" }), this._updatedLastTime = u, this._needsUpdate = !1, u } toJSON() { return JSON.stringify({ enabled: this._enabled, minDistance: this.minDistance, maxDistance: _v(this.maxDistance), minZoom: this.minZoom, maxZoom: _v(this.maxZoom), minPolarAngle: this.minPolarAngle, maxPolarAngle: _v(this.maxPolarAngle), minAzimuthAngle: _v(this.minAzimuthAngle), maxAzimuthAngle: _v(this.maxAzimuthAngle), dampingFactor: this.dampingFactor, draggingDampingFactor: this.draggingDampingFactor, dollySpeed: this.dollySpeed, truckSpeed: this.truckSpeed, dollyToCursor: this.dollyToCursor, verticalDragToForward: this.verticalDragToForward, target: this._targetEnd.toArray(), position: Fv.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(), zoom: this._zoomEnd, focalOffset: this._focalOffsetEnd.toArray(), target0: this._target0.toArray(), position0: this._position0.toArray(), zoom0: this._zoom0, focalOffset0: this._focalOffset0.toArray() }) } fromJSON(e, t = !1) { const n = JSON.parse(e), i = Fv.fromArray(n.position); this.enabled = n.enabled, this.minDistance = n.minDistance, this.maxDistance = wv(n.maxDistance), this.minZoom = n.minZoom, this.maxZoom = wv(n.maxZoom), this.minPolarAngle = n.minPolarAngle, this.maxPolarAngle = wv(n.maxPolarAngle), this.minAzimuthAngle = wv(n.minAzimuthAngle), this.maxAzimuthAngle = wv(n.maxAzimuthAngle), this.dampingFactor = n.dampingFactor, this.draggingDampingFactor = n.draggingDampingFactor, this.dollySpeed = n.dollySpeed, this.truckSpeed = n.truckSpeed, this.dollyToCursor = n.dollyToCursor, this.verticalDragToForward = n.verticalDragToForward, this._target0.fromArray(n.target0), this._position0.fromArray(n.position0), this._zoom0 = n.zoom0, this._focalOffset0.fromArray(n.focalOffset0), this.moveTo(n.target[0], n.target[1], n.target[2], t), Uv.setFromVector3(i.sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(Uv.theta, Uv.phi, t), this.zoomTo(n.zoom, t), this.setFocalOffset(n.focalOffset[0], n.focalOffset[1], n.focalOffset[2], t), this._needsUpdate = !0 } dispose() { this._removeAllEventListeners() } _findPointerById(e) { let t = null; return this._activePointers.some((n => n.pointerId === e && (t = n, !0))), t } _encloseToBoundary(e, t, n) { const i = t.lengthSq(); if (0 === i) return e; const r = zv.copy(t).add(e), s = this._boundary.clampPoint(r, kv).sub(r), a = s.lengthSq(); if (0 === a) return e.add(t); if (a === i) return e; if (0 === n) return e.add(t).add(s); { const i = 1 + n * a / t.dot(s); return e.add(zv.copy(t).multiplyScalar(i)).add(s.multiplyScalar(1 - n)) } } _updateNearPlaneCorners() { if (pv(this._camera)) { const e = this._camera, t = e.near, n = e.getEffectiveFOV() * Av.MathUtils.DEG2RAD, i = Math.tan(.5 * n) * t, r = i * e.aspect; this._nearPlaneCorners[0].set(-r, -i, 0), this._nearPlaneCorners[1].set(r, -i, 0), this._nearPlaneCorners[2].set(r, i, 0), this._nearPlaneCorners[3].set(-r, i, 0) } else if (fv(this._camera)) { const e = this._camera, t = 1 / e.zoom, n = e.left * t, i = e.right * t, r = e.top * t, s = e.bottom * t; this._nearPlaneCorners[0].set(n, r, 0), this._nearPlaneCorners[1].set(i, r, 0), this._nearPlaneCorners[2].set(i, s, 0), this._nearPlaneCorners[3].set(n, s, 0) } } _collisionTest() { let e = 1 / 0; if (!(this.colliderMeshes.length >= 1)) return e; if (Sv(this._camera, "_collisionTest")) return e; const t = Fv.setFromSpherical(this._spherical).divideScalar(this._spherical.radius); Xv.lookAt(Pv, t, this._camera.up); for (let n = 0; n < 4; n++) { const i = zv.copy(this._nearPlaneCorners[n]); i.applyMatrix4(Xv); const r = kv.addVectors(this._target, i); Yv.set(r, t), Yv.far = this._spherical.radius + 1; const s = Yv.intersectObjects(this.colliderMeshes); 0 !== s.length && s[0].distance < e && (e = s[0].distance) } return e } _getClientRect(e) { const t = this._domElement.getBoundingClientRect(); return e.x = t.left, e.y = t.top, this._viewport ? (e.x += this._viewport.x, e.y += t.height - this._viewport.w - this._viewport.y, e.width = this._viewport.z, e.height = this._viewport.w) : (e.width = t.width, e.height = t.height), e } _createOnRestPromise(e) { return e ? Promise.resolve() : (this._hasRested = !1, this.dispatchEvent({ type: "transitionstart" }), new Promise((e => { const t = () => { this.removeEventListener("rest", t), e() }; this.addEventListener("rest", t) }))) } _removeAllEventListeners() { } } Ci.registerPlugin(Va); const Kv = { MOUSE: { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, Vector2: ul, Vector3: Rl, Vector4: Cl, Quaternion: Pl, Matrix4: cc, Spherical: class { constructor(e = 1, t = 0, n = 0) { return this.radius = e, this.phi = t, this.theta = n, this } set(e, t, n) { return this.radius = e, this.phi = t, this.theta = n, this } copy(e) { return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this } makeSafe() { const e = 1e-6; return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)), this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, t, n) { return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(il(t / this.radius, -1, 1))), this } clone() { return (new this.constructor).copy(this) } }, Box3: Fl, Sphere: ec, Raycaster: Hg, MathUtils: { DEG2RAD: cl.DEG2RAD, clamp: cl.clamp } }; Zv.install({ THREE: Kv }); class Jv { constructor(e, t, n, i, r, s, a, o) { this.mouseMoveTarget = e => { const t = e.currentTarget, n = e.clientX - t.offsetLeft, i = e.clientY - t.offsetTop, r = t.offsetWidth, s = t.offsetHeight; this.mouse.x = n / r * 2 - 1, this.mouse.y = -i / s * 2 + 1, null !== this.startPoint && Math.sqrt(Math.pow(n - this.startPoint.x, 2) + Math.pow(i - this.startPoint.y, 2)) > 10 && (this.clickFlg = !1), this.raycaster.setFromCamera(this.mouse, this.camera), this.rayTarget = this.raycaster.intersectObjects(this.scene.children), this.grabFlg || this.pointFlg || (document.body.parentElement.style.cursor = "grab") }, this.mouseOutTarget = () => { this.rayTarget = [], this.grabFlg = !1, this.clickFlg = !1, this.startPoint = null, document.body.parentElement.style.cursor = "grab" }, this.mouseUpTarget = () => { this.grabFlg = !1, document.body.parentElement.style.cursor = "grab" }, this.mouseDownTarget = e => { const t = e.currentTarget; this.grabFlg = !0, this.clickFlg = !0, this.startPoint = { x: e.clientX - t.offsetLeft, y: e.clientY - t.offsetTop }, document.body.parentElement.style.cursor = "grabbing" }, this.renderer = e, this.scene = t, this.camera = n, this.isPC = s, this.base_gltf = i.scene.children.slice(0, i.scene.children.length / 2), this.spread_gltf = i.scene.children.slice(126, 252), this.dataArray = r, this.instanceNum = this.dataArray.length, this.eventTargetDom = a, this.clickCallback = o, this.panelPosition = [], this.spreadPosition = [], this.instanceNum > 126 && (this.instanceNum = 126); let l = new vp, c = new vp; for (let e = 0; e < this.instanceNum; e++) { const t = this.base_gltf[e], n = (Math.random() + Math.random() + Math.random()) / 3; try { this.panelPosition.push({ x: t.position.x, y: t.position.y, opacity: 0, position: 0, moveRate: .022 * this.clamp(n, .3, 1), multiRate: this.clamp(1 - n, .3, 1), mesh: null, smallTexture: this.dataArray[e].smallTexture, largeImgUrl: this.dataArray[e].largeTexturePath, url: this.dataArray[e].url, title: this.dataArray[e].title, largeFlg: !1 }), l.add(t) } catch (e) { console.log(t) } } this.dataArray = void 0; for (let e = 0; e < this.instanceNum; e++) { const t = this.spread_gltf[e]; this.spreadPosition.push({ x: t.position.x, y: t.position.y }), c.add(t) } let u = (new Fl).setFromObject(l); this.sceneWidth = u.max.x - u.min.x, this.sceneHeight = u.max.y - u.min.y, u = (new Fl).setFromObject(c), this.spreadWidth = u.max.x - u.min.x, this.spreadHeight = u.max.y - u.min.y, u.makeEmpty(), u = void 0; for (let e = this.instanceNum - 1; 0 < e; e--) { const t = Math.floor(Math.random() * e);[this.spreadPosition[t], this.spreadPosition[e - 1]] = [this.spreadPosition[e - 1], this.spreadPosition[t]]; const n = Math.floor(Math.random() * e);[this.panelPosition[n], this.panelPosition[e - 1]] = [this.panelPosition[e - 1], this.panelPosition[n]]; let i = this.base_gltf[e]; l.remove(i), i.material.dispose(), i.geometry.dispose(), i = void 0; let r = this.spread_gltf[e]; l.remove(r), r.material.dispose(), r.geometry.dispose(), r = void 0 } l = void 0, c = void 0 } init(e, t, n = null) { this.rootWidth = e, this.rootHeight = t, this.clickFlg = !1, this.startPoint = null, this.widthRate = .8, this.defaultOpacity = .6, this.parentGroup = new vp, this.rayTarget = [], this.opacityObj = { opacity: 1 }, this.raycaster = new Hg, this.mouse = new ul(0, 0), this.eventTargetDom.addEventListener("mousemove", this.mouseMoveTarget), this.Frustum = (new Wu).setFromProjectionMatrix((new cc).multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse)), this.scaleWidth_first = Math.ceil(this.rootWidth * this.widthRate * 2.5 / this.sceneWidth * 100) / 100, this.scaleWidth_second = Math.ceil(this.rootWidth * this.widthRate / this.sceneWidth * 100) / 100, this.scaleWidth_finish = Math.ceil(100 * this.clamp(this.rootWidth * this.widthRate * 5.7 / this.sceneWidth, 8, 20)) / 100, this.geoWidth = this.base_gltf[0].geometry.boundingBox.max.x - this.base_gltf[0].geometry.boundingBox.min.x, this.geoHeight = this.base_gltf[0].geometry.boundingBox.max.y - this.base_gltf[0].geometry.boundingBox.min.y; const i = new Xu(this.geoWidth, this.geoHeight); for (let e = 0; e < this.instanceNum; e++) { const t = this.panelPosition[e].smallTexture.source.data.width, r = this.panelPosition[e].smallTexture.source.data.height, s = this.getClipValue(t, r), a = new Tm({ vertexShader: lv, fragmentShader: "precision mediump float;\n#define GLSLIFY 1\nuniform sampler2D thumbnailTex;\nuniform sampler2D mainTex;\n// alpha / effect / globalAlpha / isLarge\nuniform vec4 panelValue_01;\nuniform vec2 panelValue_02;\nuniform vec4 thumbValue;\nuniform vec4 mainValue;\nvarying vec2 vUv;\n\nvec2 getUV(vec4 targetParam){\n\treturn vec2(targetParam.x + (targetParam.z * vUv.x), targetParam.y + (targetParam.w * vUv.y));\n}\n\nvoid main(){\n    vec2 thumbUV = getUV(thumbValue);\n    vec3 thumbColor = texture2D( thumbnailTex, thumbUV).rgb;\n    vec2 mainUV = getUV(mainValue);\n    vec3 mainColor = texture2D( mainTex, mainUV).rgb;\n\n    vec3 distColor = (thumbColor * (1.0 - panelValue_02.y)) + (mainColor * panelValue_02.y);\n\n    gl_FragColor = vec4(distColor, panelValue_01.x * panelValue_01.z);\n}", transparent: !0, alphaTest: .5, uniforms: { thumbnailTex: { value: this.panelPosition[e].smallTexture }, mainTex: { value: null }, panelValue_01: { value: new Cl(null === n ? 0 : this.defaultOpacity, 0, 1, 0) }, panelValue_02: { value: new ul(0, 0) }, thumbValue: { value: new Cl(s[0], s[1], s[2], s[3]) }, mainValue: { value: new Cl(e, 0, 0, 0) } } }); a.uniformsNeedUpdate = !0; const o = new Tu(i, a); "resize" === n ? o.position.set(this.panelPosition[e].x, this.panelPosition[e].y, 0) : o.position.set(this.spreadPosition[e].x, this.spreadPosition[e].y, 0), this.parentGroup.add(o), this.panelPosition[e].mesh = o } "mouse" === n ? (this.parentGroup.scale.set(this.scaleWidth_finish, this.scaleWidth_finish, 1), this.addMouseEvents()) : "touch" === n ? (this.parentGroup.scale.set(this.scaleWidth_finish, this.scaleWidth_finish, 1), this.addTouchEvents()) : "resize" === n ? this.parentGroup.scale.set(this.scaleWidth_second, this.scaleWidth_second, 1) : this.parentGroup.scale.set(this.scaleWidth_first, this.scaleWidth_first, 1), this.scene.add(this.parentGroup) } getClipValue(e, t) { let n, i, r, s, a; return this.geoWidth / this.geoHeight >= e / t ? (a = this.geoWidth / e, n = 0, i = (t * a - this.geoHeight) / a / 2 / t, r = 1, s = this.geoHeight / a / t) : (a = this.geoHeight / t, n = (e * a - this.geoWidth) / a / 2 / e, i = 0, r = this.geoWidth / a / e, s = 1), [n, i, r, s] } transitionIn(e, t, n, i, r, s, a, o, l, c) { this.positionFlg = !0, Ci.to(this.panelPosition, { duration: e, opacity: this.defaultOpacity, ease: n, stagger: { each: t } }), Ci.to(this.panelPosition, { duration: i, position: 1, ease: l, delay: a, stagger: { each: r } }), Ci.to(this.parentGroup.scale, { duration: i + r * this.instanceNum + (s - a), x: this.scaleWidth_second, y: this.scaleWidth_second, ease: o, delay: s, onComplete: () => { c() } }) } zooomIn(e, t, n, i) { this.spreadFlg = !0, document.body.parentElement.style.cursor = "auto", Ci.to(this.panelPosition, { duration: e, position: 0, ease: t, stagger: { each: .0025 } }), Ci.to(this.parentGroup.scale, { duration: n, x: this.scaleWidth_finish, y: this.scaleWidth_finish, ease: Va.create("custom", "M0,0 C0,0 0.136,-0.039 0.21,-0.049 0.228,-0.052 0.245,-0.046 0.262,-0.038 0.28,-0.03 0.295,-0.02 0.31,-0.005 0.332,0.019 0.347,0.041 0.365,0.072 0.387,0.113 0.398,0.141 0.415,0.186 0.437,0.248 0.447,0.285 0.465,0.35 0.506,0.508 0.522,0.599 0.565,0.754 0.578,0.802 0.598,0.896 0.694,0.948 0.805,1.008 1,1 1,1 "), onComplete: () => { i() } }) } fadeIn(e, t, n) { this.fadeFlg = !1, Ci.to(this.opacityObj, { opacity: 1, duration: e, ease: t, overwrite: !0, onUpdate: () => { for (let e = 0; e < this.instanceNum; e++)this.panelPosition[e].mesh.material.uniforms.panelValue_01.value.z = this.opacityObj.opacity }, onComplete: () => { n() } }) } fadeOut(e, t, n) { this.fadeFlg = !0, Ci.to(this.opacityObj, { opacity: 0, duration: e, ease: t, overwrite: !0, onUpdate: () => { for (let e = 0; e < this.instanceNum; e++)this.panelPosition[e].mesh.material.uniforms.panelValue_01.value.z = this.opacityObj.opacity }, onComplete: () => { n() } }) } fadeOutDestroy(e, t, n) { Ci.killTweensOf(this.opacityObj), Ci.to(this.opacityObj, { opacity: 0, duration: e, ease: t, overwrite: !0, onUpdate: () => { for (let e = 0; e < this.instanceNum; e++)this.panelPosition[e].mesh.material.uniforms.panelValue_01.value.z = this.opacityObj.opacity }, onComplete: () => { Ci.killTweensOf(this.panelPosition), Ci.killTweensOf(this.parentGroup.scale), this.removeAll(), n() } }) } addMouseEvents() { this.mouseFlg = !0, this.eventTargetDom.addEventListener("mouseout", this.mouseOutTarget), this.eventTargetDom.addEventListener("mouseup", this.mouseUpTarget), this.eventTargetDom.addEventListener("mousedown", this.mouseDownTarget), this.eventTargetDom.addEventListener("click", { callback: this.clickCallback, parent: this, handleEvent: this.mouseClickTarget }), this.cameraControls = new Zv(this.camera, this.eventTargetDom), this.cameraControls.mouseButtons.left = Zv.ACTION.TRUCK, this.cameraControls.mouseButtons.right = Zv.ACTION.TRUCK, this.cameraControls.mouseButtons.wheel = Zv.ACTION.NONE, this.cameraControls.dampingFactor = .1, this.cameraControls.draggingDampingFactor = .1; const e = new Fl(new Rl(-this.spreadWidth * this.scaleWidth_finish / 2 + .3 * this.rootWidth, -this.spreadHeight * this.scaleWidth_finish / 2 + .3 * this.rootHeight, -5), new Rl(this.spreadWidth * this.scaleWidth_finish / 2 - .3 * this.rootWidth, this.spreadHeight * this.scaleWidth_finish / 2 - .3 * this.rootHeight, 5)); this.cameraControls.setBoundary(e) } mouseClickTarget() { if (0 !== this.parent.rayTarget.length) { for (let e = 0; e < this.parent.instanceNum; e++)this.parent.clickFlg && this.parent.rayTarget[0].object === this.parent.panelPosition[e].mesh && this.callback(this.parent.panelPosition[e].url); this.parent.clickFlg = !1, this.parent.startPoint = null } } addTouchEvents() { this.touchFlg = !0, this.raycaster = new Hg, this.eventTargetDom.addEventListener("click", { callback: this.clickCallback, parent: this, handleEvent: this.fingerTouchTarget }), this.cameraControls = new Zv(this.camera, this.eventTargetDom), this.cameraControls.touches.one = Zv.ACTION.TRUCK, this.cameraControls.dampingFactor = .1, this.cameraControls.draggingDampingFactor = .1; const e = new Fl(new Rl(-this.spreadWidth * this.scaleWidth_finish / 2 + .3 * this.rootWidth, -this.spreadHeight * this.scaleWidth_finish / 2 + .3 * this.rootHeight, -5), new Rl(this.spreadWidth * this.scaleWidth_finish / 2 - .3 * this.rootWidth, this.spreadHeight * this.scaleWidth_finish / 2 - .3 * this.rootHeight, 5)); this.cameraControls.setBoundary(e) } fingerTouchTarget(e) { const t = e.currentTarget, n = e.clientX - t.offsetLeft, i = e.clientY - t.offsetTop, r = t.offsetWidth, s = t.offsetHeight, a = new ul(n / r * 2 - 1, -i / s * 2 + 1); if (this.parent.raycaster.setFromCamera(a, this.parent.camera), this.parent.rayTarget = this.parent.raycaster.intersectObjects(this.parent.scene.children), 0 !== this.parent.rayTarget.length) for (let e = 0; e < this.parent.instanceNum; e++)this.parent.rayTarget[0].object === this.parent.panelPosition[e].mesh && this.callback(this.parent.panelPosition[e].url) } destroy() { this.gui && (this.gui.destroy(), this.gui = void 0), this.rootWidth = void 0, this.rootHeight = void 0, this.widthRate = void 0, this.defaultOpacity = void 0, this.rayTarget = void 0, this.scaleWidth_first = void 0, this.scaleWidth_second = void 0, this.scaleWidth_finish = void 0, this.positionFlg = void 0, this.spreadFlg = void 0, this.positionFlg = void 0, this.raycaster = void 0, this.opacityObj = void 0, this.clickFlg = void 0, this.startPoint = void 0, this.fadeFlg = void 0, this.introFinishFlg = void 0, this.eventTargetDom.removeEventListener("mousemove", this.mouseMoveTarget), this.mouseFlg && (this.mouse = void 0, this.eventTargetDom.removeEventListener("mouseout", this.mouseOutTarget), this.eventTargetDom.removeEventListener("mouseup", this.mouseUpTarget), this.eventTargetDom.removeEventListener("mousedown", this.mouseDownTarget), this.eventTargetDom.removeEventListener("click", this.mouseClickTarget)), this.touchFlg && this.eventTargetDom.removeEventListener("click", this.touchTarget); for (let e = 0; e < this.instanceNum; e++) { const t = this.panelPosition[e]; this.parentGroup.remove(t.mesh), t.mesh.material.dispose(), t.mesh.geometry.dispose(), t.mesh = void 0 } this.scene.remove(this.parentGroup), this.parentGroup = void 0, this.cameraControls && (this.camera.position.set(0, 0, 0), this.camera.rotation.set(0, 0, 0), this.cameraControls.dispose(), this.cameraControls = void 0) } removeAll() { this.destroy(), this.renderer = void 0, this.scene = void 0, this.camera = void 0, this.isPC = void 0, this.base_gltf = void 0, this.spread_gltf = void 0, this.instanceNum = void 0, this.eventTargetDom = void 0, this.clickCallback = void 0; for (let e = 0; e < this.instanceNum; e++)this.panelPosition[e].smallTexture.dispose(), this.dataArray[e].smallTexture.dispose(); this.dataArray = void 0, this.panelPosition = void 0, this.spreadPosition = void 0, this.sceneWidth = void 0, this.sceneHeight = void 0, this.spreadWidth = void 0, this.spreadHeight = void 0, this.mouseFlg = void 0, this.touchFlg = void 0 } update(e) { if (this.positionFlg) { for (let e = 0; e < this.instanceNum; e++) { const t = this.panelPosition[e]; t.mesh.material.uniforms.panelValue_01.value.x = t.opacity, t.mesh.position.set(this.spreadPosition[e].x + (this.panelPosition[e].x - this.spreadPosition[e].x) * t.position, this.spreadPosition[e].y + (this.panelPosition[e].y - this.spreadPosition[e].y) * t.position, 0) } this.panelPosition[this.instanceNum - 1].mesh.material.uniforms.panelValue_01.value.x === this.defaultOpacity && (this.positionFlg = !1) } if (this.spreadFlg) { for (let e = 0; e < this.instanceNum; e++) { const t = this.panelPosition[e]; t.mesh.position.set(this.spreadPosition[e].x + (this.panelPosition[e].x - this.spreadPosition[e].x) * t.position, this.spreadPosition[e].y + (this.panelPosition[e].y - this.spreadPosition[e].y) * t.position, 0) } this.parentGroup.scale.x === this.scaleWidth_finish && (this.spreadFlg = !1, this.isPC ? this.addMouseEvents() : this.addTouchEvents()) } if (this.mouseFlg) { for (let e = 0; e < this.instanceNum; e++) { const t = this.panelPosition[e].mesh, n = this.spreadPosition[e].x - this.mouse.x * this.panelPosition[e].moveRate * this.rootWidth, i = this.spreadPosition[e].y - this.mouse.y * this.panelPosition[e].moveRate * this.rootHeight; if (t.position.set(t.position.x + (n - t.position.x) * this.panelPosition[e].moveRate, t.position.y + (i - t.position.y) * this.panelPosition[e].moveRate), this.grabFlg && !this.pointFlg) { const e = Math.max(t.scale.x - .01, .9); t.scale.set(e, e) } else { const e = Math.min(t.scale.x + .01, 1); t.scale.set(e, e) } this.rayTarget.length > 0 && this.rayTarget[0].object === t ? (t.material.uniforms.panelValue_01.value.x = Math.min(t.material.uniforms.panelValue_01.value.x + .02, 1), t.position.z = -.01) : (t.material.uniforms.panelValue_01.value.x = Math.max(t.material.uniforms.panelValue_01.value.x - .02, this.defaultOpacity), t.position.z = 0) } this.rayTarget.length > 0 ? (this.pointFlg = !0, document.body.parentElement.style.cursor = "pointer") : this.pointFlg = !1 } else if (this.introFinishFlg) for (let e = 0; e < this.instanceNum; e++) { const t = this.panelPosition[e].mesh; this.rayTarget.length > 0 && this.rayTarget[0].object === t ? (t.material.uniforms.panelValue_01.value.x = Math.min(t.material.uniforms.panelValue_01.value.x + .02, 1), t.position.z = -.5) : (t.material.uniforms.panelValue_01.value.x = Math.max(t.material.uniforms.panelValue_01.value.x - .02, this.defaultOpacity), t.position.z = 0) } if (this.cameraControls && !this.fadeFlg) { this.cameraControls.update(e), this.camera.updateProjectionMatrix(); const t = new cc; t.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse), this.Frustum.setFromProjectionMatrix(t), this.scene.traverse((e => { this.visibleCheck(e) })) } } visibleCheck(e) { e.isMesh && this.Frustum.intersectsObject(e) && 1 !== e.material.uniforms.panelValue_01.value.w && (e.material.uniforms.panelValue_01.value.w = 1, (new rg).load(this.panelPosition[e.material.uniforms.mainValue.value.x].largeImgUrl, (t => { const n = t.source.data.width, i = t.source.data.height, r = this.getClipValue(n, i); e.material.uniforms.mainTex.value = t, e.material.uniforms.panelValue_02.value.x = 1, e.material.uniforms.mainValue.value.set(r[0], r[1], r[2], r[3]), Ci.to(e.material.uniforms.panelValue_02.value, { y: 1, duration: .6, ease: "power3.easeOut" }) }))) } resize(e, t) { (this.spreadFlg || this.mouseFlg || this.introFinishFlg) && this.isPC ? (this.destroy(), this.init(e, t, "mouse")) : !this.spreadFlg && !this.touchFlg || this.isPC ? (this.destroy(), this.init(e, t, "resize")) : (this.touchFlg = !1, this.destroy(), this.init(e, t, "touch")) } clamp(e, t, n) { return Math.min(Math.max(e, t), n) } } class Qv { constructor() { this.debounce = (e, t = 0) => { let n; return (...i) => { clearTimeout(n), n = setTimeout((() => { e.apply(this, i) }), t) } }, this.resize = () => { const e = .01 * window.innerHeight, t = this.rootWidth === this.rootElement.clientWidth && window.LIG.isIOS; this.rootElement.style.setProperty("--initVh", `${e}px`), this.rootWidth = this.rootElement.clientWidth, this.rootHeight = this.rootElement.clientHeight, this.renderer.setSize(this.rootWidth, this.rootHeight), this.flatCamera.top = this.rootHeight / 2, this.flatCamera.bottom = -this.rootHeight / 2, this.flatCamera.left = -this.rootWidth / 2, this.flatCamera.right = this.rootWidth / 2, this.flatCamera.updateProjectionMatrix(), this.topMovieComponent && !t && this.topMovieComponent.resize(this.rootWidth, this.rootHeight), this.menuComponent.isRendering && this.menuComponent.resize(this.rootWidth, this.rootHeight), this.solutionComponent && !t && this.solutionComponent.resize(this.rootWidth, this.rootHeight), this.noiseHandle && this.noiseHandle.resize(this.rootWidth, this.rootHeight), this.notFoundComponent && this.notFoundComponent.resize(this.rootWidth, this.rootHeight); const n = this.clock.getDelta(), i = 1e3 * this.clock.getElapsedTime(); this.render(i, n) } } init(e, t) { this.rootElement = e, this.clock = new Mg, this.FPS = 60, this.rootWidth = this.rootElement.clientWidth, this.rootHeight = this.rootElement.clientHeight, this.flatScene = new Tp, this.flatCamera = new rh(-this.rootWidth / 2, this.rootWidth / 2, this.rootHeight / 2, -this.rootHeight / 2, 0, 1); const n = .01 * window.innerHeight; this.rootElement.style.setProperty("--initVh", `${n}px`), this.renderer = new Sp, this.renderer.setClearColor(t), this.renderer.setSize(this.rootWidth, this.rootHeight), this.renderer.clearColor(), this.rootElement.appendChild(this.renderer.domElement), this.composer = new rv(this.renderer), this.flatRenderPass = new av(this.flatScene, this.flatCamera), this.composer.addPass(this.flatRenderPass), window.LIG.isTouch ? this.menuComponent = { isRendering: !1 } : this.menuComponent = new hv(this.renderer, this.flatScene, this.flatCamera), window.addEventListener("resize", this.resize) } addNoiseBG() { this.noiseComponent = new ov(this.renderer, this.composer), this.noiseComponent.init(this.rootWidth, this.rootHeight) } addNoiseToBlack(e, t) { this.start(), this.noiseComponent = new ov(this.renderer, this.composer), this.noiseComponent.init(this.rootWidth, this.rootHeight), this.noiseComponent.colorAnimationIn(e, t) } removeNoiseToWhite(e, t, n = null) { this.noiseComponent && this.noiseComponent.colorAnimationOut(e, t, (() => { this.noiseComponent = void 0, null !== n && (this.stop(), n()) })) } addTopMovie(e) { this.topMovieComponent = new cv(this.flatScene), this.topMovieComponent.init(this.rootWidth, this.rootHeight, e) } introTopMovie(e, t, n, i, r, s = null) { this.topMovieComponent && this.topMovieComponent.maskAnimation(e, t, n, i, r, (() => { null !== s && s() })) } introLowerMovie(e, t, n = null) { this.topMovieComponent && this.topMovieComponent.fadeAnimation(e, t, (() => { null !== n && n() })) } hideTopMovie(e, t, n = null) { this.topMovieComponent && this.topMovieComponent.fadeOut(e, t, (() => { null !== n && n() })) } showTopMovie(e, t, n, i = null) { this.topMovieComponent && this.topMovieComponent.fadeIn(e, t, n, (() => { null !== i && i() })) } scrollTopMovie(e) { this.topMovieComponent && this.topMovieComponent.scrollChange(e) } removeTopMovie(e, t, n = null) { this.topMovieComponent && this.topMovieComponent.fadeOutDestroy(e, t, (() => { this.topMovieComponent = void 0, null !== n && n() })) } addLiquidSolution() { this.clock = new Mg, this.solutionComponent = new uv(this.renderer, this.flatScene, this.flatCamera), this.solutionComponent.init(this.rootWidth, this.rootHeight) } solutionTransitionIn(e, t, n = null) { this.solutionComponent && this.solutionComponent.transitionIn(e, t, (() => { null !== n && n() })) } solutionScroll(e) { this.solutionComponent && this.solutionComponent.scrollValue(e) } hideSolution(e, t, n = null) { this.solutionComponent && this.solutionComponent.fadeOut(e, t, (() => { null !== n && n() })) } showSolution(e, t, n = null) { this.solutionComponent && this.solutionComponent.fadeIn(e, t, 1e3 * this.clock.getElapsedTime(), (() => { null !== n && n() })) } removeSolution(e, t, n = null) { this.solutionComponent && this.solutionComponent.fadeOutDestroy(e, t, (() => { this.solutionComponent = void 0, null !== n && n() })) } addLiquidMenu() { this.menuComponent.init(this.rootWidth, this.rootHeight) } removeLiquidMenu(e, t, n = null) { this.menuComponent.fadeOutDestroy(e, t, (() => { null !== n && n() })) } add404component(e, t, n, i, r) { this.notFoundComponent = new Jv(this.renderer, this.flatScene, this.flatCamera, t, e, n, i, r), this.notFoundComponent.init(this.rootWidth, this.rootHeight) } intro404component(e, t, n, i, r, s, a, o, l, c = null) { this.notFoundComponent && this.notFoundComponent.transitionIn(e, t, n, i, r, s, a, o, l, (() => { null !== c && (c(), this.notFoundComponent.introFinishFlg = !0) })) } zoom404component(e, t, n, i = null) { this.notFoundComponent && this.notFoundComponent.zooomIn(e, t, n, (() => { null !== i && i() })) } set404MouseEvent(e, t) { this.notFoundComponent && this.notFoundComponent.addMouseEvents(e, t) } set404TouchEvent(e, t) { this.notFoundComponent && this.notFoundComponent.addTouchEvents(e, t) } hide404(e, t, n = null) { this.notFoundComponent && this.notFoundComponent.fadeOut(e, t, (() => { null !== n && n() })) } show404(e, t, n = null) { this.notFoundComponent && this.notFoundComponent.fadeIn(e, t, (() => { null !== n && n() })) } remove404(e, t, n = null) { this.notFoundComponent && this.notFoundComponent.fadeOutDestroy(e, t, (() => { null !== n && n() })) } update() { const e = this.clock.getDelta(), t = 1e3 * this.clock.getElapsedTime(); e <= this.frameTime || (e > 1 && this.clock.start(), this.render(t, e)) } start() { this.requestId = requestAnimationFrame((() => { this.start() })), this.update() } stop() { cancelAnimationFrame(this.requestId), this.requestId = void 0 } changeFPS(e) { this.FPS = e, this.frameTime = 1 / this.FPS } render(e, t) { this.menuComponent.isRendering && this.menuComponent.update(e), this.solutionComponent && this.solutionComponent.update(e), this.noiseComponent && this.noiseComponent.update(e), this.notFoundComponent && this.notFoundComponent.update(t), this.composer.render() } } function ey() { const e = document.querySelector("body"), t = document.querySelector(".js-header"), n = document.querySelector("#js-content-wrapper"); let i = !1; const r = document.querySelectorAll(".js-menu-main-item"), s = document.querySelectorAll(".js-menu-main-overflow-item"), a = document.querySelectorAll(".js-menu-sp-back"), o = document.getElementById("jsHeaderMenuButton"), l = document.getElementById("jsHeaderMenu"), c = document.querySelectorAll(".js-opacity-item"), u = document.querySelectorAll(".js-menu-main-link-item"); let h = document.querySelector("#js-menu-main-overview"), d = null, p = null, f = null, m = 0; const g = h.querySelectorAll("li"), v = function (e) { ThreeHandler.solutionComponent ? ThreeHandler.showSolution(.4, "circ.out", (() => { })) : ThreeHandler.topMovieComponent ? ThreeHandler.showTopMovie(e, .4, "circ.out", (() => { })) : ThreeHandler.notFoundComponent && ThreeHandler.show404(.4, "circ.out", (() => { })) }, y = function (r, s = !1) { i = !0, window.LIG.isTouch ? s || v(m) : window.ThreeHandler.removeLiquidMenu(.4, "circ.out", (() => { s || v(m) })), null !== p && p.pause(), null === f ? (s || (e.classList.remove("in-menu"), e.style.setProperty("--scrollBar", "0px"), t.style.setProperty("--scrollBar", "0px"), requestAnimationFrame((() => { fa.getAll().forEach((e => { e.enable() })), window.scrollTo(0, m) }))), f = Ci.timeline({ paused: !0, onComplete: () => { l.classList.add("hidden"), Ci.set(l, { clearProps: "all" }), Ci.set(l.querySelectorAll(".items-center"), { clearProps: "all" }), Ci.set(".js-menu-main-contents", { clearProps: "all" }), Ci.set(h, { clearProps: "all" }), Ci.set(".js-menu-iconline-02", { clearProps: "all" }), c.forEach((e => { e.classList.remove("js-addOpacity") })), l.querySelectorAll(".active").forEach((e => { e.classList.contains("active") && e.classList.remove("active") })), Ci.set(g, { clearProps: "all" }), f.kill(), f = null, i = !1, window.LIG.isAndroid && fa.normalizeScroll(!0) } }), f.to(l, { alpha: 0, duration: r, ease: "circ.out", onComplete: () => { window.LIG.isMenuOpen = !1, s && (e.classList.remove("in-menu"), e.style.setProperty("--scrollBar", "0px"), t.style.setProperty("--scrollBar", "0px"), s()) } }), s ? Ci.set(n, { clearProps: "all" }) : f.set(n, { clearProps: "pointerEvents,visibility", opacity: 0 }).to(n, { alpha: 1, duration: r, ease: "circ.out" })) : f.seek(0, !0).pause(), f.play(), t.classList.contains("bg-header-white") && !s && (window.LIG.isBgBlack = !1, window.ThreeHandler.removeNoiseToWhite(.8, "circ.out")) }; function x(e) { const t = e.dataset.type ? e.dataset.type : e.parentNode.dataset.type; d = "#js-menu-main-" + t; const n = document.querySelector(d); if (n.classList.remove("pointer-events-none"), window.LIG.mql.matches) { Ci.set(n, { alpha: 0, display: "block", x: "80vw" }); const e = n.querySelectorAll(".items-center"); Ci.set(e, { x: 200, opacity: 0, scaleX: 2.5, transformOrigin: "left center" }), Ci.to(e, { x: 0, opacity: 1, scaleX: 1, duration: .4, ease: "circ.out", stagger: .07, delay: .4 }), Ci.to(n, { x: 0, alpha: 1, duration: .4, delay: .4, ease: "circ.out" }) } else { window.scrollTo({ top: 0, behavior: "smooth" }), Ci.set(n, { alpha: 0, display: "block", x: "105%" }); const e = n.querySelectorAll(".items-center"); Ci.set(e, { x: 100, opacity: 0, scaleX: 2.5, transformOrigin: "left center" }), Ci.to(e, { x: 0, opacity: 1, scaleX: 1, duration: .4, ease: "circ.out", stagger: .07, delay: .4 }), Ci.to(n, { x: 0, alpha: 1, duration: .6, delay: .4, ease: "expo.out" }) } } function _(e) { Ci.set(".js-menu-iconline-02", { clearProps: "all" }), c.forEach((e => { e.classList.add("js-addOpacity") })), s.forEach((e => { e.classList.remove("active") })); const t = e.dataset.type ? e : e.parentNode; Ci.set(t.querySelector(".js-menu-iconline-02"), { scaleY: 0 }), t.parentNode.classList.remove("js-addOpacity"), t.classList.add("active") } return o.addEventListener("click", (() => { i || (e.classList.contains("in-menu") ? y(.4) : (window.LIG.isAndroid && fa.normalizeScroll(!1), i = !0, fa.getAll().forEach((e => { e.disable(!1) })), Ci.set(n, { pointerEvents: "none" }), ThreeHandler.solutionComponent ? ThreeHandler.hideSolution(.3, "circ.out", (() => { })) : ThreeHandler.topMovieComponent ? ThreeHandler.hideTopMovie(.3, "circ.out", (() => { })) : ThreeHandler.notFoundComponent && ThreeHandler.hide404(.3, "circ.out", (() => { })), null !== f && f.pause(), m = window.pageYOffset, t.style.setProperty("--scrollBar", window.innerWidth - document.body.clientWidth + "px"), e.style.setProperty("--scrollBar", window.innerWidth - document.body.clientWidth + "px"), e.classList.add("in-menu"), l.classList.remove("hidden"), Ci.set(".js-menu-main-overflow-item", { x: 200, opacity: 0, scaleX: 2, transformOrigin: "left center" }), p = Ci.timeline(), p.to(n, { alpha: 0, duration: .4, ease: "circ.out", onComplete: () => { Ci.set(n, { visibility: "hidden" }), window.LIG.isTouch || (window.ThreeHandler.addLiquidMenu(), window.LIG.isMenuOpen = !0), i = !1 } }).to(".js-menu-main-overflow-item", { x: 0, opacity: 1, scaleX: 1, duration: .4, ease: "circ.out", stagger: .07 }, "+=0.05"), p.play(), t.classList.contains("bg-header-white") && (window.LIG.isBgBlack = !0, window.ThreeHandler.addNoiseToBlack(.4, "circ.out")))) })), r.forEach((e => { e.addEventListener("click", (e => { e.preventDefault(); const t = e.target.parentNode; if (h.classList.contains("active")) { const n = d; Ci.to(n, { x: "80vw", alpha: 0, duration: .6, ease: "expo.inOut", onStart: function () { this.targets()[0].classList.add("pointer-events-none") }, onComplete: function () { Ci.set(n, { clearProps: "display" }) } }), t.classList.contains("active") ? (Ci.to(h, { scale: 1, y: 0, x: "19.7vw", duration: .6, delay: .1, ease: "power2.inOut", onComplete: () => { Ci.set(h, { position: "absolut" }) } }), g.forEach((e => { Ci.to(g, { marginTop: "6px", delay: .1, ease: "power2.inOut" }) })), t.classList.remove("active"), h.classList.remove("active"), Ci.set(".js-menu-iconline-02", { clearProps: "all" }), c.forEach((e => { e.classList.remove("js-addOpacity") }))) : (x(e.target), _(e.target)) } else { if (window.LIG.mql.matches) { let e = 1.6; window.innerWidth < 1280 && (e = 1.35); const t = "-4.4rem"; Ci.to(h, { scale: .25, x: t, duration: .6, ease: "power2.inOut", transformOrigin: "top center", onComplete: () => { Ci.set(h, { position: "fixed" }) } }), g.forEach(((e, t) => { Ci.to(e, { marginTop: 0 === t ? 0 : "24px", delay: .1, ease: "power2.inOut" }) })) } else Ci.to(h, { x: "-100%", duration: .6, alpha: 0, ease: "expo.out" }); h.classList.add("active"), _(e.target), x(e.target) } })) })), document.querySelectorAll(".js-menu-main-overflow-item").forEach((e => { e.addEventListener("mouseenter", (e => { h.classList.contains("active") || (e.target.closest(".js-menu-main-contents"), c.forEach((t => { t != e.target.parentNode && t.classList.add("js-addOpacity") }))) })), e.addEventListener("mouseleave", (e => { h.classList.contains("active") || e.target.closest(".js-menu-main-contents").querySelectorAll(".js-opacity-item").forEach((t => { t != e.target.parentNode && t.classList.remove("js-addOpacity") })) })) })), a.forEach((e => { e.addEventListener("click", (e => { e.preventDefault(); const t = e.target.parentNode; Ci.to(d, { x: "100%", alpha: 0, duration: .6, ease: "expo.out", onStart: function () { this.targets()[0].classList.add("pointer-events-none") }, onComplete: function () { Ci.set(d, { display: "none" }), window.scrollTo({ top: 0, behavior: "smooth" }) } }); const n = h.querySelectorAll(".items-center"); Ci.set(n, { x: -100, opacity: 0, scaleX: 2.5, transformOrigin: "right center" }), Ci.to(n, { x: 0, opacity: 1, scaleX: 1, duration: .4, ease: "circ.out", stagger: .07, delay: .1 }), Ci.to(h, { x: "0", alpha: 1, duration: .6, delay: .1, ease: "expo.out" }), t.classList.remove("active"), h.classList.remove("active"), Ci.set(".js-menu-iconline-02", { clearProps: "all" }), c.forEach((e => { e.classList.remove("js-addOpacity") })) })) })), s.forEach(((e, t) => { e.addEventListener("mouseenter", (e => { h.classList.contains("active") && (e.target.classList.contains("active") || e.target.parentNode.classList.remove("js-addOpacity")) })), e.addEventListener("mouseleave", (e => { h.classList.contains("active") && (e.target.classList.contains("active") || e.target.parentNode.classList.add("js-addOpacity")) })) })), u.forEach((e => { e.addEventListener("mouseenter", (e => { e.target.closest(".js-menu-main-contents").querySelectorAll(".js-menu-main-link-item").forEach((t => { t != e.target && t.classList.add("js-addOpacity") })) })), e.addEventListener("mouseleave", (e => { e.target.closest(".js-menu-main-contents").querySelectorAll(".js-menu-main-link-item").forEach((t => { t != e.target && t.classList.remove("js-addOpacity") })) })) })), y } function ty() { let e = {}, t = 0; return { addEventListener: function (n, i, r, s) { return n.addEventListener(i, r, s), e[t] = { target: n, type: i, listener: r, capture: s }, t++ }, removeEventListener: function (t) { if (t in e) { var n = e[t]; n.target.removeEventListener(n.type, n.listener, n.capture) } }, destroy: function () { for (let t in e) { let n = e[t]; n.target.removeEventListener(n.type, n.listener, n.capture) } } } } n(662), Ci.registerPlugin(fa); const ny = (e, t) => { console.log("%cstopTransition", "font-weight: bold;color:blue;"), console.log("current page - " + e.current.namespace), console.log("next page - " + e.next.namespace); const n = document.querySelectorAll(".barba-container"); if ("solutions_child_page" === e.next.namespace) { let e; const t = document.querySelector(".js-transition-cover"); t.classList.forEach((t => { t.match(/bg-solution-/) && (e = t) })); const n = ty(); t.classList.remove("isTransition"), n.addEventListener(t, "transitionend", (i => { i.target.classList.contains("js-transition-cover") && (Ci.set(t, { clearProps: "all" }), t.classList.remove(e), n.destroy(), e = void 0) })) } n.forEach((e => { if (e.classList.contains("js_transitionOut")) return; const n = ty(); e.classList.add("js_showContents"), n.addEventListener(e, "transitionend", (e => { e.target.classList.contains("barba-container") && (n.destroy(), t()) })) })) }; function iy(e) { let t = []; const n = e.querySelectorAll("#dynamic-footer"), i = [...document.querySelectorAll(".js-fixed-fadeout-scroll")], r = [...e.querySelectorAll(".js-fixed-fadeout-scroll")], s = e.querySelector("#js-lig-footer-parent"); if (t = Object.assign(i, r), t && t.forEach((t => { let n = e.querySelector("#jsFooter"), i = null; t.dataset.fadeElement && (n = e.querySelector(t.dataset.fadeElement), i = window.outerHeight + "px"), Ci.to(t, { scrollTrigger: { trigger: n, start: () => "top center", end: i, toggleClass: { targets: t, className: "is-hide" }, markers: window.LIG.isDebug, invalidateOnRefresh: !0 } }) })), s) { const t = e.querySelector("#js-lig-footer-image"), n = e.querySelector(".footer-msg"); Ci.to(s, { scrollTrigger: { trigger: s, start: () => "center bottom", onEnter: () => { t.classList.contains("is-show") || (t.classList.add("is-show"), n.classList.add("is-show")) }, markers: window.LIG.isDebug, invalidateOnRefresh: !0 } }), Ci.to(s, { scrollTrigger: { trigger: "#jsFooter", start: () => "center center", onLeaveBack: () => { t.classList.contains("is-show") && (t.classList.remove("is-show"), n.classList.remove("is-show")) }, markers: window.LIG.isDebug, invalidateOnRefresh: !0 } }) } n && n.forEach((t => { let n = e.querySelector("#toc_container"); n || (n = e.querySelector(".title")), t.dataset.fadeElement && (n = e.querySelector(t.dataset.fadeElement)), Ci.to(t, { opacity: 1, scrollTrigger: { trigger: "body", start: () => n.offsetTop, end: () => "bottom bottom", toggleActions: "play none none reverse", onEnter: () => t.classList.remove("is-hide"), onLeaveBack: () => t.classList.add("is-hide") } }) })) } function ry(e) { return null !== e && "object" == typeof e && "constructor" in e && e.constructor === Object } function sy(e = {}, t = {}) { Object.keys(t).forEach((n => { void 0 === e[n] ? e[n] = t[n] : ry(t[n]) && ry(e[n]) && Object.keys(t[n]).length > 0 && sy(e[n], t[n]) })) } Ci.registerPlugin(fa); const ay = { body: {}, addEventListener() { }, removeEventListener() { }, activeElement: { blur() { }, nodeName: "" }, querySelector: () => null, querySelectorAll: () => [], getElementById: () => null, createEvent: () => ({ initEvent() { } }), createElement: () => ({ children: [], childNodes: [], style: {}, setAttribute() { }, getElementsByTagName: () => [] }), createElementNS: () => ({}), importNode: () => null, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" } }; function oy() { const e = "undefined" != typeof document ? document : {}; return sy(e, ay), e } const ly = { document: ay, navigator: { userAgent: "" }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" }, history: { replaceState() { }, pushState() { }, go() { }, back() { } }, CustomEvent: function () { return this }, addEventListener() { }, removeEventListener() { }, getComputedStyle: () => ({ getPropertyValue: () => "" }), Image() { }, Date() { }, screen: {}, setTimeout() { }, clearTimeout() { }, matchMedia: () => ({}), requestAnimationFrame: e => "undefined" == typeof setTimeout ? (e(), null) : setTimeout(e, 0), cancelAnimationFrame(e) { "undefined" != typeof setTimeout && clearTimeout(e) } }; function cy() { const e = "undefined" != typeof window ? window : {}; return sy(e, ly), e } class uy extends Array { constructor(e) { super(...e || []), function (e) { const t = e.__proto__; Object.defineProperty(e, "__proto__", { get: () => t, set(e) { t.__proto__ = e } }) }(this) } } function hy(e = []) { const t = []; return e.forEach((e => { Array.isArray(e) ? t.push(...hy(e)) : t.push(e) })), t } function dy(e, t) { return Array.prototype.filter.call(e, t) } function py(e, t) { const n = cy(), i = oy(); let r = []; if (!t && e instanceof uy) return e; if (!e) return new uy(r); if ("string" == typeof e) { const n = e.trim(); if (n.indexOf("<") >= 0 && n.indexOf(">") >= 0) { let e = "div"; 0 === n.indexOf("<li") && (e = "ul"), 0 === n.indexOf("<tr") && (e = "tbody"), 0 !== n.indexOf("<td") && 0 !== n.indexOf("<th") || (e = "tr"), 0 === n.indexOf("<tbody") && (e = "table"), 0 === n.indexOf("<option") && (e = "select"); const t = i.createElement(e); t.innerHTML = n; for (let e = 0; e < t.childNodes.length; e += 1)r.push(t.childNodes[e]) } else r = function (e, t) { if ("string" != typeof e) return [e]; const n = [], i = t.querySelectorAll(e); for (let e = 0; e < i.length; e += 1)n.push(i[e]); return n }(e.trim(), t || i) } else if (e.nodeType || e === n || e === i) r.push(e); else if (Array.isArray(e)) { if (e instanceof uy) return e; r = e } return new uy(function (e) { const t = []; for (let n = 0; n < e.length; n += 1)-1 === t.indexOf(e[n]) && t.push(e[n]); return t }(r)) } py.fn = uy.prototype; const fy = "resize scroll".split(" "); function my(e) { return function (...t) { if (void 0 === t[0]) { for (let t = 0; t < this.length; t += 1)fy.indexOf(e) < 0 && (e in this[t] ? this[t][e]() : py(this[t]).trigger(e)); return this } return this.on(e, ...t) } } my("click"), my("blur"), my("focus"), my("focusin"), my("focusout"), my("keyup"), my("keydown"), my("keypress"), my("submit"), my("change"), my("mousedown"), my("mousemove"), my("mouseup"), my("mouseenter"), my("mouseleave"), my("mouseout"), my("mouseover"), my("touchstart"), my("touchend"), my("touchmove"), my("resize"), my("scroll"); const gy = { addClass: function (...e) { const t = hy(e.map((e => e.split(" ")))); return this.forEach((e => { e.classList.add(...t) })), this }, removeClass: function (...e) { const t = hy(e.map((e => e.split(" ")))); return this.forEach((e => { e.classList.remove(...t) })), this }, hasClass: function (...e) { const t = hy(e.map((e => e.split(" ")))); return dy(this, (e => t.filter((t => e.classList.contains(t))).length > 0)).length > 0 }, toggleClass: function (...e) { const t = hy(e.map((e => e.split(" ")))); this.forEach((e => { t.forEach((t => { e.classList.toggle(t) })) })) }, attr: function (e, t) { if (1 === arguments.length && "string" == typeof e) return this[0] ? this[0].getAttribute(e) : void 0; for (let n = 0; n < this.length; n += 1)if (2 === arguments.length) this[n].setAttribute(e, t); else for (const t in e) this[n][t] = e[t], this[n].setAttribute(t, e[t]); return this }, removeAttr: function (e) { for (let t = 0; t < this.length; t += 1)this[t].removeAttribute(e); return this }, transform: function (e) { for (let t = 0; t < this.length; t += 1)this[t].style.transform = e; return this }, transition: function (e) { for (let t = 0; t < this.length; t += 1)this[t].style.transitionDuration = "string" != typeof e ? `${e}ms` : e; return this }, on: function (...e) { let [t, n, i, r] = e; function s(e) { const t = e.target; if (!t) return; const r = e.target.dom7EventData || []; if (r.indexOf(e) < 0 && r.unshift(e), py(t).is(n)) i.apply(t, r); else { const e = py(t).parents(); for (let t = 0; t < e.length; t += 1)py(e[t]).is(n) && i.apply(e[t], r) } } function a(e) { const t = e && e.target && e.target.dom7EventData || []; t.indexOf(e) < 0 && t.unshift(e), i.apply(this, t) } "function" == typeof e[1] && ([t, i, r] = e, n = void 0), r || (r = !1); const o = t.split(" "); let l; for (let e = 0; e < this.length; e += 1) { const t = this[e]; if (n) for (l = 0; l < o.length; l += 1) { const e = o[l]; t.dom7LiveListeners || (t.dom7LiveListeners = {}), t.dom7LiveListeners[e] || (t.dom7LiveListeners[e] = []), t.dom7LiveListeners[e].push({ listener: i, proxyListener: s }), t.addEventListener(e, s, r) } else for (l = 0; l < o.length; l += 1) { const e = o[l]; t.dom7Listeners || (t.dom7Listeners = {}), t.dom7Listeners[e] || (t.dom7Listeners[e] = []), t.dom7Listeners[e].push({ listener: i, proxyListener: a }), t.addEventListener(e, a, r) } } return this }, off: function (...e) { let [t, n, i, r] = e; "function" == typeof e[1] && ([t, i, r] = e, n = void 0), r || (r = !1); const s = t.split(" "); for (let e = 0; e < s.length; e += 1) { const t = s[e]; for (let e = 0; e < this.length; e += 1) { const s = this[e]; let a; if (!n && s.dom7Listeners ? a = s.dom7Listeners[t] : n && s.dom7LiveListeners && (a = s.dom7LiveListeners[t]), a && a.length) for (let e = a.length - 1; e >= 0; e -= 1) { const n = a[e]; i && n.listener === i || i && n.listener && n.listener.dom7proxy && n.listener.dom7proxy === i ? (s.removeEventListener(t, n.proxyListener, r), a.splice(e, 1)) : i || (s.removeEventListener(t, n.proxyListener, r), a.splice(e, 1)) } } } return this }, trigger: function (...e) { const t = cy(), n = e[0].split(" "), i = e[1]; for (let r = 0; r < n.length; r += 1) { const s = n[r]; for (let n = 0; n < this.length; n += 1) { const r = this[n]; if (t.CustomEvent) { const n = new t.CustomEvent(s, { detail: i, bubbles: !0, cancelable: !0 }); r.dom7EventData = e.filter(((e, t) => t > 0)), r.dispatchEvent(n), r.dom7EventData = [], delete r.dom7EventData } } } return this }, transitionEnd: function (e) { const t = this; return e && t.on("transitionend", (function n(i) { i.target === this && (e.call(this, i), t.off("transitionend", n)) })), this }, outerWidth: function (e) { if (this.length > 0) { if (e) { const e = this.styles(); return this[0].offsetWidth + parseFloat(e.getPropertyValue("margin-right")) + parseFloat(e.getPropertyValue("margin-left")) } return this[0].offsetWidth } return null }, outerHeight: function (e) { if (this.length > 0) { if (e) { const e = this.styles(); return this[0].offsetHeight + parseFloat(e.getPropertyValue("margin-top")) + parseFloat(e.getPropertyValue("margin-bottom")) } return this[0].offsetHeight } return null }, styles: function () { const e = cy(); return this[0] ? e.getComputedStyle(this[0], null) : {} }, offset: function () { if (this.length > 0) { const e = cy(), t = oy(), n = this[0], i = n.getBoundingClientRect(), r = t.body, s = n.clientTop || r.clientTop || 0, a = n.clientLeft || r.clientLeft || 0, o = n === e ? e.scrollY : n.scrollTop, l = n === e ? e.scrollX : n.scrollLeft; return { top: i.top + o - s, left: i.left + l - a } } return null }, css: function (e, t) { const n = cy(); let i; if (1 === arguments.length) { if ("string" != typeof e) { for (i = 0; i < this.length; i += 1)for (const t in e) this[i].style[t] = e[t]; return this } if (this[0]) return n.getComputedStyle(this[0], null).getPropertyValue(e) } if (2 === arguments.length && "string" == typeof e) { for (i = 0; i < this.length; i += 1)this[i].style[e] = t; return this } return this }, each: function (e) { return e ? (this.forEach(((t, n) => { e.apply(t, [t, n]) })), this) : this }, html: function (e) { if (void 0 === e) return this[0] ? this[0].innerHTML : null; for (let t = 0; t < this.length; t += 1)this[t].innerHTML = e; return this }, text: function (e) { if (void 0 === e) return this[0] ? this[0].textContent.trim() : null; for (let t = 0; t < this.length; t += 1)this[t].textContent = e; return this }, is: function (e) { const t = cy(), n = oy(), i = this[0]; let r, s; if (!i || void 0 === e) return !1; if ("string" == typeof e) { if (i.matches) return i.matches(e); if (i.webkitMatchesSelector) return i.webkitMatchesSelector(e); if (i.msMatchesSelector) return i.msMatchesSelector(e); for (r = py(e), s = 0; s < r.length; s += 1)if (r[s] === i) return !0; return !1 } if (e === n) return i === n; if (e === t) return i === t; if (e.nodeType || e instanceof uy) { for (r = e.nodeType ? [e] : e, s = 0; s < r.length; s += 1)if (r[s] === i) return !0; return !1 } return !1 }, index: function () { let e, t = this[0]; if (t) { for (e = 0; null !== (t = t.previousSibling);)1 === t.nodeType && (e += 1); return e } }, eq: function (e) { if (void 0 === e) return this; const t = this.length; if (e > t - 1) return py([]); if (e < 0) { const n = t + e; return py(n < 0 ? [] : [this[n]]) } return py([this[e]]) }, append: function (...e) { let t; const n = oy(); for (let i = 0; i < e.length; i += 1) { t = e[i]; for (let e = 0; e < this.length; e += 1)if ("string" == typeof t) { const i = n.createElement("div"); for (i.innerHTML = t; i.firstChild;)this[e].appendChild(i.firstChild) } else if (t instanceof uy) for (let n = 0; n < t.length; n += 1)this[e].appendChild(t[n]); else this[e].appendChild(t) } return this }, prepend: function (e) { const t = oy(); let n, i; for (n = 0; n < this.length; n += 1)if ("string" == typeof e) { const r = t.createElement("div"); for (r.innerHTML = e, i = r.childNodes.length - 1; i >= 0; i -= 1)this[n].insertBefore(r.childNodes[i], this[n].childNodes[0]) } else if (e instanceof uy) for (i = 0; i < e.length; i += 1)this[n].insertBefore(e[i], this[n].childNodes[0]); else this[n].insertBefore(e, this[n].childNodes[0]); return this }, next: function (e) { return this.length > 0 ? e ? this[0].nextElementSibling && py(this[0].nextElementSibling).is(e) ? py([this[0].nextElementSibling]) : py([]) : this[0].nextElementSibling ? py([this[0].nextElementSibling]) : py([]) : py([]) }, nextAll: function (e) { const t = []; let n = this[0]; if (!n) return py([]); for (; n.nextElementSibling;) { const i = n.nextElementSibling; e ? py(i).is(e) && t.push(i) : t.push(i), n = i } return py(t) }, prev: function (e) { if (this.length > 0) { const t = this[0]; return e ? t.previousElementSibling && py(t.previousElementSibling).is(e) ? py([t.previousElementSibling]) : py([]) : t.previousElementSibling ? py([t.previousElementSibling]) : py([]) } return py([]) }, prevAll: function (e) { const t = []; let n = this[0]; if (!n) return py([]); for (; n.previousElementSibling;) { const i = n.previousElementSibling; e ? py(i).is(e) && t.push(i) : t.push(i), n = i } return py(t) }, parent: function (e) { const t = []; for (let n = 0; n < this.length; n += 1)null !== this[n].parentNode && (e ? py(this[n].parentNode).is(e) && t.push(this[n].parentNode) : t.push(this[n].parentNode)); return py(t) }, parents: function (e) { const t = []; for (let n = 0; n < this.length; n += 1) { let i = this[n].parentNode; for (; i;)e ? py(i).is(e) && t.push(i) : t.push(i), i = i.parentNode } return py(t) }, closest: function (e) { let t = this; return void 0 === e ? py([]) : (t.is(e) || (t = t.parents(e).eq(0)), t) }, find: function (e) { const t = []; for (let n = 0; n < this.length; n += 1) { const i = this[n].querySelectorAll(e); for (let e = 0; e < i.length; e += 1)t.push(i[e]) } return py(t) }, children: function (e) { const t = []; for (let n = 0; n < this.length; n += 1) { const i = this[n].children; for (let n = 0; n < i.length; n += 1)e && !py(i[n]).is(e) || t.push(i[n]) } return py(t) }, filter: function (e) { return py(dy(this, e)) }, remove: function () { for (let e = 0; e < this.length; e += 1)this[e].parentNode && this[e].parentNode.removeChild(this[e]); return this } }; Object.keys(gy).forEach((e => { Object.defineProperty(py.fn, e, { value: gy[e], writable: !0 }) })); const vy = py; function yy(e, t = 0) { return setTimeout(e, t) } function xy() { return Date.now() } function _y(e, t = "x") { const n = cy(); let i, r, s; const a = function (e) { const t = cy(); let n; return t.getComputedStyle && (n = t.getComputedStyle(e, null)), !n && e.currentStyle && (n = e.currentStyle), n || (n = e.style), n }(e); return n.WebKitCSSMatrix ? (r = a.transform || a.webkitTransform, r.split(",").length > 6 && (r = r.split(", ").map((e => e.replace(",", "."))).join(", ")), s = new n.WebKitCSSMatrix("none" === r ? "" : r)) : (s = a.MozTransform || a.OTransform || a.MsTransform || a.msTransform || a.transform || a.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), i = s.toString().split(",")), "x" === t && (r = n.WebKitCSSMatrix ? s.m41 : 16 === i.length ? parseFloat(i[12]) : parseFloat(i[4])), "y" === t && (r = n.WebKitCSSMatrix ? s.m42 : 16 === i.length ? parseFloat(i[13]) : parseFloat(i[5])), r || 0 } function wy(e) { return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1) } function by(...e) { const t = Object(e[0]), n = ["__proto__", "constructor", "prototype"]; for (let r = 1; r < e.length; r += 1) { const s = e[r]; if (null != s && (i = s, !("undefined" != typeof window && void 0 !== window.HTMLElement ? i instanceof HTMLElement : i && (1 === i.nodeType || 11 === i.nodeType)))) { const e = Object.keys(Object(s)).filter((e => n.indexOf(e) < 0)); for (let n = 0, i = e.length; n < i; n += 1) { const i = e[n], r = Object.getOwnPropertyDescriptor(s, i); void 0 !== r && r.enumerable && (wy(t[i]) && wy(s[i]) ? s[i].__swiper__ ? t[i] = s[i] : by(t[i], s[i]) : !wy(t[i]) && wy(s[i]) ? (t[i] = {}, s[i].__swiper__ ? t[i] = s[i] : by(t[i], s[i])) : t[i] = s[i]) } } } var i; return t } function Sy(e, t, n) { e.style.setProperty(t, n) } function Ey({ swiper: e, targetPosition: t, side: n }) { const i = cy(), r = -e.translate; let s, a = null; const o = e.params.speed; e.wrapperEl.style.scrollSnapType = "none", i.cancelAnimationFrame(e.cssModeFrameID); const l = t > r ? "next" : "prev", c = (e, t) => "next" === l && e >= t || "prev" === l && e <= t, u = () => { s = (new Date).getTime(), null === a && (a = s); const l = Math.max(Math.min((s - a) / o, 1), 0), h = .5 - Math.cos(l * Math.PI) / 2; let d = r + h * (t - r); if (c(d, t) && (d = t), e.wrapperEl.scrollTo({ [n]: d }), c(d, t)) return e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.scrollSnapType = "", setTimeout((() => { e.wrapperEl.style.overflow = "", e.wrapperEl.scrollTo({ [n]: d }) })), void i.cancelAnimationFrame(e.cssModeFrameID); e.cssModeFrameID = i.requestAnimationFrame(u) }; u() } let My, Ty, Cy; function Dy() { return My || (My = function () { const e = cy(), t = oy(); return { smoothScroll: t.documentElement && "scrollBehavior" in t.documentElement.style, touch: !!("ontouchstart" in e || e.DocumentTouch && t instanceof e.DocumentTouch), passiveListener: function () { let t = !1; try { const n = Object.defineProperty({}, "passive", { get() { t = !0 } }); e.addEventListener("testPassiveListener", null, n) } catch (e) { } return t }(), gestures: "ongesturestart" in e } }()), My } const Ly = { on(e, t, n) { const i = this; if ("function" != typeof t) return i; const r = n ? "unshift" : "push"; return e.split(" ").forEach((e => { i.eventsListeners[e] || (i.eventsListeners[e] = []), i.eventsListeners[e][r](t) })), i }, once(e, t, n) { const i = this; if ("function" != typeof t) return i; function r(...n) { i.off(e, r), r.__emitterProxy && delete r.__emitterProxy, t.apply(i, n) } return r.__emitterProxy = t, i.on(e, r, n) }, onAny(e, t) { const n = this; if ("function" != typeof e) return n; const i = t ? "unshift" : "push"; return n.eventsAnyListeners.indexOf(e) < 0 && n.eventsAnyListeners[i](e), n }, offAny(e) { const t = this; if (!t.eventsAnyListeners) return t; const n = t.eventsAnyListeners.indexOf(e); return n >= 0 && t.eventsAnyListeners.splice(n, 1), t }, off(e, t) { const n = this; return n.eventsListeners ? (e.split(" ").forEach((e => { void 0 === t ? n.eventsListeners[e] = [] : n.eventsListeners[e] && n.eventsListeners[e].forEach(((i, r) => { (i === t || i.__emitterProxy && i.__emitterProxy === t) && n.eventsListeners[e].splice(r, 1) })) })), n) : n }, emit(...e) { const t = this; if (!t.eventsListeners) return t; let n, i, r; return "string" == typeof e[0] || Array.isArray(e[0]) ? (n = e[0], i = e.slice(1, e.length), r = t) : (n = e[0].events, i = e[0].data, r = e[0].context || t), i.unshift(r), (Array.isArray(n) ? n : n.split(" ")).forEach((e => { t.eventsAnyListeners && t.eventsAnyListeners.length && t.eventsAnyListeners.forEach((t => { t.apply(r, [e, ...i]) })), t.eventsListeners && t.eventsListeners[e] && t.eventsListeners[e].forEach((e => { e.apply(r, i) })) })), t } }, Ay = { updateSize: function () { const e = this; let t, n; const i = e.$el; t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : i[0].clientWidth, n = void 0 !== e.params.height && null !== e.params.height ? e.params.height : i[0].clientHeight, 0 === t && e.isHorizontal() || 0 === n && e.isVertical() || (t = t - parseInt(i.css("padding-left") || 0, 10) - parseInt(i.css("padding-right") || 0, 10), n = n - parseInt(i.css("padding-top") || 0, 10) - parseInt(i.css("padding-bottom") || 0, 10), Number.isNaN(t) && (t = 0), Number.isNaN(n) && (n = 0), Object.assign(e, { width: t, height: n, size: e.isHorizontal() ? t : n })) }, updateSlides: function () { const e = this; function t(t) { return e.isHorizontal() ? t : { width: "height", "margin-top": "margin-left", "margin-bottom ": "margin-right", "margin-left": "margin-top", "margin-right": "margin-bottom", "padding-left": "padding-top", "padding-right": "padding-bottom", marginRight: "marginBottom" }[t] } function n(e, n) { return parseFloat(e.getPropertyValue(t(n)) || 0) } const i = e.params, { $wrapperEl: r, size: s, rtlTranslate: a, wrongRTL: o } = e, l = e.virtual && i.virtual.enabled, c = l ? e.virtual.slides.length : e.slides.length, u = r.children(`.${e.params.slideClass}`), h = l ? e.virtual.slides.length : u.length; let d = []; const p = [], f = []; let m = i.slidesOffsetBefore; "function" == typeof m && (m = i.slidesOffsetBefore.call(e)); let g = i.slidesOffsetAfter; "function" == typeof g && (g = i.slidesOffsetAfter.call(e)); const v = e.snapGrid.length, y = e.slidesGrid.length; let x = i.spaceBetween, _ = -m, w = 0, b = 0; if (void 0 === s) return; "string" == typeof x && x.indexOf("%") >= 0 && (x = parseFloat(x.replace("%", "")) / 100 * s), e.virtualSize = -x, a ? u.css({ marginLeft: "", marginBottom: "", marginTop: "" }) : u.css({ marginRight: "", marginBottom: "", marginTop: "" }), i.centeredSlides && i.cssMode && (Sy(e.wrapperEl, "--swiper-centered-offset-before", ""), Sy(e.wrapperEl, "--swiper-centered-offset-after", "")); const S = i.grid && i.grid.rows > 1 && e.grid; let E; S && e.grid.initSlides(h); const M = "auto" === i.slidesPerView && i.breakpoints && Object.keys(i.breakpoints).filter((e => void 0 !== i.breakpoints[e].slidesPerView)).length > 0; for (let r = 0; r < h; r += 1) { E = 0; const a = u.eq(r); if (S && e.grid.updateSlide(r, a, h, t), "none" !== a.css("display")) { if ("auto" === i.slidesPerView) { M && (u[r].style[t("width")] = ""); const s = getComputedStyle(a[0]), o = a[0].style.transform, l = a[0].style.webkitTransform; if (o && (a[0].style.transform = "none"), l && (a[0].style.webkitTransform = "none"), i.roundLengths) E = e.isHorizontal() ? a.outerWidth(!0) : a.outerHeight(!0); else { const e = n(s, "width"), t = n(s, "padding-left"), i = n(s, "padding-right"), r = n(s, "margin-left"), o = n(s, "margin-right"), l = s.getPropertyValue("box-sizing"); if (l && "border-box" === l) E = e + r + o; else { const { clientWidth: n, offsetWidth: s } = a[0]; E = e + t + i + r + o + (s - n) } } o && (a[0].style.transform = o), l && (a[0].style.webkitTransform = l), i.roundLengths && (E = Math.floor(E)) } else E = (s - (i.slidesPerView - 1) * x) / i.slidesPerView, i.roundLengths && (E = Math.floor(E)), u[r] && (u[r].style[t("width")] = `${E}px`); u[r] && (u[r].swiperSlideSize = E), f.push(E), i.centeredSlides ? (_ = _ + E / 2 + w / 2 + x, 0 === w && 0 !== r && (_ = _ - s / 2 - x), 0 === r && (_ = _ - s / 2 - x), Math.abs(_) < .001 && (_ = 0), i.roundLengths && (_ = Math.floor(_)), b % i.slidesPerGroup == 0 && d.push(_), p.push(_)) : (i.roundLengths && (_ = Math.floor(_)), (b - Math.min(e.params.slidesPerGroupSkip, b)) % e.params.slidesPerGroup == 0 && d.push(_), p.push(_), _ = _ + E + x), e.virtualSize += E + x, w = E, b += 1 } } if (e.virtualSize = Math.max(e.virtualSize, s) + g, a && o && ("slide" === i.effect || "coverflow" === i.effect) && r.css({ width: `${e.virtualSize + i.spaceBetween}px` }), i.setWrapperSize && r.css({ [t("width")]: `${e.virtualSize + i.spaceBetween}px` }), S && e.grid.updateWrapperSize(E, d, t), !i.centeredSlides) { const t = []; for (let n = 0; n < d.length; n += 1) { let r = d[n]; i.roundLengths && (r = Math.floor(r)), d[n] <= e.virtualSize - s && t.push(r) } d = t, Math.floor(e.virtualSize - s) - Math.floor(d[d.length - 1]) > 1 && d.push(e.virtualSize - s) } if (0 === d.length && (d = [0]), 0 !== i.spaceBetween) { const n = e.isHorizontal() && a ? "marginLeft" : t("marginRight"); u.filter(((e, t) => !i.cssMode || t !== u.length - 1)).css({ [n]: `${x}px` }) } if (i.centeredSlides && i.centeredSlidesBounds) { let e = 0; f.forEach((t => { e += t + (i.spaceBetween ? i.spaceBetween : 0) })), e -= i.spaceBetween; const t = e - s; d = d.map((e => e < 0 ? -m : e > t ? t + g : e)) } if (i.centerInsufficientSlides) { let e = 0; if (f.forEach((t => { e += t + (i.spaceBetween ? i.spaceBetween : 0) })), e -= i.spaceBetween, e < s) { const t = (s - e) / 2; d.forEach(((e, n) => { d[n] = e - t })), p.forEach(((e, n) => { p[n] = e + t })) } } if (Object.assign(e, { slides: u, snapGrid: d, slidesGrid: p, slidesSizesGrid: f }), i.centeredSlides && i.cssMode && !i.centeredSlidesBounds) { Sy(e.wrapperEl, "--swiper-centered-offset-before", -d[0] + "px"), Sy(e.wrapperEl, "--swiper-centered-offset-after", e.size / 2 - f[f.length - 1] / 2 + "px"); const t = -e.snapGrid[0], n = -e.slidesGrid[0]; e.snapGrid = e.snapGrid.map((e => e + t)), e.slidesGrid = e.slidesGrid.map((e => e + n)) } h !== c && e.emit("slidesLengthChange"), d.length !== v && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), p.length !== y && e.emit("slidesGridLengthChange"), i.watchSlidesProgress && e.updateSlidesOffset() }, updateAutoHeight: function (e) { const t = this, n = [], i = t.virtual && t.params.virtual.enabled; let r, s = 0; "number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed); const a = e => i ? t.slides.filter((t => parseInt(t.getAttribute("data-swiper-slide-index"), 10) === e))[0] : t.slides.eq(e)[0]; if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1) if (t.params.centeredSlides) t.visibleSlides.each((e => { n.push(e) })); else for (r = 0; r < Math.ceil(t.params.slidesPerView); r += 1) { const e = t.activeIndex + r; if (e > t.slides.length && !i) break; n.push(a(e)) } else n.push(a(t.activeIndex)); for (r = 0; r < n.length; r += 1)if (void 0 !== n[r]) { const e = n[r].offsetHeight; s = e > s ? e : s } (s || 0 === s) && t.$wrapperEl.css("height", `${s}px`) }, updateSlidesOffset: function () { const e = this, t = e.slides; for (let n = 0; n < t.length; n += 1)t[n].swiperSlideOffset = e.isHorizontal() ? t[n].offsetLeft : t[n].offsetTop }, updateSlidesProgress: function (e = this && this.translate || 0) { const t = this, n = t.params, { slides: i, rtlTranslate: r, snapGrid: s } = t; if (0 === i.length) return; void 0 === i[0].swiperSlideOffset && t.updateSlidesOffset(); let a = -e; r && (a = e), i.removeClass(n.slideVisibleClass), t.visibleSlidesIndexes = [], t.visibleSlides = []; for (let e = 0; e < i.length; e += 1) { const o = i[e]; let l = o.swiperSlideOffset; n.cssMode && n.centeredSlides && (l -= i[0].swiperSlideOffset); const c = (a + (n.centeredSlides ? t.minTranslate() : 0) - l) / (o.swiperSlideSize + n.spaceBetween), u = (a - s[0] + (n.centeredSlides ? t.minTranslate() : 0) - l) / (o.swiperSlideSize + n.spaceBetween), h = -(a - l), d = h + t.slidesSizesGrid[e]; (h >= 0 && h < t.size - 1 || d > 1 && d <= t.size || h <= 0 && d >= t.size) && (t.visibleSlides.push(o), t.visibleSlidesIndexes.push(e), i.eq(e).addClass(n.slideVisibleClass)), o.progress = r ? -c : c, o.originalProgress = r ? -u : u } t.visibleSlides = vy(t.visibleSlides) }, updateProgress: function (e) { const t = this; if (void 0 === e) { const n = t.rtlTranslate ? -1 : 1; e = t && t.translate && t.translate * n || 0 } const n = t.params, i = t.maxTranslate() - t.minTranslate(); let { progress: r, isBeginning: s, isEnd: a } = t; const o = s, l = a; 0 === i ? (r = 0, s = !0, a = !0) : (r = (e - t.minTranslate()) / i, s = r <= 0, a = r >= 1), Object.assign(t, { progress: r, isBeginning: s, isEnd: a }), (n.watchSlidesProgress || n.centeredSlides && n.autoHeight) && t.updateSlidesProgress(e), s && !o && t.emit("reachBeginning toEdge"), a && !l && t.emit("reachEnd toEdge"), (o && !s || l && !a) && t.emit("fromEdge"), t.emit("progress", r) }, updateSlidesClasses: function () { const e = this, { slides: t, params: n, $wrapperEl: i, activeIndex: r, realIndex: s } = e, a = e.virtual && n.virtual.enabled; let o; t.removeClass(`${n.slideActiveClass} ${n.slideNextClass} ${n.slidePrevClass} ${n.slideDuplicateActiveClass} ${n.slideDuplicateNextClass} ${n.slideDuplicatePrevClass}`), o = a ? e.$wrapperEl.find(`.${n.slideClass}[data-swiper-slide-index="${r}"]`) : t.eq(r), o.addClass(n.slideActiveClass), n.loop && (o.hasClass(n.slideDuplicateClass) ? i.children(`.${n.slideClass}:not(.${n.slideDuplicateClass})[data-swiper-slide-index="${s}"]`).addClass(n.slideDuplicateActiveClass) : i.children(`.${n.slideClass}.${n.slideDuplicateClass}[data-swiper-slide-index="${s}"]`).addClass(n.slideDuplicateActiveClass)); let l = o.nextAll(`.${n.slideClass}`).eq(0).addClass(n.slideNextClass); n.loop && 0 === l.length && (l = t.eq(0), l.addClass(n.slideNextClass)); let c = o.prevAll(`.${n.slideClass}`).eq(0).addClass(n.slidePrevClass); n.loop && 0 === c.length && (c = t.eq(-1), c.addClass(n.slidePrevClass)), n.loop && (l.hasClass(n.slideDuplicateClass) ? i.children(`.${n.slideClass}:not(.${n.slideDuplicateClass})[data-swiper-slide-index="${l.attr("data-swiper-slide-index")}"]`).addClass(n.slideDuplicateNextClass) : i.children(`.${n.slideClass}.${n.slideDuplicateClass}[data-swiper-slide-index="${l.attr("data-swiper-slide-index")}"]`).addClass(n.slideDuplicateNextClass), c.hasClass(n.slideDuplicateClass) ? i.children(`.${n.slideClass}:not(.${n.slideDuplicateClass})[data-swiper-slide-index="${c.attr("data-swiper-slide-index")}"]`).addClass(n.slideDuplicatePrevClass) : i.children(`.${n.slideClass}.${n.slideDuplicateClass}[data-swiper-slide-index="${c.attr("data-swiper-slide-index")}"]`).addClass(n.slideDuplicatePrevClass)), e.emitSlidesClasses() }, updateActiveIndex: function (e) { const t = this, n = t.rtlTranslate ? t.translate : -t.translate, { slidesGrid: i, snapGrid: r, params: s, activeIndex: a, realIndex: o, snapIndex: l } = t; let c, u = e; if (void 0 === u) { for (let e = 0; e < i.length; e += 1)void 0 !== i[e + 1] ? n >= i[e] && n < i[e + 1] - (i[e + 1] - i[e]) / 2 ? u = e : n >= i[e] && n < i[e + 1] && (u = e + 1) : n >= i[e] && (u = e); s.normalizeSlideIndex && (u < 0 || void 0 === u) && (u = 0) } if (r.indexOf(n) >= 0) c = r.indexOf(n); else { const e = Math.min(s.slidesPerGroupSkip, u); c = e + Math.floor((u - e) / s.slidesPerGroup) } if (c >= r.length && (c = r.length - 1), u === a) return void (c !== l && (t.snapIndex = c, t.emit("snapIndexChange"))); const h = parseInt(t.slides.eq(u).attr("data-swiper-slide-index") || u, 10); Object.assign(t, { snapIndex: c, realIndex: h, previousIndex: a, activeIndex: u }), t.emit("activeIndexChange"), t.emit("snapIndexChange"), o !== h && t.emit("realIndexChange"), (t.initialized || t.params.runCallbacksOnInit) && t.emit("slideChange") }, updateClickedSlide: function (e) { const t = this, n = t.params, i = vy(e).closest(`.${n.slideClass}`)[0]; let r, s = !1; if (i) for (let e = 0; e < t.slides.length; e += 1)if (t.slides[e] === i) { s = !0, r = e; break } if (!i || !s) return t.clickedSlide = void 0, void (t.clickedIndex = void 0); t.clickedSlide = i, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(vy(i).attr("data-swiper-slide-index"), 10) : t.clickedIndex = r, n.slideToClickedSlide && void 0 !== t.clickedIndex && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide() } }; function Py({ swiper: e, runCallbacks: t, direction: n, step: i }) { const { activeIndex: r, previousIndex: s } = e; let a = n; if (a || (a = r > s ? "next" : r < s ? "prev" : "reset"), e.emit(`transition${i}`), t && r !== s) { if ("reset" === a) return void e.emit(`slideResetTransition${i}`); e.emit(`slideChangeTransition${i}`), "next" === a ? e.emit(`slideNextTransition${i}`) : e.emit(`slidePrevTransition${i}`) } } const Ry = { slideTo: function (e = 0, t = this.params.speed, n = !0, i, r) { if ("number" != typeof e && "string" != typeof e) throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof e}] given.`); if ("string" == typeof e) { const t = parseInt(e, 10); if (!isFinite(t)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`); e = t } const s = this; let a = e; a < 0 && (a = 0); const { params: o, snapGrid: l, slidesGrid: c, previousIndex: u, activeIndex: h, rtlTranslate: d, wrapperEl: p, enabled: f } = s; if (s.animating && o.preventInteractionOnTransition || !f && !i && !r) return !1; const m = Math.min(s.params.slidesPerGroupSkip, a); let g = m + Math.floor((a - m) / s.params.slidesPerGroup); g >= l.length && (g = l.length - 1), (h || o.initialSlide || 0) === (u || 0) && n && s.emit("beforeSlideChangeStart"); const v = -l[g]; if (s.updateProgress(v), o.normalizeSlideIndex) for (let e = 0; e < c.length; e += 1) { const t = -Math.floor(100 * v), n = Math.floor(100 * c[e]), i = Math.floor(100 * c[e + 1]); void 0 !== c[e + 1] ? t >= n && t < i - (i - n) / 2 ? a = e : t >= n && t < i && (a = e + 1) : t >= n && (a = e) } if (s.initialized && a !== h) { if (!s.allowSlideNext && v < s.translate && v < s.minTranslate()) return !1; if (!s.allowSlidePrev && v > s.translate && v > s.maxTranslate() && (h || 0) !== a) return !1 } let y; if (y = a > h ? "next" : a < h ? "prev" : "reset", d && -v === s.translate || !d && v === s.translate) return s.updateActiveIndex(a), o.autoHeight && s.updateAutoHeight(), s.updateSlidesClasses(), "slide" !== o.effect && s.setTranslate(v), "reset" !== y && (s.transitionStart(n, y), s.transitionEnd(n, y)), !1; if (o.cssMode) { const e = s.isHorizontal(), n = d ? v : -v; if (0 === t) { const t = s.virtual && s.params.virtual.enabled; t && (s.wrapperEl.style.scrollSnapType = "none", s._immediateVirtual = !0), p[e ? "scrollLeft" : "scrollTop"] = n, t && requestAnimationFrame((() => { s.wrapperEl.style.scrollSnapType = "", s._swiperImmediateVirtual = !1 })) } else { if (!s.support.smoothScroll) return Ey({ swiper: s, targetPosition: n, side: e ? "left" : "top" }), !0; p.scrollTo({ [e ? "left" : "top"]: n, behavior: "smooth" }) } return !0 } return s.setTransition(t), s.setTranslate(v), s.updateActiveIndex(a), s.updateSlidesClasses(), s.emit("beforeTransitionStart", t, i), s.transitionStart(n, y), 0 === t ? s.transitionEnd(n, y) : s.animating || (s.animating = !0, s.onSlideToWrapperTransitionEnd || (s.onSlideToWrapperTransitionEnd = function (e) { s && !s.destroyed && e.target === this && (s.$wrapperEl[0].removeEventListener("transitionend", s.onSlideToWrapperTransitionEnd), s.$wrapperEl[0].removeEventListener("webkitTransitionEnd", s.onSlideToWrapperTransitionEnd), s.onSlideToWrapperTransitionEnd = null, delete s.onSlideToWrapperTransitionEnd, s.transitionEnd(n, y)) }), s.$wrapperEl[0].addEventListener("transitionend", s.onSlideToWrapperTransitionEnd), s.$wrapperEl[0].addEventListener("webkitTransitionEnd", s.onSlideToWrapperTransitionEnd)), !0 }, slideToLoop: function (e = 0, t = this.params.speed, n = !0, i) { const r = this; let s = e; return r.params.loop && (s += r.loopedSlides), r.slideTo(s, t, n, i) }, slideNext: function (e = this.params.speed, t = !0, n) { const i = this, { animating: r, enabled: s, params: a } = i; if (!s) return i; let o = a.slidesPerGroup; "auto" === a.slidesPerView && 1 === a.slidesPerGroup && a.slidesPerGroupAuto && (o = Math.max(i.slidesPerViewDynamic("current", !0), 1)); const l = i.activeIndex < a.slidesPerGroupSkip ? 1 : o; if (a.loop) { if (r && a.loopPreventsSlide) return !1; i.loopFix(), i._clientLeft = i.$wrapperEl[0].clientLeft } return a.rewind && i.isEnd ? i.slideTo(0, e, t, n) : i.slideTo(i.activeIndex + l, e, t, n) }, slidePrev: function (e = this.params.speed, t = !0, n) { const i = this, { params: r, animating: s, snapGrid: a, slidesGrid: o, rtlTranslate: l, enabled: c } = i; if (!c) return i; if (r.loop) { if (s && r.loopPreventsSlide) return !1; i.loopFix(), i._clientLeft = i.$wrapperEl[0].clientLeft } function u(e) { return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e) } const h = u(l ? i.translate : -i.translate), d = a.map((e => u(e))); let p = a[d.indexOf(h) - 1]; if (void 0 === p && r.cssMode) { let e; a.forEach(((t, n) => { h >= t && (e = n) })), void 0 !== e && (p = a[e > 0 ? e - 1 : e]) } let f = 0; return void 0 !== p && (f = o.indexOf(p), f < 0 && (f = i.activeIndex - 1), "auto" === r.slidesPerView && 1 === r.slidesPerGroup && r.slidesPerGroupAuto && (f = f - i.slidesPerViewDynamic("previous", !0) + 1, f = Math.max(f, 0))), r.rewind && i.isBeginning ? i.slideTo(i.slides.length - 1, e, t, n) : i.slideTo(f, e, t, n) }, slideReset: function (e = this.params.speed, t = !0, n) { return this.slideTo(this.activeIndex, e, t, n) }, slideToClosest: function (e = this.params.speed, t = !0, n, i = .5) { const r = this; let s = r.activeIndex; const a = Math.min(r.params.slidesPerGroupSkip, s), o = a + Math.floor((s - a) / r.params.slidesPerGroup), l = r.rtlTranslate ? r.translate : -r.translate; if (l >= r.snapGrid[o]) { const e = r.snapGrid[o]; l - e > (r.snapGrid[o + 1] - e) * i && (s += r.params.slidesPerGroup) } else { const e = r.snapGrid[o - 1]; l - e <= (r.snapGrid[o] - e) * i && (s -= r.params.slidesPerGroup) } return s = Math.max(s, 0), s = Math.min(s, r.slidesGrid.length - 1), r.slideTo(s, e, t, n) }, slideToClickedSlide: function () { const e = this, { params: t, $wrapperEl: n } = e, i = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView; let r, s = e.clickedIndex; if (t.loop) { if (e.animating) return; r = parseInt(vy(e.clickedSlide).attr("data-swiper-slide-index"), 10), t.centeredSlides ? s < e.loopedSlides - i / 2 || s > e.slides.length - e.loopedSlides + i / 2 ? (e.loopFix(), s = n.children(`.${t.slideClass}[data-swiper-slide-index="${r}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), yy((() => { e.slideTo(s) }))) : e.slideTo(s) : s > e.slides.length - i ? (e.loopFix(), s = n.children(`.${t.slideClass}[data-swiper-slide-index="${r}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), yy((() => { e.slideTo(s) }))) : e.slideTo(s) } else e.slideTo(s) } }, Oy = { loopCreate: function () { const e = this, t = oy(), { params: n, $wrapperEl: i } = e, r = i.children().length > 0 ? vy(i.children()[0].parentNode) : i; r.children(`.${n.slideClass}.${n.slideDuplicateClass}`).remove(); let s = r.children(`.${n.slideClass}`); if (n.loopFillGroupWithBlank) { const e = n.slidesPerGroup - s.length % n.slidesPerGroup; if (e !== n.slidesPerGroup) { for (let i = 0; i < e; i += 1) { const e = vy(t.createElement("div")).addClass(`${n.slideClass} ${n.slideBlankClass}`); r.append(e) } s = r.children(`.${n.slideClass}`) } } "auto" !== n.slidesPerView || n.loopedSlides || (n.loopedSlides = s.length), e.loopedSlides = Math.ceil(parseFloat(n.loopedSlides || n.slidesPerView, 10)), e.loopedSlides += n.loopAdditionalSlides, e.loopedSlides > s.length && (e.loopedSlides = s.length); const a = [], o = []; s.each(((t, n) => { const i = vy(t); n < e.loopedSlides && o.push(t), n < s.length && n >= s.length - e.loopedSlides && a.push(t), i.attr("data-swiper-slide-index", n) })); for (let e = 0; e < o.length; e += 1)r.append(vy(o[e].cloneNode(!0)).addClass(n.slideDuplicateClass)); for (let e = a.length - 1; e >= 0; e -= 1)r.prepend(vy(a[e].cloneNode(!0)).addClass(n.slideDuplicateClass)) }, loopFix: function () { const e = this; e.emit("beforeLoopFix"); const { activeIndex: t, slides: n, loopedSlides: i, allowSlidePrev: r, allowSlideNext: s, snapGrid: a, rtlTranslate: o } = e; let l; e.allowSlidePrev = !0, e.allowSlideNext = !0; const c = -a[t] - e.getTranslate(); t < i ? (l = n.length - 3 * i + t, l += i, e.slideTo(l, 0, !1, !0) && 0 !== c && e.setTranslate((o ? -e.translate : e.translate) - c)) : t >= n.length - i && (l = -n.length + t + i, l += i, e.slideTo(l, 0, !1, !0) && 0 !== c && e.setTranslate((o ? -e.translate : e.translate) - c)), e.allowSlidePrev = r, e.allowSlideNext = s, e.emit("loopFix") }, loopDestroy: function () { const { $wrapperEl: e, params: t, slides: n } = this; e.children(`.${t.slideClass}.${t.slideDuplicateClass},.${t.slideClass}.${t.slideBlankClass}`).remove(), n.removeAttr("data-swiper-slide-index") } }; function Iy(e) { const t = this, n = oy(), i = cy(), r = t.touchEventsData, { params: s, touches: a, enabled: o } = t; if (!o) return; if (t.animating && s.preventInteractionOnTransition) return; !t.animating && s.cssMode && s.loop && t.loopFix(); let l = e; l.originalEvent && (l = l.originalEvent); let c = vy(l.target); if ("wrapper" === s.touchEventsTarget && !c.closest(t.wrapperEl).length) return; if (r.isTouchEvent = "touchstart" === l.type, !r.isTouchEvent && "which" in l && 3 === l.which) return; if (!r.isTouchEvent && "button" in l && l.button > 0) return; if (r.isTouched && r.isMoved) return; s.noSwipingClass && "" !== s.noSwipingClass && l.target && l.target.shadowRoot && e.path && e.path[0] && (c = vy(e.path[0])); const u = s.noSwipingSelector ? s.noSwipingSelector : `.${s.noSwipingClass}`, h = !(!l.target || !l.target.shadowRoot); if (s.noSwiping && (h ? function (e, t = this) { return function t(n) { return n && n !== oy() && n !== cy() ? (n.assignedSlot && (n = n.assignedSlot), n.closest(e) || t(n.getRootNode().host)) : null }(t) }(u, l.target) : c.closest(u)[0])) return void (t.allowClick = !0); if (s.swipeHandler && !c.closest(s.swipeHandler)[0]) return; a.currentX = "touchstart" === l.type ? l.targetTouches[0].pageX : l.pageX, a.currentY = "touchstart" === l.type ? l.targetTouches[0].pageY : l.pageY; const d = a.currentX, p = a.currentY, f = s.edgeSwipeDetection || s.iOSEdgeSwipeDetection, m = s.edgeSwipeThreshold || s.iOSEdgeSwipeThreshold; if (f && (d <= m || d >= i.innerWidth - m)) { if ("prevent" !== f) return; e.preventDefault() } if (Object.assign(r, { isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0 }), a.startX = d, a.startY = p, r.touchStartTime = xy(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, s.threshold > 0 && (r.allowThresholdMove = !1), "touchstart" !== l.type) { let e = !0; c.is(r.focusableElements) && (e = !1), n.activeElement && vy(n.activeElement).is(r.focusableElements) && n.activeElement !== c[0] && n.activeElement.blur(); const i = e && t.allowTouchMove && s.touchStartPreventDefault; !s.touchStartForcePreventDefault && !i || c[0].isContentEditable || l.preventDefault() } t.emit("touchStart", l) } function Fy(e) { const t = oy(), n = this, i = n.touchEventsData, { params: r, touches: s, rtlTranslate: a, enabled: o } = n; if (!o) return; let l = e; if (l.originalEvent && (l = l.originalEvent), !i.isTouched) return void (i.startMoving && i.isScrolling && n.emit("touchMoveOpposite", l)); if (i.isTouchEvent && "touchmove" !== l.type) return; const c = "touchmove" === l.type && l.targetTouches && (l.targetTouches[0] || l.changedTouches[0]), u = "touchmove" === l.type ? c.pageX : l.pageX, h = "touchmove" === l.type ? c.pageY : l.pageY; if (l.preventedByNestedSwiper) return s.startX = u, void (s.startY = h); if (!n.allowTouchMove) return n.allowClick = !1, void (i.isTouched && (Object.assign(s, { startX: u, startY: h, currentX: u, currentY: h }), i.touchStartTime = xy())); if (i.isTouchEvent && r.touchReleaseOnEdges && !r.loop) if (n.isVertical()) { if (h < s.startY && n.translate <= n.maxTranslate() || h > s.startY && n.translate >= n.minTranslate()) return i.isTouched = !1, void (i.isMoved = !1) } else if (u < s.startX && n.translate <= n.maxTranslate() || u > s.startX && n.translate >= n.minTranslate()) return; if (i.isTouchEvent && t.activeElement && l.target === t.activeElement && vy(l.target).is(i.focusableElements)) return i.isMoved = !0, void (n.allowClick = !1); if (i.allowTouchCallbacks && n.emit("touchMove", l), l.targetTouches && l.targetTouches.length > 1) return; s.currentX = u, s.currentY = h; const d = s.currentX - s.startX, p = s.currentY - s.startY; if (n.params.threshold && Math.sqrt(d ** 2 + p ** 2) < n.params.threshold) return; if (void 0 === i.isScrolling) { let e; n.isHorizontal() && s.currentY === s.startY || n.isVertical() && s.currentX === s.startX ? i.isScrolling = !1 : d * d + p * p >= 25 && (e = 180 * Math.atan2(Math.abs(p), Math.abs(d)) / Math.PI, i.isScrolling = n.isHorizontal() ? e > r.touchAngle : 90 - e > r.touchAngle) } if (i.isScrolling && n.emit("touchMoveOpposite", l), void 0 === i.startMoving && (s.currentX === s.startX && s.currentY === s.startY || (i.startMoving = !0)), i.isScrolling) return void (i.isTouched = !1); if (!i.startMoving) return; n.allowClick = !1, !r.cssMode && l.cancelable && l.preventDefault(), r.touchMoveStopPropagation && !r.nested && l.stopPropagation(), i.isMoved || (r.loop && !r.cssMode && n.loopFix(), i.startTranslate = n.getTranslate(), n.setTransition(0), n.animating && n.$wrapperEl.trigger("webkitTransitionEnd transitionend"), i.allowMomentumBounce = !1, !r.grabCursor || !0 !== n.allowSlideNext && !0 !== n.allowSlidePrev || n.setGrabCursor(!0), n.emit("sliderFirstMove", l)), n.emit("sliderMove", l), i.isMoved = !0; let f = n.isHorizontal() ? d : p; s.diff = f, f *= r.touchRatio, a && (f = -f), n.swipeDirection = f > 0 ? "prev" : "next", i.currentTranslate = f + i.startTranslate; let m = !0, g = r.resistanceRatio; if (r.touchReleaseOnEdges && (g = 0), f > 0 && i.currentTranslate > n.minTranslate() ? (m = !1, r.resistance && (i.currentTranslate = n.minTranslate() - 1 + (-n.minTranslate() + i.startTranslate + f) ** g)) : f < 0 && i.currentTranslate < n.maxTranslate() && (m = !1, r.resistance && (i.currentTranslate = n.maxTranslate() + 1 - (n.maxTranslate() - i.startTranslate - f) ** g)), m && (l.preventedByNestedSwiper = !0), !n.allowSlideNext && "next" === n.swipeDirection && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !n.allowSlidePrev && "prev" === n.swipeDirection && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), n.allowSlidePrev || n.allowSlideNext || (i.currentTranslate = i.startTranslate), r.threshold > 0) { if (!(Math.abs(f) > r.threshold || i.allowThresholdMove)) return void (i.currentTranslate = i.startTranslate); if (!i.allowThresholdMove) return i.allowThresholdMove = !0, s.startX = s.currentX, s.startY = s.currentY, i.currentTranslate = i.startTranslate, void (s.diff = n.isHorizontal() ? s.currentX - s.startX : s.currentY - s.startY) } r.followFinger && !r.cssMode && ((r.freeMode && r.freeMode.enabled && n.freeMode || r.watchSlidesProgress) && (n.updateActiveIndex(), n.updateSlidesClasses()), n.params.freeMode && r.freeMode.enabled && n.freeMode && n.freeMode.onTouchMove(), n.updateProgress(i.currentTranslate), n.setTranslate(i.currentTranslate)) } function zy(e) { const t = this, n = t.touchEventsData, { params: i, touches: r, rtlTranslate: s, slidesGrid: a, enabled: o } = t; if (!o) return; let l = e; if (l.originalEvent && (l = l.originalEvent), n.allowTouchCallbacks && t.emit("touchEnd", l), n.allowTouchCallbacks = !1, !n.isTouched) return n.isMoved && i.grabCursor && t.setGrabCursor(!1), n.isMoved = !1, void (n.startMoving = !1); i.grabCursor && n.isMoved && n.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1); const c = xy(), u = c - n.touchStartTime; if (t.allowClick) { const e = l.path || l.composedPath && l.composedPath(); t.updateClickedSlide(e && e[0] || l.target), t.emit("tap click", l), u < 300 && c - n.lastClickTime < 300 && t.emit("doubleTap doubleClick", l) } if (n.lastClickTime = xy(), yy((() => { t.destroyed || (t.allowClick = !0) })), !n.isTouched || !n.isMoved || !t.swipeDirection || 0 === r.diff || n.currentTranslate === n.startTranslate) return n.isTouched = !1, n.isMoved = !1, void (n.startMoving = !1); let h; if (n.isTouched = !1, n.isMoved = !1, n.startMoving = !1, h = i.followFinger ? s ? t.translate : -t.translate : -n.currentTranslate, i.cssMode) return; if (t.params.freeMode && i.freeMode.enabled) return void t.freeMode.onTouchEnd({ currentPos: h }); let d = 0, p = t.slidesSizesGrid[0]; for (let e = 0; e < a.length; e += e < i.slidesPerGroupSkip ? 1 : i.slidesPerGroup) { const t = e < i.slidesPerGroupSkip - 1 ? 1 : i.slidesPerGroup; void 0 !== a[e + t] ? h >= a[e] && h < a[e + t] && (d = e, p = a[e + t] - a[e]) : h >= a[e] && (d = e, p = a[a.length - 1] - a[a.length - 2]) } const f = (h - a[d]) / p, m = d < i.slidesPerGroupSkip - 1 ? 1 : i.slidesPerGroup; if (u > i.longSwipesMs) { if (!i.longSwipes) return void t.slideTo(t.activeIndex); "next" === t.swipeDirection && (f >= i.longSwipesRatio ? t.slideTo(d + m) : t.slideTo(d)), "prev" === t.swipeDirection && (f > 1 - i.longSwipesRatio ? t.slideTo(d + m) : t.slideTo(d)) } else { if (!i.shortSwipes) return void t.slideTo(t.activeIndex); !t.navigation || l.target !== t.navigation.nextEl && l.target !== t.navigation.prevEl ? ("next" === t.swipeDirection && t.slideTo(d + m), "prev" === t.swipeDirection && t.slideTo(d)) : l.target === t.navigation.nextEl ? t.slideTo(d + m) : t.slideTo(d) } } function ky() { const e = this, { params: t, el: n } = e; if (n && 0 === n.offsetWidth) return; t.breakpoints && e.setBreakpoint(); const { allowSlideNext: i, allowSlidePrev: r, snapGrid: s } = e; e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(), ("auto" === t.slidesPerView || t.slidesPerView > 1) && e.isEnd && !e.isBeginning && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.run(), e.allowSlidePrev = r, e.allowSlideNext = i, e.params.watchOverflow && s !== e.snapGrid && e.checkOverflow() } function Ny(e) { const t = this; t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation()))) } function By() { const e = this, { wrapperEl: t, rtlTranslate: n, enabled: i } = e; if (!i) return; let r; e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, -0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses(); const s = e.maxTranslate() - e.minTranslate(); r = 0 === s ? 0 : (e.translate - e.minTranslate()) / s, r !== e.progress && e.updateProgress(n ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1) } let Hy = !1; function Uy() { } const Vy = (e, t) => { const n = oy(), { params: i, touchEvents: r, el: s, wrapperEl: a, device: o, support: l } = e, c = !!i.nested, u = "on" === t ? "addEventListener" : "removeEventListener", h = t; if (l.touch) { const t = !("touchstart" !== r.start || !l.passiveListener || !i.passiveListeners) && { passive: !0, capture: !1 }; s[u](r.start, e.onTouchStart, t), s[u](r.move, e.onTouchMove, l.passiveListener ? { passive: !1, capture: c } : c), s[u](r.end, e.onTouchEnd, t), r.cancel && s[u](r.cancel, e.onTouchEnd, t) } else s[u](r.start, e.onTouchStart, !1), n[u](r.move, e.onTouchMove, c), n[u](r.end, e.onTouchEnd, !1); (i.preventClicks || i.preventClicksPropagation) && s[u]("click", e.onClick, !0), i.cssMode && a[u]("scroll", e.onScroll), i.updateOnWindowResize ? e[h](o.ios || o.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", ky, !0) : e[h]("observerUpdate", ky, !0) }, Gy = { attachEvents: function () { const e = this, t = oy(), { params: n, support: i } = e; e.onTouchStart = Iy.bind(e), e.onTouchMove = Fy.bind(e), e.onTouchEnd = zy.bind(e), n.cssMode && (e.onScroll = By.bind(e)), e.onClick = Ny.bind(e), i.touch && !Hy && (t.addEventListener("touchstart", Uy), Hy = !0), Vy(e, "on") }, detachEvents: function () { Vy(this, "off") } }, jy = (e, t) => e.grid && t.grid && t.grid.rows > 1, Wy = { addClasses: function () { const e = this, { classNames: t, params: n, rtl: i, $el: r, device: s, support: a } = e, o = function (e, t) { const n = []; return e.forEach((e => { "object" == typeof e ? Object.keys(e).forEach((i => { e[i] && n.push(t + i) })) : "string" == typeof e && n.push(t + e) })), n }(["initialized", n.direction, { "pointer-events": !a.touch }, { "free-mode": e.params.freeMode && n.freeMode.enabled }, { autoheight: n.autoHeight }, { rtl: i }, { grid: n.grid && n.grid.rows > 1 }, { "grid-column": n.grid && n.grid.rows > 1 && "column" === n.grid.fill }, { android: s.android }, { ios: s.ios }, { "css-mode": n.cssMode }, { centered: n.cssMode && n.centeredSlides }], n.containerModifierClass); t.push(...o), r.addClass([...t].join(" ")), e.emitContainerClasses() }, removeClasses: function () { const { $el: e, classNames: t } = this; e.removeClass(t.join(" ")), this.emitContainerClasses() } }, qy = { init: !0, direction: "horizontal", touchEventsTarget: "wrapper", initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, resizeObserver: !0, nested: !1, createElements: !1, enabled: !0, focusableElements: "input, select, option, textarea, button, video, label", width: null, height: null, preventInteractionOnTransition: !1, userAgent: null, url: null, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: "slide", breakpoints: void 0, breakpointsBase: "window", spaceBetween: 0, slidesPerView: 1, slidesPerGroup: 1, slidesPerGroupSkip: 0, slidesPerGroupAuto: !1, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !0, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: .5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 0, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: .85, watchSlidesProgress: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, preloadImages: !0, updateOnImagesReady: !0, loop: !1, loopAdditionalSlides: 0, loopedSlides: null, loopFillGroupWithBlank: !1, loopPreventsSlide: !0, rewind: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: "swiper-no-swiping", noSwipingSelector: null, passiveListeners: !0, containerModifierClass: "swiper-", slideClass: "swiper-slide", slideBlankClass: "swiper-slide-invisible-blank", slideActiveClass: "swiper-slide-active", slideDuplicateActiveClass: "swiper-slide-duplicate-active", slideVisibleClass: "swiper-slide-visible", slideDuplicateClass: "swiper-slide-duplicate", slideNextClass: "swiper-slide-next", slideDuplicateNextClass: "swiper-slide-duplicate-next", slidePrevClass: "swiper-slide-prev", slideDuplicatePrevClass: "swiper-slide-duplicate-prev", wrapperClass: "swiper-wrapper", runCallbacksOnInit: !0, _emitClasses: !1 }; function $y(e, t) { return function (n = {}) { const i = Object.keys(n)[0], r = n[i]; "object" == typeof r && null !== r ? (["navigation", "pagination", "scrollbar"].indexOf(i) >= 0 && !0 === e[i] && (e[i] = { auto: !0 }), i in e && "enabled" in r ? (!0 === e[i] && (e[i] = { enabled: !0 }), "object" != typeof e[i] || "enabled" in e[i] || (e[i].enabled = !0), e[i] || (e[i] = { enabled: !1 }), by(t, n)) : by(t, n)) : by(t, n) } } const Xy = { eventsEmitter: Ly, update: Ay, translate: { getTranslate: function (e = (this.isHorizontal() ? "x" : "y")) { const { params: t, rtlTranslate: n, translate: i, $wrapperEl: r } = this; if (t.virtualTranslate) return n ? -i : i; if (t.cssMode) return i; let s = _y(r[0], e); return n && (s = -s), s || 0 }, setTranslate: function (e, t) { const n = this, { rtlTranslate: i, params: r, $wrapperEl: s, wrapperEl: a, progress: o } = n; let l, c = 0, u = 0; n.isHorizontal() ? c = i ? -e : e : u = e, r.roundLengths && (c = Math.floor(c), u = Math.floor(u)), r.cssMode ? a[n.isHorizontal() ? "scrollLeft" : "scrollTop"] = n.isHorizontal() ? -c : -u : r.virtualTranslate || s.transform(`translate3d(${c}px, ${u}px, 0px)`), n.previousTranslate = n.translate, n.translate = n.isHorizontal() ? c : u; const h = n.maxTranslate() - n.minTranslate(); l = 0 === h ? 0 : (e - n.minTranslate()) / h, l !== o && n.updateProgress(e), n.emit("setTranslate", n.translate, t) }, minTranslate: function () { return -this.snapGrid[0] }, maxTranslate: function () { return -this.snapGrid[this.snapGrid.length - 1] }, translateTo: function (e = 0, t = this.params.speed, n = !0, i = !0, r) { const s = this, { params: a, wrapperEl: o } = s; if (s.animating && a.preventInteractionOnTransition) return !1; const l = s.minTranslate(), c = s.maxTranslate(); let u; if (u = i && e > l ? l : i && e < c ? c : e, s.updateProgress(u), a.cssMode) { const e = s.isHorizontal(); if (0 === t) o[e ? "scrollLeft" : "scrollTop"] = -u; else { if (!s.support.smoothScroll) return Ey({ swiper: s, targetPosition: -u, side: e ? "left" : "top" }), !0; o.scrollTo({ [e ? "left" : "top"]: -u, behavior: "smooth" }) } return !0 } return 0 === t ? (s.setTransition(0), s.setTranslate(u), n && (s.emit("beforeTransitionStart", t, r), s.emit("transitionEnd"))) : (s.setTransition(t), s.setTranslate(u), n && (s.emit("beforeTransitionStart", t, r), s.emit("transitionStart")), s.animating || (s.animating = !0, s.onTranslateToWrapperTransitionEnd || (s.onTranslateToWrapperTransitionEnd = function (e) { s && !s.destroyed && e.target === this && (s.$wrapperEl[0].removeEventListener("transitionend", s.onTranslateToWrapperTransitionEnd), s.$wrapperEl[0].removeEventListener("webkitTransitionEnd", s.onTranslateToWrapperTransitionEnd), s.onTranslateToWrapperTransitionEnd = null, delete s.onTranslateToWrapperTransitionEnd, n && s.emit("transitionEnd")) }), s.$wrapperEl[0].addEventListener("transitionend", s.onTranslateToWrapperTransitionEnd), s.$wrapperEl[0].addEventListener("webkitTransitionEnd", s.onTranslateToWrapperTransitionEnd))), !0 } }, transition: { setTransition: function (e, t) { const n = this; n.params.cssMode || n.$wrapperEl.transition(e), n.emit("setTransition", e, t) }, transitionStart: function (e = !0, t) { const n = this, { params: i } = n; i.cssMode || (i.autoHeight && n.updateAutoHeight(), Py({ swiper: n, runCallbacks: e, direction: t, step: "Start" })) }, transitionEnd: function (e = !0, t) { const n = this, { params: i } = n; n.animating = !1, i.cssMode || (n.setTransition(0), Py({ swiper: n, runCallbacks: e, direction: t, step: "End" })) } }, slide: Ry, loop: Oy, grabCursor: { setGrabCursor: function (e) { const t = this; if (t.support.touch || !t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return; const n = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl; n.style.cursor = "move", n.style.cursor = e ? "-webkit-grabbing" : "-webkit-grab", n.style.cursor = e ? "-moz-grabbin" : "-moz-grab", n.style.cursor = e ? "grabbing" : "grab" }, unsetGrabCursor: function () { const e = this; e.support.touch || e.params.watchOverflow && e.isLocked || e.params.cssMode || (e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "") } }, events: Gy, breakpoints: { setBreakpoint: function () { const e = this, { activeIndex: t, initialized: n, loopedSlides: i = 0, params: r, $el: s } = e, a = r.breakpoints; if (!a || a && 0 === Object.keys(a).length) return; const o = e.getBreakpoint(a, e.params.breakpointsBase, e.el); if (!o || e.currentBreakpoint === o) return; const l = (o in a ? a[o] : void 0) || e.originalParams, c = jy(e, r), u = jy(e, l), h = r.enabled; c && !u ? (s.removeClass(`${r.containerModifierClass}grid ${r.containerModifierClass}grid-column`), e.emitContainerClasses()) : !c && u && (s.addClass(`${r.containerModifierClass}grid`), (l.grid.fill && "column" === l.grid.fill || !l.grid.fill && "column" === r.grid.fill) && s.addClass(`${r.containerModifierClass}grid-column`), e.emitContainerClasses()); const d = l.direction && l.direction !== r.direction, p = r.loop && (l.slidesPerView !== r.slidesPerView || d); d && n && e.changeDirection(), by(e.params, l); const f = e.params.enabled; Object.assign(e, { allowTouchMove: e.params.allowTouchMove, allowSlideNext: e.params.allowSlideNext, allowSlidePrev: e.params.allowSlidePrev }), h && !f ? e.disable() : !h && f && e.enable(), e.currentBreakpoint = o, e.emit("_beforeBreakpoint", l), p && n && (e.loopDestroy(), e.loopCreate(), e.updateSlides(), e.slideTo(t - i + e.loopedSlides, 0, !1)), e.emit("breakpoint", l) }, getBreakpoint: function (e, t = "window", n) { if (!e || "container" === t && !n) return; let i = !1; const r = cy(), s = "window" === t ? r.innerHeight : n.clientHeight, a = Object.keys(e).map((e => { if ("string" == typeof e && 0 === e.indexOf("@")) { const t = parseFloat(e.substr(1)); return { value: s * t, point: e } } return { value: e, point: e } })); a.sort(((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10))); for (let e = 0; e < a.length; e += 1) { const { point: s, value: o } = a[e]; "window" === t ? r.matchMedia(`(min-width: ${o}px)`).matches && (i = s) : o <= n.clientWidth && (i = s) } return i || "max" } }, checkOverflow: { checkOverflow: function () { const e = this, { isLocked: t, params: n } = e, { slidesOffsetBefore: i } = n; if (i) { const t = e.slides.length - 1, n = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * i; e.isLocked = e.size > n } else e.isLocked = 1 === e.snapGrid.length; !0 === n.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === n.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock") } }, classes: Wy, images: { loadImage: function (e, t, n, i, r, s) { const a = cy(); let o; function l() { s && s() } vy(e).parent("picture")[0] || e.complete && r ? l() : t ? (o = new a.Image, o.onload = l, o.onerror = l, i && (o.sizes = i), n && (o.srcset = n), t && (o.src = t)) : l() }, preloadImages: function () { const e = this; function t() { null != e && e && !e.destroyed && (void 0 !== e.imagesLoaded && (e.imagesLoaded += 1), e.imagesLoaded === e.imagesToLoad.length && (e.params.updateOnImagesReady && e.update(), e.emit("imagesReady"))) } e.imagesToLoad = e.$el.find("img"); for (let n = 0; n < e.imagesToLoad.length; n += 1) { const i = e.imagesToLoad[n]; e.loadImage(i, i.currentSrc || i.getAttribute("src"), i.srcset || i.getAttribute("srcset"), i.sizes || i.getAttribute("sizes"), !0, t) } } } }, Yy = {}; class Zy { constructor(...e) { let t, n; if (1 === e.length && e[0].constructor && "Object" === Object.prototype.toString.call(e[0]).slice(8, -1) ? n = e[0] : [t, n] = e, n || (n = {}), n = by({}, n), t && !n.el && (n.el = t), n.el && vy(n.el).length > 1) { const e = []; return vy(n.el).each((t => { const i = by({}, n, { el: t }); e.push(new Zy(i)) })), e } const i = this; i.__swiper__ = !0, i.support = Dy(), i.device = function (e = {}) { return Ty || (Ty = function ({ userAgent: e } = {}) { const t = Dy(), n = cy(), i = n.navigator.platform, r = e || n.navigator.userAgent, s = { ios: !1, android: !1 }, a = n.screen.width, o = n.screen.height, l = r.match(/(Android);?[\s\/]+([\d.]+)?/); let c = r.match(/(iPad).*OS\s([\d_]+)/); const u = r.match(/(iPod)(.*OS\s([\d_]+))?/), h = !c && r.match(/(iPhone\sOS|iOS)\s([\d_]+)/), d = "Win32" === i; let p = "MacIntel" === i; return !c && p && t.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${a}x${o}`) >= 0 && (c = r.match(/(Version)\/([\d.]+)/), c || (c = [0, 1, "13_0_0"]), p = !1), l && !d && (s.os = "android", s.android = !0), (c || h || u) && (s.os = "ios", s.ios = !0), s }(e)), Ty }({ userAgent: n.userAgent }), i.browser = (Cy || (Cy = function () { const e = cy(); return { isSafari: function () { const t = e.navigator.userAgent.toLowerCase(); return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0 }(), isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent) } }()), Cy), i.eventsListeners = {}, i.eventsAnyListeners = [], i.modules = [...i.__modules__], n.modules && Array.isArray(n.modules) && i.modules.push(...n.modules); const r = {}; i.modules.forEach((e => { e({ swiper: i, extendParams: $y(n, r), on: i.on.bind(i), once: i.once.bind(i), off: i.off.bind(i), emit: i.emit.bind(i) }) })); const s = by({}, qy, r); return i.params = by({}, s, Yy, n), i.originalParams = by({}, i.params), i.passedParams = by({}, n), i.params && i.params.on && Object.keys(i.params.on).forEach((e => { i.on(e, i.params.on[e]) })), i.params && i.params.onAny && i.onAny(i.params.onAny), i.$ = vy, Object.assign(i, { enabled: i.params.enabled, el: t, classNames: [], slides: vy(), slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal: () => "horizontal" === i.params.direction, isVertical: () => "vertical" === i.params.direction, activeIndex: 0, realIndex: 0, isBeginning: !0, isEnd: !1, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: !1, allowSlideNext: i.params.allowSlideNext, allowSlidePrev: i.params.allowSlidePrev, touchEvents: function () { const e = ["touchstart", "touchmove", "touchend", "touchcancel"], t = ["pointerdown", "pointermove", "pointerup"]; return i.touchEventsTouch = { start: e[0], move: e[1], end: e[2], cancel: e[3] }, i.touchEventsDesktop = { start: t[0], move: t[1], end: t[2] }, i.support.touch || !i.params.simulateTouch ? i.touchEventsTouch : i.touchEventsDesktop }(), touchEventsData: { isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, focusableElements: i.params.focusableElements, lastClickTime: xy(), clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, isTouchEvent: void 0, startMoving: void 0 }, allowClick: !0, allowTouchMove: i.params.allowTouchMove, touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }, imagesToLoad: [], imagesLoaded: 0 }), i.emit("_swiper"), i.params.init && i.init(), i } enable() { const e = this; e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable")) } disable() { const e = this; e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable")) } setProgress(e, t) { const n = this; e = Math.min(Math.max(e, 0), 1); const i = n.minTranslate(), r = (n.maxTranslate() - i) * e + i; n.translateTo(r, void 0 === t ? 0 : t), n.updateActiveIndex(), n.updateSlidesClasses() } emitContainerClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = e.el.className.split(" ").filter((t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass))); e.emit("_containerClasses", t.join(" ")) } getSlideClasses(e) { const t = this; return e.className.split(" ").filter((e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass))).join(" ") } emitSlidesClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = []; e.slides.each((n => { const i = e.getSlideClasses(n); t.push({ slideEl: n, classNames: i }), e.emit("_slideClass", n, i) })), e.emit("_slideClasses", t) } slidesPerViewDynamic(e = "current", t = !1) { const { params: n, slides: i, slidesGrid: r, slidesSizesGrid: s, size: a, activeIndex: o } = this; let l = 1; if (n.centeredSlides) { let e, t = i[o].swiperSlideSize; for (let n = o + 1; n < i.length; n += 1)i[n] && !e && (t += i[n].swiperSlideSize, l += 1, t > a && (e = !0)); for (let n = o - 1; n >= 0; n -= 1)i[n] && !e && (t += i[n].swiperSlideSize, l += 1, t > a && (e = !0)) } else if ("current" === e) for (let e = o + 1; e < i.length; e += 1)(t ? r[e] + s[e] - r[o] < a : r[e] - r[o] < a) && (l += 1); else for (let e = o - 1; e >= 0; e -= 1)r[o] - r[e] < a && (l += 1); return l } update() { const e = this; if (!e || e.destroyed) return; const { snapGrid: t, params: n } = e; function i() { const t = e.rtlTranslate ? -1 * e.translate : e.translate, n = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate()); e.setTranslate(n), e.updateActiveIndex(), e.updateSlidesClasses() } let r; n.breakpoints && e.setBreakpoint(), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.params.freeMode && e.params.freeMode.enabled ? (i(), e.params.autoHeight && e.updateAutoHeight()) : (r = ("auto" === e.params.slidesPerView || e.params.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), r || i()), n.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update") } changeDirection(e, t = !0) { const n = this, i = n.params.direction; return e || (e = "horizontal" === i ? "vertical" : "horizontal"), e === i || "horizontal" !== e && "vertical" !== e || (n.$el.removeClass(`${n.params.containerModifierClass}${i}`).addClass(`${n.params.containerModifierClass}${e}`), n.emitContainerClasses(), n.params.direction = e, n.slides.each((t => { "vertical" === e ? t.style.width = "" : t.style.height = "" })), n.emit("changeDirection"), t && n.update()), n } mount(e) { const t = this; if (t.mounted) return !0; const n = vy(e || t.params.el); if (!(e = n[0])) return !1; e.swiper = t; const i = () => `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`; let r = (() => { if (e && e.shadowRoot && e.shadowRoot.querySelector) { const t = vy(e.shadowRoot.querySelector(i())); return t.children = e => n.children(e), t } return n.children(i()) })(); if (0 === r.length && t.params.createElements) { const e = oy().createElement("div"); r = vy(e), e.className = t.params.wrapperClass, n.append(e), n.children(`.${t.params.slideClass}`).each((e => { r.append(e) })) } return Object.assign(t, { $el: n, el: e, $wrapperEl: r, wrapperEl: r[0], mounted: !0, rtl: "rtl" === e.dir.toLowerCase() || "rtl" === n.css("direction"), rtlTranslate: "horizontal" === t.params.direction && ("rtl" === e.dir.toLowerCase() || "rtl" === n.css("direction")), wrongRTL: "-webkit-box" === r.css("display") }), !0 } init(e) { const t = this; return t.initialized || !1 === t.mount(e) || (t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.params.loop && t.loopCreate(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.preloadImages && t.preloadImages(), t.params.loop ? t.slideTo(t.params.initialSlide + t.loopedSlides, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.attachEvents(), t.initialized = !0, t.emit("init"), t.emit("afterInit")), t } destroy(e = !0, t = !0) { const n = this, { params: i, $el: r, $wrapperEl: s, slides: a } = n; return void 0 === n.params || n.destroyed || (n.emit("beforeDestroy"), n.initialized = !1, n.detachEvents(), i.loop && n.loopDestroy(), t && (n.removeClasses(), r.removeAttr("style"), s.removeAttr("style"), a && a.length && a.removeClass([i.slideVisibleClass, i.slideActiveClass, i.slideNextClass, i.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")), n.emit("destroy"), Object.keys(n.eventsListeners).forEach((e => { n.off(e) })), !1 !== e && (n.$el[0].swiper = null, function (e) { const t = e; Object.keys(t).forEach((e => { try { t[e] = null } catch (e) { } try { delete t[e] } catch (e) { } })) }(n)), n.destroyed = !0), null } static extendDefaults(e) { by(Yy, e) } static get extendedDefaults() { return Yy } static get defaults() { return qy } static installModule(e) { Zy.prototype.__modules__ || (Zy.prototype.__modules__ = []); const t = Zy.prototype.__modules__; "function" == typeof e && t.indexOf(e) < 0 && t.push(e) } static use(e) { return Array.isArray(e) ? (e.forEach((e => Zy.installModule(e))), Zy) : (Zy.installModule(e), Zy) } } Object.keys(Xy).forEach((e => { Object.keys(Xy[e]).forEach((t => { Zy.prototype[t] = Xy[e][t] })) })), Zy.use([function ({ swiper: e, on: t, emit: n }) { const i = cy(); let r = null; const s = () => { e && !e.destroyed && e.initialized && (n("beforeResize"), n("resize")) }, a = () => { e && !e.destroyed && e.initialized && n("orientationchange") }; t("init", (() => { e.params.resizeObserver && void 0 !== i.ResizeObserver ? e && !e.destroyed && e.initialized && (r = new ResizeObserver((t => { const { width: n, height: i } = e; let r = n, a = i; t.forEach((({ contentBoxSize: t, contentRect: n, target: i }) => { i && i !== e.el || (r = n ? n.width : (t[0] || t).inlineSize, a = n ? n.height : (t[0] || t).blockSize) })), r === n && a === i || s() })), r.observe(e.el)) : (i.addEventListener("resize", s), i.addEventListener("orientationchange", a)) })), t("destroy", (() => { r && r.unobserve && e.el && (r.unobserve(e.el), r = null), i.removeEventListener("resize", s), i.removeEventListener("orientationchange", a) })) }, function ({ swiper: e, extendParams: t, on: n, emit: i }) { const r = [], s = cy(), a = (e, t = {}) => { const n = new (s.MutationObserver || s.WebkitMutationObserver)((e => { if (1 === e.length) return void i("observerUpdate", e[0]); const t = function () { i("observerUpdate", e[0]) }; s.requestAnimationFrame ? s.requestAnimationFrame(t) : s.setTimeout(t, 0) })); n.observe(e, { attributes: void 0 === t.attributes || t.attributes, childList: void 0 === t.childList || t.childList, characterData: void 0 === t.characterData || t.characterData }), r.push(n) }; t({ observer: !1, observeParents: !1, observeSlideChildren: !1 }), n("init", (() => { if (e.params.observer) { if (e.params.observeParents) { const t = e.$el.parents(); for (let e = 0; e < t.length; e += 1)a(t[e]) } a(e.$el[0], { childList: e.params.observeSlideChildren }), a(e.$wrapperEl[0], { attributes: !1 }) } })), n("destroy", (() => { r.forEach((e => { e.disconnect() })), r.splice(0, r.length) })) }]); const Ky = Zy; function Jy(e, t, n, i) { const r = oy(); return e.params.createElements && Object.keys(i).forEach((s => { if (!n[s] && !0 === n.auto) { let a = e.$el.children(`.${i[s]}`)[0]; a || (a = r.createElement("div"), a.className = i[s], e.$el.append(a)), n[s] = a, t[s] = a } })), n } function Qy(e = "") { return `.${e.trim().replace(/([\.:!\/])/g, "\\$1").replace(/ /g, ".")}` } function ex(e) { const t = this, { $wrapperEl: n, params: i } = t; if (i.loop && t.loopDestroy(), "object" == typeof e && "length" in e) for (let t = 0; t < e.length; t += 1)e[t] && n.append(e[t]); else n.append(e); i.loop && t.loopCreate(), i.observer || t.update() } function tx(e) { const t = this, { params: n, $wrapperEl: i, activeIndex: r } = t; n.loop && t.loopDestroy(); let s = r + 1; if ("object" == typeof e && "length" in e) { for (let t = 0; t < e.length; t += 1)e[t] && i.prepend(e[t]); s = r + e.length } else i.prepend(e); n.loop && t.loopCreate(), n.observer || t.update(), t.slideTo(s, 0, !1) } function nx(e, t) { const n = this, { $wrapperEl: i, params: r, activeIndex: s } = n; let a = s; r.loop && (a -= n.loopedSlides, n.loopDestroy(), n.slides = i.children(`.${r.slideClass}`)); const o = n.slides.length; if (e <= 0) return void n.prependSlide(t); if (e >= o) return void n.appendSlide(t); let l = a > e ? a + 1 : a; const c = []; for (let t = o - 1; t >= e; t -= 1) { const e = n.slides.eq(t); e.remove(), c.unshift(e) } if ("object" == typeof t && "length" in t) { for (let e = 0; e < t.length; e += 1)t[e] && i.append(t[e]); l = a > e ? a + t.length : a } else i.append(t); for (let e = 0; e < c.length; e += 1)i.append(c[e]); r.loop && n.loopCreate(), r.observer || n.update(), r.loop ? n.slideTo(l + n.loopedSlides, 0, !1) : n.slideTo(l, 0, !1) } function ix(e) { const t = this, { params: n, $wrapperEl: i, activeIndex: r } = t; let s = r; n.loop && (s -= t.loopedSlides, t.loopDestroy(), t.slides = i.children(`.${n.slideClass}`)); let a, o = s; if ("object" == typeof e && "length" in e) { for (let n = 0; n < e.length; n += 1)a = e[n], t.slides[a] && t.slides.eq(a).remove(), a < o && (o -= 1); o = Math.max(o, 0) } else a = e, t.slides[a] && t.slides.eq(a).remove(), a < o && (o -= 1), o = Math.max(o, 0); n.loop && t.loopCreate(), n.observer || t.update(), n.loop ? t.slideTo(o + t.loopedSlides, 0, !1) : t.slideTo(o, 0, !1) } function rx() { const e = this, t = []; for (let n = 0; n < e.slides.length; n += 1)t.push(n); e.removeSlide(t) } function sx(e) { const { effect: t, swiper: n, on: i, setTranslate: r, setTransition: s, overwriteParams: a, perspective: o } = e; i("beforeInit", (() => { if (n.params.effect !== t) return; n.classNames.push(`${n.params.containerModifierClass}${t}`), o && o() && n.classNames.push(`${n.params.containerModifierClass}3d`); const e = a ? a() : {}; Object.assign(n.params, e), Object.assign(n.originalParams, e) })), i("setTranslate", (() => { n.params.effect === t && r() })), i("setTransition", ((e, i) => { n.params.effect === t && s(i) })) } function ax(e, t) { return e.transformEl ? t.find(e.transformEl).css({ "backface-visibility": "hidden", "-webkit-backface-visibility": "hidden" }) : t } function ox({ swiper: e, duration: t, transformEl: n, allSlides: i }) { const { slides: r, activeIndex: s, $wrapperEl: a } = e; if (e.params.virtualTranslate && 0 !== t) { let t, o = !1; t = i ? n ? r.find(n) : r : n ? r.eq(s).find(n) : r.eq(s), t.transitionEnd((() => { if (o) return; if (!e || e.destroyed) return; o = !0, e.animating = !1; const t = ["webkitTransitionEnd", "transitionend"]; for (let e = 0; e < t.length; e += 1)a.trigger(t[e]) })) } } function lx(e, t, n) { const i = "swiper-slide-shadow" + (n ? `-${n}` : ""), r = e.transformEl ? t.find(e.transformEl) : t; let s = r.children(`.${i}`); return s.length || (s = vy(`<div class="swiper-slide-shadow${n ? `-${n}` : ""}"></div>`), r.append(s)), s } const cx = [function ({ swiper: e, extendParams: t, on: n }) { let i; function r(t, n) { const i = e.params.virtual; if (i.cache && e.virtual.cache[n]) return e.virtual.cache[n]; const r = i.renderSlide ? vy(i.renderSlide.call(e, t, n)) : vy(`<div class="${e.params.slideClass}" data-swiper-slide-index="${n}">${t}</div>`); return r.attr("data-swiper-slide-index") || r.attr("data-swiper-slide-index", n), i.cache && (e.virtual.cache[n] = r), r } function s(t) { const { slidesPerView: n, slidesPerGroup: i, centeredSlides: s } = e.params, { addSlidesBefore: a, addSlidesAfter: o } = e.params.virtual, { from: l, to: c, slides: u, slidesGrid: h, offset: d } = e.virtual; e.params.cssMode || e.updateActiveIndex(); const p = e.activeIndex || 0; let f, m, g; f = e.rtlTranslate ? "right" : e.isHorizontal() ? "left" : "top", s ? (m = Math.floor(n / 2) + i + o, g = Math.floor(n / 2) + i + a) : (m = n + (i - 1) + o, g = i + a); const v = Math.max((p || 0) - g, 0), y = Math.min((p || 0) + m, u.length - 1), x = (e.slidesGrid[v] || 0) - (e.slidesGrid[0] || 0); function _() { e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.lazy && e.params.lazy.enabled && e.lazy.load() } if (Object.assign(e.virtual, { from: v, to: y, offset: x, slidesGrid: e.slidesGrid }), l === v && c === y && !t) return e.slidesGrid !== h && x !== d && e.slides.css(f, `${x}px`), void e.updateProgress(); if (e.params.virtual.renderExternal) return e.params.virtual.renderExternal.call(e, { offset: x, from: v, to: y, slides: function () { const e = []; for (let t = v; t <= y; t += 1)e.push(u[t]); return e }() }), void (e.params.virtual.renderExternalUpdate && _()); const w = [], b = []; if (t) e.$wrapperEl.find(`.${e.params.slideClass}`).remove(); else for (let t = l; t <= c; t += 1)(t < v || t > y) && e.$wrapperEl.find(`.${e.params.slideClass}[data-swiper-slide-index="${t}"]`).remove(); for (let e = 0; e < u.length; e += 1)e >= v && e <= y && (void 0 === c || t ? b.push(e) : (e > c && b.push(e), e < l && w.push(e))); b.forEach((t => { e.$wrapperEl.append(r(u[t], t)) })), w.sort(((e, t) => t - e)).forEach((t => { e.$wrapperEl.prepend(r(u[t], t)) })), e.$wrapperEl.children(".swiper-slide").css(f, `${x}px`), _() } t({ virtual: { enabled: !1, slides: [], cache: !0, renderSlide: null, renderExternal: null, renderExternalUpdate: !0, addSlidesBefore: 0, addSlidesAfter: 0 } }), e.virtual = { cache: {}, from: void 0, to: void 0, slides: [], offset: 0, slidesGrid: [] }, n("beforeInit", (() => { e.params.virtual.enabled && (e.virtual.slides = e.params.virtual.slides, e.classNames.push(`${e.params.containerModifierClass}virtual`), e.params.watchSlidesProgress = !0, e.originalParams.watchSlidesProgress = !0, e.params.initialSlide || s()) })), n("setTranslate", (() => { e.params.virtual.enabled && (e.params.cssMode && !e._immediateVirtual ? (clearTimeout(i), i = setTimeout((() => { s() }), 100)) : s()) })), n("init update resize", (() => { e.params.virtual.enabled && e.params.cssMode && Sy(e.wrapperEl, "--swiper-virtual-size", `${e.virtualSize}px`) })), Object.assign(e.virtual, { appendSlide: function (t) { if ("object" == typeof t && "length" in t) for (let n = 0; n < t.length; n += 1)t[n] && e.virtual.slides.push(t[n]); else e.virtual.slides.push(t); s(!0) }, prependSlide: function (t) { const n = e.activeIndex; let i = n + 1, r = 1; if (Array.isArray(t)) { for (let n = 0; n < t.length; n += 1)t[n] && e.virtual.slides.unshift(t[n]); i = n + t.length, r = t.length } else e.virtual.slides.unshift(t); if (e.params.virtual.cache) { const t = e.virtual.cache, n = {}; Object.keys(t).forEach((e => { const i = t[e], s = i.attr("data-swiper-slide-index"); s && i.attr("data-swiper-slide-index", parseInt(s, 10) + r), n[parseInt(e, 10) + r] = i })), e.virtual.cache = n } s(!0), e.slideTo(i, 0) }, removeSlide: function (t) { if (null == t) return; let n = e.activeIndex; if (Array.isArray(t)) for (let i = t.length - 1; i >= 0; i -= 1)e.virtual.slides.splice(t[i], 1), e.params.virtual.cache && delete e.virtual.cache[t[i]], t[i] < n && (n -= 1), n = Math.max(n, 0); else e.virtual.slides.splice(t, 1), e.params.virtual.cache && delete e.virtual.cache[t], t < n && (n -= 1), n = Math.max(n, 0); s(!0), e.slideTo(n, 0) }, removeAllSlides: function () { e.virtual.slides = [], e.params.virtual.cache && (e.virtual.cache = {}), s(!0), e.slideTo(0, 0) }, update: s }) }, function ({ swiper: e, extendParams: t, on: n, emit: i }) { const r = oy(), s = cy(); function a(t) { if (!e.enabled) return; const { rtlTranslate: n } = e; let a = t; a.originalEvent && (a = a.originalEvent); const o = a.keyCode || a.charCode, l = e.params.keyboard.pageUpDown, c = l && 33 === o, u = l && 34 === o, h = 37 === o, d = 39 === o, p = 38 === o, f = 40 === o; if (!e.allowSlideNext && (e.isHorizontal() && d || e.isVertical() && f || u)) return !1; if (!e.allowSlidePrev && (e.isHorizontal() && h || e.isVertical() && p || c)) return !1; if (!(a.shiftKey || a.altKey || a.ctrlKey || a.metaKey || r.activeElement && r.activeElement.nodeName && ("input" === r.activeElement.nodeName.toLowerCase() || "textarea" === r.activeElement.nodeName.toLowerCase()))) { if (e.params.keyboard.onlyInViewport && (c || u || h || d || p || f)) { let t = !1; if (e.$el.parents(`.${e.params.slideClass}`).length > 0 && 0 === e.$el.parents(`.${e.params.slideActiveClass}`).length) return; const i = e.$el, r = i[0].clientWidth, a = i[0].clientHeight, o = s.innerWidth, l = s.innerHeight, c = e.$el.offset(); n && (c.left -= e.$el[0].scrollLeft); const u = [[c.left, c.top], [c.left + r, c.top], [c.left, c.top + a], [c.left + r, c.top + a]]; for (let e = 0; e < u.length; e += 1) { const n = u[e]; if (n[0] >= 0 && n[0] <= o && n[1] >= 0 && n[1] <= l) { if (0 === n[0] && 0 === n[1]) continue; t = !0 } } if (!t) return } e.isHorizontal() ? ((c || u || h || d) && (a.preventDefault ? a.preventDefault() : a.returnValue = !1), ((u || d) && !n || (c || h) && n) && e.slideNext(), ((c || h) && !n || (u || d) && n) && e.slidePrev()) : ((c || u || p || f) && (a.preventDefault ? a.preventDefault() : a.returnValue = !1), (u || f) && e.slideNext(), (c || p) && e.slidePrev()), i("keyPress", o) } } function o() { e.keyboard.enabled || (vy(r).on("keydown", a), e.keyboard.enabled = !0) } function l() { e.keyboard.enabled && (vy(r).off("keydown", a), e.keyboard.enabled = !1) } e.keyboard = { enabled: !1 }, t({ keyboard: { enabled: !1, onlyInViewport: !0, pageUpDown: !0 } }), n("init", (() => { e.params.keyboard.enabled && o() })), n("destroy", (() => { e.keyboard.enabled && l() })), Object.assign(e.keyboard, { enable: o, disable: l }) }, function ({ swiper: e, extendParams: t, on: n, emit: i }) { const r = cy(); let s; t({ mousewheel: { enabled: !1, releaseOnEdges: !1, invert: !1, forceToAxis: !1, sensitivity: 1, eventsTarget: "container", thresholdDelta: null, thresholdTime: null } }), e.mousewheel = { enabled: !1 }; let a, o = xy(); const l = []; function c() { e.enabled && (e.mouseEntered = !0) } function u() { e.enabled && (e.mouseEntered = !1) } function h(t) { return !(e.params.mousewheel.thresholdDelta && t.delta < e.params.mousewheel.thresholdDelta || e.params.mousewheel.thresholdTime && xy() - o < e.params.mousewheel.thresholdTime || !(t.delta >= 6 && xy() - o < 60) && (t.direction < 0 ? e.isEnd && !e.params.loop || e.animating || (e.slideNext(), i("scroll", t.raw)) : e.isBeginning && !e.params.loop || e.animating || (e.slidePrev(), i("scroll", t.raw)), o = (new r.Date).getTime(), 1)) } function d(t) { let n = t, r = !0; if (!e.enabled) return; const o = e.params.mousewheel; e.params.cssMode && n.preventDefault(); let c = e.$el; if ("container" !== e.params.mousewheel.eventsTarget && (c = vy(e.params.mousewheel.eventsTarget)), !e.mouseEntered && !c[0].contains(n.target) && !o.releaseOnEdges) return !0; n.originalEvent && (n = n.originalEvent); let u = 0; const d = e.rtlTranslate ? -1 : 1, p = function (e) { let t = 0, n = 0, i = 0, r = 0; return "detail" in e && (n = e.detail), "wheelDelta" in e && (n = -e.wheelDelta / 120), "wheelDeltaY" in e && (n = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (t = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (t = n, n = 0), i = 10 * t, r = 10 * n, "deltaY" in e && (r = e.deltaY), "deltaX" in e && (i = e.deltaX), e.shiftKey && !i && (i = r, r = 0), (i || r) && e.deltaMode && (1 === e.deltaMode ? (i *= 40, r *= 40) : (i *= 800, r *= 800)), i && !t && (t = i < 1 ? -1 : 1), r && !n && (n = r < 1 ? -1 : 1), { spinX: t, spinY: n, pixelX: i, pixelY: r } }(n); if (o.forceToAxis) if (e.isHorizontal()) { if (!(Math.abs(p.pixelX) > Math.abs(p.pixelY))) return !0; u = -p.pixelX * d } else { if (!(Math.abs(p.pixelY) > Math.abs(p.pixelX))) return !0; u = -p.pixelY } else u = Math.abs(p.pixelX) > Math.abs(p.pixelY) ? -p.pixelX * d : -p.pixelY; if (0 === u) return !0; o.invert && (u = -u); let f = e.getTranslate() + u * o.sensitivity; if (f >= e.minTranslate() && (f = e.minTranslate()), f <= e.maxTranslate() && (f = e.maxTranslate()), r = !!e.params.loop || !(f === e.minTranslate() || f === e.maxTranslate()), r && e.params.nested && n.stopPropagation(), e.params.freeMode && e.params.freeMode.enabled) { const t = { time: xy(), delta: Math.abs(u), direction: Math.sign(u) }, r = a && t.time < a.time + 500 && t.delta <= a.delta && t.direction === a.direction; if (!r) { a = void 0, e.params.loop && e.loopFix(); let c = e.getTranslate() + u * o.sensitivity; const h = e.isBeginning, d = e.isEnd; if (c >= e.minTranslate() && (c = e.minTranslate()), c <= e.maxTranslate() && (c = e.maxTranslate()), e.setTransition(0), e.setTranslate(c), e.updateProgress(), e.updateActiveIndex(), e.updateSlidesClasses(), (!h && e.isBeginning || !d && e.isEnd) && e.updateSlidesClasses(), e.params.freeMode.sticky) { clearTimeout(s), s = void 0, l.length >= 15 && l.shift(); const n = l.length ? l[l.length - 1] : void 0, i = l[0]; if (l.push(t), n && (t.delta > n.delta || t.direction !== n.direction)) l.splice(0); else if (l.length >= 15 && t.time - i.time < 500 && i.delta - t.delta >= 1 && t.delta <= 6) { const n = u > 0 ? .8 : .2; a = t, l.splice(0), s = yy((() => { e.slideToClosest(e.params.speed, !0, void 0, n) }), 0) } s || (s = yy((() => { a = t, l.splice(0), e.slideToClosest(e.params.speed, !0, void 0, .5) }), 500)) } if (r || i("scroll", n), e.params.autoplay && e.params.autoplayDisableOnInteraction && e.autoplay.stop(), c === e.minTranslate() || c === e.maxTranslate()) return !0 } } else { const n = { time: xy(), delta: Math.abs(u), direction: Math.sign(u), raw: t }; l.length >= 2 && l.shift(); const i = l.length ? l[l.length - 1] : void 0; if (l.push(n), i ? (n.direction !== i.direction || n.delta > i.delta || n.time > i.time + 150) && h(n) : h(n), function (t) { const n = e.params.mousewheel; if (t.direction < 0) { if (e.isEnd && !e.params.loop && n.releaseOnEdges) return !0 } else if (e.isBeginning && !e.params.loop && n.releaseOnEdges) return !0; return !1 }(n)) return !0 } return n.preventDefault ? n.preventDefault() : n.returnValue = !1, !1 } function p(t) { let n = e.$el; "container" !== e.params.mousewheel.eventsTarget && (n = vy(e.params.mousewheel.eventsTarget)), n[t]("mouseenter", c), n[t]("mouseleave", u), n[t]("wheel", d) } function f() { return e.params.cssMode ? (e.wrapperEl.removeEventListener("wheel", d), !0) : !e.mousewheel.enabled && (p("on"), e.mousewheel.enabled = !0, !0) } function m() { return e.params.cssMode ? (e.wrapperEl.addEventListener(event, d), !0) : !!e.mousewheel.enabled && (p("off"), e.mousewheel.enabled = !1, !0) } n("init", (() => { !e.params.mousewheel.enabled && e.params.cssMode && m(), e.params.mousewheel.enabled && f() })), n("destroy", (() => { e.params.cssMode && f(), e.mousewheel.enabled && m() })), Object.assign(e.mousewheel, { enable: f, disable: m }) }, function ({ swiper: e, extendParams: t, on: n, emit: i }) { function r(t) { let n; return t && (n = vy(t), e.params.uniqueNavElements && "string" == typeof t && n.length > 1 && 1 === e.$el.find(t).length && (n = e.$el.find(t))), n } function s(t, n) { const i = e.params.navigation; t && t.length > 0 && (t[n ? "addClass" : "removeClass"](i.disabledClass), t[0] && "BUTTON" === t[0].tagName && (t[0].disabled = n), e.params.watchOverflow && e.enabled && t[e.isLocked ? "addClass" : "removeClass"](i.lockClass)) } function a() { if (e.params.loop) return; const { $nextEl: t, $prevEl: n } = e.navigation; s(n, e.isBeginning && !e.params.rewind), s(t, e.isEnd && !e.params.rewind) } function o(t) { t.preventDefault(), (!e.isBeginning || e.params.loop || e.params.rewind) && e.slidePrev() } function l(t) { t.preventDefault(), (!e.isEnd || e.params.loop || e.params.rewind) && e.slideNext() } function c() { const t = e.params.navigation; if (e.params.navigation = Jy(e, e.originalParams.navigation, e.params.navigation, { nextEl: "swiper-button-next", prevEl: "swiper-button-prev" }), !t.nextEl && !t.prevEl) return; const n = r(t.nextEl), i = r(t.prevEl); n && n.length > 0 && n.on("click", l), i && i.length > 0 && i.on("click", o), Object.assign(e.navigation, { $nextEl: n, nextEl: n && n[0], $prevEl: i, prevEl: i && i[0] }), e.enabled || (n && n.addClass(t.lockClass), i && i.addClass(t.lockClass)) } function u() { const { $nextEl: t, $prevEl: n } = e.navigation; t && t.length && (t.off("click", l), t.removeClass(e.params.navigation.disabledClass)), n && n.length && (n.off("click", o), n.removeClass(e.params.navigation.disabledClass)) } t({ navigation: { nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: "swiper-button-disabled", hiddenClass: "swiper-button-hidden", lockClass: "swiper-button-lock" } }), e.navigation = { nextEl: null, $nextEl: null, prevEl: null, $prevEl: null }, n("init", (() => { c(), a() })), n("toEdge fromEdge lock unlock", (() => { a() })), n("destroy", (() => { u() })), n("enable disable", (() => { const { $nextEl: t, $prevEl: n } = e.navigation; t && t[e.enabled ? "removeClass" : "addClass"](e.params.navigation.lockClass), n && n[e.enabled ? "removeClass" : "addClass"](e.params.navigation.lockClass) })), n("click", ((t, n) => { const { $nextEl: r, $prevEl: s } = e.navigation, a = n.target; if (e.params.navigation.hideOnClick && !vy(a).is(s) && !vy(a).is(r)) { if (e.pagination && e.params.pagination && e.params.pagination.clickable && (e.pagination.el === a || e.pagination.el.contains(a))) return; let t; r ? t = r.hasClass(e.params.navigation.hiddenClass) : s && (t = s.hasClass(e.params.navigation.hiddenClass)), i(!0 === t ? "navigationShow" : "navigationHide"), r && r.toggleClass(e.params.navigation.hiddenClass), s && s.toggleClass(e.params.navigation.hiddenClass) } })), Object.assign(e.navigation, { update: a, init: c, destroy: u }) }, function ({ swiper: e, extendParams: t, on: n, emit: i }) { const r = "swiper-pagination"; let s; t({ pagination: { el: null, bulletElement: "span", clickable: !1, hideOnClick: !1, renderBullet: null, renderProgressbar: null, renderFraction: null, renderCustom: null, progressbarOpposite: !1, type: "bullets", dynamicBullets: !1, dynamicMainBullets: 1, formatFractionCurrent: e => e, formatFractionTotal: e => e, bulletClass: `${r}-bullet`, bulletActiveClass: `${r}-bullet-active`, modifierClass: `${r}-`, currentClass: `${r}-current`, totalClass: `${r}-total`, hiddenClass: `${r}-hidden`, progressbarFillClass: `${r}-progressbar-fill`, progressbarOppositeClass: `${r}-progressbar-opposite`, clickableClass: `${r}-clickable`, lockClass: `${r}-lock`, horizontalClass: `${r}-horizontal`, verticalClass: `${r}-vertical` } }), e.pagination = { el: null, $el: null, bullets: [] }; let a = 0; function o() { return !e.params.pagination.el || !e.pagination.el || !e.pagination.$el || 0 === e.pagination.$el.length } function l(t, n) { const { bulletActiveClass: i } = e.params.pagination; t[n]().addClass(`${i}-${n}`)[n]().addClass(`${i}-${n}-${n}`) } function c() { const t = e.rtl, n = e.params.pagination; if (o()) return; const r = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length, c = e.pagination.$el; let u; const h = e.params.loop ? Math.ceil((r - 2 * e.loopedSlides) / e.params.slidesPerGroup) : e.snapGrid.length; if (e.params.loop ? (u = Math.ceil((e.activeIndex - e.loopedSlides) / e.params.slidesPerGroup), u > r - 1 - 2 * e.loopedSlides && (u -= r - 2 * e.loopedSlides), u > h - 1 && (u -= h), u < 0 && "bullets" !== e.params.paginationType && (u = h + u)) : u = void 0 !== e.snapIndex ? e.snapIndex : e.activeIndex || 0, "bullets" === n.type && e.pagination.bullets && e.pagination.bullets.length > 0) { const i = e.pagination.bullets; let r, o, h; if (n.dynamicBullets && (s = i.eq(0)[e.isHorizontal() ? "outerWidth" : "outerHeight"](!0), c.css(e.isHorizontal() ? "width" : "height", s * (n.dynamicMainBullets + 4) + "px"), n.dynamicMainBullets > 1 && void 0 !== e.previousIndex && (a += u - (e.previousIndex - e.loopedSlides || 0), a > n.dynamicMainBullets - 1 ? a = n.dynamicMainBullets - 1 : a < 0 && (a = 0)), r = Math.max(u - a, 0), o = r + (Math.min(i.length, n.dynamicMainBullets) - 1), h = (o + r) / 2), i.removeClass(["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((e => `${n.bulletActiveClass}${e}`)).join(" ")), c.length > 1) i.each((e => { const t = vy(e), i = t.index(); i === u && t.addClass(n.bulletActiveClass), n.dynamicBullets && (i >= r && i <= o && t.addClass(`${n.bulletActiveClass}-main`), i === r && l(t, "prev"), i === o && l(t, "next")) })); else { const t = i.eq(u), s = t.index(); if (t.addClass(n.bulletActiveClass), n.dynamicBullets) { const t = i.eq(r), a = i.eq(o); for (let e = r; e <= o; e += 1)i.eq(e).addClass(`${n.bulletActiveClass}-main`); if (e.params.loop) if (s >= i.length) { for (let e = n.dynamicMainBullets; e >= 0; e -= 1)i.eq(i.length - e).addClass(`${n.bulletActiveClass}-main`); i.eq(i.length - n.dynamicMainBullets - 1).addClass(`${n.bulletActiveClass}-prev`) } else l(t, "prev"), l(a, "next"); else l(t, "prev"), l(a, "next") } } if (n.dynamicBullets) { const r = Math.min(i.length, n.dynamicMainBullets + 4), a = (s * r - s) / 2 - h * s, o = t ? "right" : "left"; i.css(e.isHorizontal() ? o : "top", `${a}px`) } } if ("fraction" === n.type && (c.find(Qy(n.currentClass)).text(n.formatFractionCurrent(u + 1)), c.find(Qy(n.totalClass)).text(n.formatFractionTotal(h))), "progressbar" === n.type) { let t; t = n.progressbarOpposite ? e.isHorizontal() ? "vertical" : "horizontal" : e.isHorizontal() ? "horizontal" : "vertical"; const i = (u + 1) / h; let r = 1, s = 1; "horizontal" === t ? r = i : s = i, c.find(Qy(n.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${r}) scaleY(${s})`).transition(e.params.speed) } "custom" === n.type && n.renderCustom ? (c.html(n.renderCustom(e, u + 1, h)), i("paginationRender", c[0])) : i("paginationUpdate", c[0]), e.params.watchOverflow && e.enabled && c[e.isLocked ? "addClass" : "removeClass"](n.lockClass) } function u() { const t = e.params.pagination; if (o()) return; const n = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length, r = e.pagination.$el; let s = ""; if ("bullets" === t.type) { let i = e.params.loop ? Math.ceil((n - 2 * e.loopedSlides) / e.params.slidesPerGroup) : e.snapGrid.length; e.params.freeMode && e.params.freeMode.enabled && !e.params.loop && i > n && (i = n); for (let n = 0; n < i; n += 1)t.renderBullet ? s += t.renderBullet.call(e, n, t.bulletClass) : s += `<${t.bulletElement} class="${t.bulletClass}"></${t.bulletElement}>`; r.html(s), e.pagination.bullets = r.find(Qy(t.bulletClass)) } "fraction" === t.type && (s = t.renderFraction ? t.renderFraction.call(e, t.currentClass, t.totalClass) : `<span class="${t.currentClass}"></span> / <span class="${t.totalClass}"></span>`, r.html(s)), "progressbar" === t.type && (s = t.renderProgressbar ? t.renderProgressbar.call(e, t.progressbarFillClass) : `<span class="${t.progressbarFillClass}"></span>`, r.html(s)), "custom" !== t.type && i("paginationRender", e.pagination.$el[0]) } function h() { e.params.pagination = Jy(e, e.originalParams.pagination, e.params.pagination, { el: "swiper-pagination" }); const t = e.params.pagination; if (!t.el) return; let n = vy(t.el); 0 !== n.length && (e.params.uniqueNavElements && "string" == typeof t.el && n.length > 1 && (n = e.$el.find(t.el), n.length > 1 && (n = n.filter((t => vy(t).parents(".swiper")[0] === e.el)))), "bullets" === t.type && t.clickable && n.addClass(t.clickableClass), n.addClass(t.modifierClass + t.type), n.addClass(t.modifierClass + e.params.direction), "bullets" === t.type && t.dynamicBullets && (n.addClass(`${t.modifierClass}${t.type}-dynamic`), a = 0, t.dynamicMainBullets < 1 && (t.dynamicMainBullets = 1)), "progressbar" === t.type && t.progressbarOpposite && n.addClass(t.progressbarOppositeClass), t.clickable && n.on("click", Qy(t.bulletClass), (function (t) { t.preventDefault(); let n = vy(this).index() * e.params.slidesPerGroup; e.params.loop && (n += e.loopedSlides), e.slideTo(n) })), Object.assign(e.pagination, { $el: n, el: n[0] }), e.enabled || n.addClass(t.lockClass)) } function d() { const t = e.params.pagination; if (o()) return; const n = e.pagination.$el; n.removeClass(t.hiddenClass), n.removeClass(t.modifierClass + t.type), n.removeClass(t.modifierClass + e.params.direction), e.pagination.bullets && e.pagination.bullets.removeClass && e.pagination.bullets.removeClass(t.bulletActiveClass), t.clickable && n.off("click", Qy(t.bulletClass)) } n("init", (() => { h(), u(), c() })), n("activeIndexChange", (() => { (e.params.loop || void 0 === e.snapIndex) && c() })), n("snapIndexChange", (() => { e.params.loop || c() })), n("slidesLengthChange", (() => { e.params.loop && (u(), c()) })), n("snapGridLengthChange", (() => { e.params.loop || (u(), c()) })), n("destroy", (() => { d() })), n("enable disable", (() => { const { $el: t } = e.pagination; t && t[e.enabled ? "removeClass" : "addClass"](e.params.pagination.lockClass) })), n("lock unlock", (() => { c() })), n("click", ((t, n) => { const r = n.target, { $el: s } = e.pagination; if (e.params.pagination.el && e.params.pagination.hideOnClick && s.length > 0 && !vy(r).hasClass(e.params.pagination.bulletClass)) { if (e.navigation && (e.navigation.nextEl && r === e.navigation.nextEl || e.navigation.prevEl && r === e.navigation.prevEl)) return; const t = s.hasClass(e.params.pagination.hiddenClass); i(!0 === t ? "paginationShow" : "paginationHide"), s.toggleClass(e.params.pagination.hiddenClass) } })), Object.assign(e.pagination, { render: u, update: c, init: h, destroy: d }) }, function ({ swiper: e, extendParams: t, on: n, emit: i }) { const r = oy(); let s, a, o, l, c = !1, u = null, h = null; function d() { if (!e.params.scrollbar.el || !e.scrollbar.el) return; const { scrollbar: t, rtlTranslate: n, progress: i } = e, { $dragEl: r, $el: s } = t, l = e.params.scrollbar; let c = a, h = (o - a) * i; n ? (h = -h, h > 0 ? (c = a - h, h = 0) : -h + a > o && (c = o + h)) : h < 0 ? (c = a + h, h = 0) : h + a > o && (c = o - h), e.isHorizontal() ? (r.transform(`translate3d(${h}px, 0, 0)`), r[0].style.width = `${c}px`) : (r.transform(`translate3d(0px, ${h}px, 0)`), r[0].style.height = `${c}px`), l.hide && (clearTimeout(u), s[0].style.opacity = 1, u = setTimeout((() => { s[0].style.opacity = 0, s.transition(400) }), 1e3)) } function p() { if (!e.params.scrollbar.el || !e.scrollbar.el) return; const { scrollbar: t } = e, { $dragEl: n, $el: i } = t; n[0].style.width = "", n[0].style.height = "", o = e.isHorizontal() ? i[0].offsetWidth : i[0].offsetHeight, l = e.size / (e.virtualSize + e.params.slidesOffsetBefore - (e.params.centeredSlides ? e.snapGrid[0] : 0)), a = "auto" === e.params.scrollbar.dragSize ? o * l : parseInt(e.params.scrollbar.dragSize, 10), e.isHorizontal() ? n[0].style.width = `${a}px` : n[0].style.height = `${a}px`, i[0].style.display = l >= 1 ? "none" : "", e.params.scrollbar.hide && (i[0].style.opacity = 0), e.params.watchOverflow && e.enabled && t.$el[e.isLocked ? "addClass" : "removeClass"](e.params.scrollbar.lockClass) } function f(t) { return e.isHorizontal() ? "touchstart" === t.type || "touchmove" === t.type ? t.targetTouches[0].clientX : t.clientX : "touchstart" === t.type || "touchmove" === t.type ? t.targetTouches[0].clientY : t.clientY } function m(t) { const { scrollbar: n, rtlTranslate: i } = e, { $el: r } = n; let l; l = (f(t) - r.offset()[e.isHorizontal() ? "left" : "top"] - (null !== s ? s : a / 2)) / (o - a), l = Math.max(Math.min(l, 1), 0), i && (l = 1 - l); const c = e.minTranslate() + (e.maxTranslate() - e.minTranslate()) * l; e.updateProgress(c), e.setTranslate(c), e.updateActiveIndex(), e.updateSlidesClasses() } function g(t) { const n = e.params.scrollbar, { scrollbar: r, $wrapperEl: a } = e, { $el: o, $dragEl: l } = r; c = !0, s = t.target === l[0] || t.target === l ? f(t) - t.target.getBoundingClientRect()[e.isHorizontal() ? "left" : "top"] : null, t.preventDefault(), t.stopPropagation(), a.transition(100), l.transition(100), m(t), clearTimeout(h), o.transition(0), n.hide && o.css("opacity", 1), e.params.cssMode && e.$wrapperEl.css("scroll-snap-type", "none"), i("scrollbarDragStart", t) } function v(t) { const { scrollbar: n, $wrapperEl: r } = e, { $el: s, $dragEl: a } = n; c && (t.preventDefault ? t.preventDefault() : t.returnValue = !1, m(t), r.transition(0), s.transition(0), a.transition(0), i("scrollbarDragMove", t)) } function y(t) { const n = e.params.scrollbar, { scrollbar: r, $wrapperEl: s } = e, { $el: a } = r; c && (c = !1, e.params.cssMode && (e.$wrapperEl.css("scroll-snap-type", ""), s.transition("")), n.hide && (clearTimeout(h), h = yy((() => { a.css("opacity", 0), a.transition(400) }), 1e3)), i("scrollbarDragEnd", t), n.snapOnRelease && e.slideToClosest()) } function x(t) { const { scrollbar: n, touchEventsTouch: i, touchEventsDesktop: s, params: a, support: o } = e, l = n.$el[0], c = !(!o.passiveListener || !a.passiveListeners) && { passive: !1, capture: !1 }, u = !(!o.passiveListener || !a.passiveListeners) && { passive: !0, capture: !1 }; if (!l) return; const h = "on" === t ? "addEventListener" : "removeEventListener"; o.touch ? (l[h](i.start, g, c), l[h](i.move, v, c), l[h](i.end, y, u)) : (l[h](s.start, g, c), r[h](s.move, v, c), r[h](s.end, y, u)) } function _() { const { scrollbar: t, $el: n } = e; e.params.scrollbar = Jy(e, e.originalParams.scrollbar, e.params.scrollbar, { el: "swiper-scrollbar" }); const i = e.params.scrollbar; if (!i.el) return; let r = vy(i.el); e.params.uniqueNavElements && "string" == typeof i.el && r.length > 1 && 1 === n.find(i.el).length && (r = n.find(i.el)); let s = r.find(`.${e.params.scrollbar.dragClass}`); 0 === s.length && (s = vy(`<div class="${e.params.scrollbar.dragClass}"></div>`), r.append(s)), Object.assign(t, { $el: r, el: r[0], $dragEl: s, dragEl: s[0] }), i.draggable && e.params.scrollbar.el && x("on"), r && r[e.enabled ? "removeClass" : "addClass"](e.params.scrollbar.lockClass) } function w() { e.params.scrollbar.el && x("off") } t({ scrollbar: { el: null, dragSize: "auto", hide: !1, draggable: !1, snapOnRelease: !0, lockClass: "swiper-scrollbar-lock", dragClass: "swiper-scrollbar-drag" } }), e.scrollbar = { el: null, dragEl: null, $el: null, $dragEl: null }, n("init", (() => { _(), p(), d() })), n("update resize observerUpdate lock unlock", (() => { p() })), n("setTranslate", (() => { d() })), n("setTransition", ((t, n) => { !function (t) { e.params.scrollbar.el && e.scrollbar.el && e.scrollbar.$dragEl.transition(t) }(n) })), n("enable disable", (() => { const { $el: t } = e.scrollbar; t && t[e.enabled ? "removeClass" : "addClass"](e.params.scrollbar.lockClass) })), n("destroy", (() => { w() })), Object.assign(e.scrollbar, { updateSize: p, setTranslate: d, init: _, destroy: w }) }, function ({ swiper: e, extendParams: t, on: n }) { t({ parallax: { enabled: !1 } }); const i = (t, n) => { const { rtl: i } = e, r = vy(t), s = i ? -1 : 1, a = r.attr("data-swiper-parallax") || "0"; let o = r.attr("data-swiper-parallax-x"), l = r.attr("data-swiper-parallax-y"); const c = r.attr("data-swiper-parallax-scale"), u = r.attr("data-swiper-parallax-opacity"); if (o || l ? (o = o || "0", l = l || "0") : e.isHorizontal() ? (o = a, l = "0") : (l = a, o = "0"), o = o.indexOf("%") >= 0 ? parseInt(o, 10) * n * s + "%" : o * n * s + "px", l = l.indexOf("%") >= 0 ? parseInt(l, 10) * n + "%" : l * n + "px", null != u) { const e = u - (u - 1) * (1 - Math.abs(n)); r[0].style.opacity = e } if (null == c) r.transform(`translate3d(${o}, ${l}, 0px)`); else { const e = c - (c - 1) * (1 - Math.abs(n)); r.transform(`translate3d(${o}, ${l}, 0px) scale(${e})`) } }, r = () => { const { $el: t, slides: n, progress: r, snapGrid: s } = e; t.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((e => { i(e, r) })), n.each(((t, n) => { let a = t.progress; e.params.slidesPerGroup > 1 && "auto" !== e.params.slidesPerView && (a += Math.ceil(n / 2) - r * (s.length - 1)), a = Math.min(Math.max(a, -1), 1), vy(t).find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((e => { i(e, a) })) })) }; n("beforeInit", (() => { e.params.parallax.enabled && (e.params.watchSlidesProgress = !0, e.originalParams.watchSlidesProgress = !0) })), n("init", (() => { e.params.parallax.enabled && r() })), n("setTranslate", (() => { e.params.parallax.enabled && r() })), n("setTransition", ((t, n) => { e.params.parallax.enabled && ((t = e.params.speed) => { const { $el: n } = e; n.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((e => { const n = vy(e); let i = parseInt(n.attr("data-swiper-parallax-duration"), 10) || t; 0 === t && (i = 0), n.transition(i) })) })(n) })) }, function ({ swiper: e, extendParams: t, on: n, emit: i }) { const r = cy(); t({ zoom: { enabled: !1, maxRatio: 3, minRatio: 1, toggle: !0, containerClass: "swiper-zoom-container", zoomedSlideClass: "swiper-slide-zoomed" } }), e.zoom = { enabled: !1 }; let s, a, o, l = 1, c = !1; const u = { $slideEl: void 0, slideWidth: void 0, slideHeight: void 0, $imageEl: void 0, $imageWrapEl: void 0, maxRatio: 3 }, h = { isTouched: void 0, isMoved: void 0, currentX: void 0, currentY: void 0, minX: void 0, minY: void 0, maxX: void 0, maxY: void 0, width: void 0, height: void 0, startX: void 0, startY: void 0, touchesStart: {}, touchesCurrent: {} }, d = { x: void 0, y: void 0, prevPositionX: void 0, prevPositionY: void 0, prevTime: void 0 }; let p = 1; function f(e) { if (e.targetTouches.length < 2) return 1; const t = e.targetTouches[0].pageX, n = e.targetTouches[0].pageY, i = e.targetTouches[1].pageX, r = e.targetTouches[1].pageY; return Math.sqrt((i - t) ** 2 + (r - n) ** 2) } function m(t) { const n = e.support, i = e.params.zoom; if (a = !1, o = !1, !n.gestures) { if ("touchstart" !== t.type || "touchstart" === t.type && t.targetTouches.length < 2) return; a = !0, u.scaleStart = f(t) } u.$slideEl && u.$slideEl.length || (u.$slideEl = vy(t.target).closest(`.${e.params.slideClass}`), 0 === u.$slideEl.length && (u.$slideEl = e.slides.eq(e.activeIndex)), u.$imageEl = u.$slideEl.find(`.${i.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), u.$imageWrapEl = u.$imageEl.parent(`.${i.containerClass}`), u.maxRatio = u.$imageWrapEl.attr("data-swiper-zoom") || i.maxRatio, 0 !== u.$imageWrapEl.length) ? (u.$imageEl && u.$imageEl.transition(0), c = !0) : u.$imageEl = void 0 } function g(t) { const n = e.support, i = e.params.zoom, r = e.zoom; if (!n.gestures) { if ("touchmove" !== t.type || "touchmove" === t.type && t.targetTouches.length < 2) return; o = !0, u.scaleMove = f(t) } u.$imageEl && 0 !== u.$imageEl.length ? (n.gestures ? r.scale = t.scale * l : r.scale = u.scaleMove / u.scaleStart * l, r.scale > u.maxRatio && (r.scale = u.maxRatio - 1 + (r.scale - u.maxRatio + 1) ** .5), r.scale < i.minRatio && (r.scale = i.minRatio + 1 - (i.minRatio - r.scale + 1) ** .5), u.$imageEl.transform(`translate3d(0,0,0) scale(${r.scale})`)) : "gesturechange" === t.type && m(t) } function v(t) { const n = e.device, i = e.support, r = e.params.zoom, s = e.zoom; if (!i.gestures) { if (!a || !o) return; if ("touchend" !== t.type || "touchend" === t.type && t.changedTouches.length < 2 && !n.android) return; a = !1, o = !1 } u.$imageEl && 0 !== u.$imageEl.length && (s.scale = Math.max(Math.min(s.scale, u.maxRatio), r.minRatio), u.$imageEl.transition(e.params.speed).transform(`translate3d(0,0,0) scale(${s.scale})`), l = s.scale, c = !1, 1 === s.scale && (u.$slideEl = void 0)) } function y(t) { const n = e.zoom; if (!u.$imageEl || 0 === u.$imageEl.length) return; if (e.allowClick = !1, !h.isTouched || !u.$slideEl) return; h.isMoved || (h.width = u.$imageEl[0].offsetWidth, h.height = u.$imageEl[0].offsetHeight, h.startX = _y(u.$imageWrapEl[0], "x") || 0, h.startY = _y(u.$imageWrapEl[0], "y") || 0, u.slideWidth = u.$slideEl[0].offsetWidth, u.slideHeight = u.$slideEl[0].offsetHeight, u.$imageWrapEl.transition(0)); const i = h.width * n.scale, r = h.height * n.scale; if (!(i < u.slideWidth && r < u.slideHeight)) { if (h.minX = Math.min(u.slideWidth / 2 - i / 2, 0), h.maxX = -h.minX, h.minY = Math.min(u.slideHeight / 2 - r / 2, 0), h.maxY = -h.minY, h.touchesCurrent.x = "touchmove" === t.type ? t.targetTouches[0].pageX : t.pageX, h.touchesCurrent.y = "touchmove" === t.type ? t.targetTouches[0].pageY : t.pageY, !h.isMoved && !c) { if (e.isHorizontal() && (Math.floor(h.minX) === Math.floor(h.startX) && h.touchesCurrent.x < h.touchesStart.x || Math.floor(h.maxX) === Math.floor(h.startX) && h.touchesCurrent.x > h.touchesStart.x)) return void (h.isTouched = !1); if (!e.isHorizontal() && (Math.floor(h.minY) === Math.floor(h.startY) && h.touchesCurrent.y < h.touchesStart.y || Math.floor(h.maxY) === Math.floor(h.startY) && h.touchesCurrent.y > h.touchesStart.y)) return void (h.isTouched = !1) } t.cancelable && t.preventDefault(), t.stopPropagation(), h.isMoved = !0, h.currentX = h.touchesCurrent.x - h.touchesStart.x + h.startX, h.currentY = h.touchesCurrent.y - h.touchesStart.y + h.startY, h.currentX < h.minX && (h.currentX = h.minX + 1 - (h.minX - h.currentX + 1) ** .8), h.currentX > h.maxX && (h.currentX = h.maxX - 1 + (h.currentX - h.maxX + 1) ** .8), h.currentY < h.minY && (h.currentY = h.minY + 1 - (h.minY - h.currentY + 1) ** .8), h.currentY > h.maxY && (h.currentY = h.maxY - 1 + (h.currentY - h.maxY + 1) ** .8), d.prevPositionX || (d.prevPositionX = h.touchesCurrent.x), d.prevPositionY || (d.prevPositionY = h.touchesCurrent.y), d.prevTime || (d.prevTime = Date.now()), d.x = (h.touchesCurrent.x - d.prevPositionX) / (Date.now() - d.prevTime) / 2, d.y = (h.touchesCurrent.y - d.prevPositionY) / (Date.now() - d.prevTime) / 2, Math.abs(h.touchesCurrent.x - d.prevPositionX) < 2 && (d.x = 0), Math.abs(h.touchesCurrent.y - d.prevPositionY) < 2 && (d.y = 0), d.prevPositionX = h.touchesCurrent.x, d.prevPositionY = h.touchesCurrent.y, d.prevTime = Date.now(), u.$imageWrapEl.transform(`translate3d(${h.currentX}px, ${h.currentY}px,0)`) } } function x() { const t = e.zoom; u.$slideEl && e.previousIndex !== e.activeIndex && (u.$imageEl && u.$imageEl.transform("translate3d(0,0,0) scale(1)"), u.$imageWrapEl && u.$imageWrapEl.transform("translate3d(0,0,0)"), t.scale = 1, l = 1, u.$slideEl = void 0, u.$imageEl = void 0, u.$imageWrapEl = void 0) } function _(t) { const n = e.zoom, i = e.params.zoom; if (u.$slideEl || (t && t.target && (u.$slideEl = vy(t.target).closest(`.${e.params.slideClass}`)), u.$slideEl || (e.params.virtual && e.params.virtual.enabled && e.virtual ? u.$slideEl = e.$wrapperEl.children(`.${e.params.slideActiveClass}`) : u.$slideEl = e.slides.eq(e.activeIndex)), u.$imageEl = u.$slideEl.find(`.${i.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), u.$imageWrapEl = u.$imageEl.parent(`.${i.containerClass}`)), !u.$imageEl || 0 === u.$imageEl.length || !u.$imageWrapEl || 0 === u.$imageWrapEl.length) return; let s, a, o, c, d, p, f, m, g, v, y, x, _, w, b, S, E, M; e.params.cssMode && (e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.touchAction = "none"), u.$slideEl.addClass(`${i.zoomedSlideClass}`), void 0 === h.touchesStart.x && t ? (s = "touchend" === t.type ? t.changedTouches[0].pageX : t.pageX, a = "touchend" === t.type ? t.changedTouches[0].pageY : t.pageY) : (s = h.touchesStart.x, a = h.touchesStart.y), n.scale = u.$imageWrapEl.attr("data-swiper-zoom") || i.maxRatio, l = u.$imageWrapEl.attr("data-swiper-zoom") || i.maxRatio, t ? (E = u.$slideEl[0].offsetWidth, M = u.$slideEl[0].offsetHeight, o = u.$slideEl.offset().left + r.scrollX, c = u.$slideEl.offset().top + r.scrollY, d = o + E / 2 - s, p = c + M / 2 - a, g = u.$imageEl[0].offsetWidth, v = u.$imageEl[0].offsetHeight, y = g * n.scale, x = v * n.scale, _ = Math.min(E / 2 - y / 2, 0), w = Math.min(M / 2 - x / 2, 0), b = -_, S = -w, f = d * n.scale, m = p * n.scale, f < _ && (f = _), f > b && (f = b), m < w && (m = w), m > S && (m = S)) : (f = 0, m = 0), u.$imageWrapEl.transition(300).transform(`translate3d(${f}px, ${m}px,0)`), u.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${n.scale})`) } function w() { const t = e.zoom, n = e.params.zoom; u.$slideEl || (e.params.virtual && e.params.virtual.enabled && e.virtual ? u.$slideEl = e.$wrapperEl.children(`.${e.params.slideActiveClass}`) : u.$slideEl = e.slides.eq(e.activeIndex), u.$imageEl = u.$slideEl.find(`.${n.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), u.$imageWrapEl = u.$imageEl.parent(`.${n.containerClass}`)), u.$imageEl && 0 !== u.$imageEl.length && u.$imageWrapEl && 0 !== u.$imageWrapEl.length && (e.params.cssMode && (e.wrapperEl.style.overflow = "", e.wrapperEl.style.touchAction = ""), t.scale = 1, l = 1, u.$imageWrapEl.transition(300).transform("translate3d(0,0,0)"), u.$imageEl.transition(300).transform("translate3d(0,0,0) scale(1)"), u.$slideEl.removeClass(`${n.zoomedSlideClass}`), u.$slideEl = void 0) } function b(t) { const n = e.zoom; n.scale && 1 !== n.scale ? w() : _(t) } function S() { const t = e.support; return { passiveListener: !("touchstart" !== e.touchEvents.start || !t.passiveListener || !e.params.passiveListeners) && { passive: !0, capture: !1 }, activeListenerWithCapture: !t.passiveListener || { passive: !1, capture: !0 } } } function E() { return `.${e.params.slideClass}` } function M(t) { const { passiveListener: n } = S(), i = E(); e.$wrapperEl[t]("gesturestart", i, m, n), e.$wrapperEl[t]("gesturechange", i, g, n), e.$wrapperEl[t]("gestureend", i, v, n) } function T() { s || (s = !0, M("on")) } function C() { s && (s = !1, M("off")) } function D() { const t = e.zoom; if (t.enabled) return; t.enabled = !0; const n = e.support, { passiveListener: i, activeListenerWithCapture: r } = S(), s = E(); n.gestures ? (e.$wrapperEl.on(e.touchEvents.start, T, i), e.$wrapperEl.on(e.touchEvents.end, C, i)) : "touchstart" === e.touchEvents.start && (e.$wrapperEl.on(e.touchEvents.start, s, m, i), e.$wrapperEl.on(e.touchEvents.move, s, g, r), e.$wrapperEl.on(e.touchEvents.end, s, v, i), e.touchEvents.cancel && e.$wrapperEl.on(e.touchEvents.cancel, s, v, i)), e.$wrapperEl.on(e.touchEvents.move, `.${e.params.zoom.containerClass}`, y, r) } function L() { const t = e.zoom; if (!t.enabled) return; const n = e.support; t.enabled = !1; const { passiveListener: i, activeListenerWithCapture: r } = S(), s = E(); n.gestures ? (e.$wrapperEl.off(e.touchEvents.start, T, i), e.$wrapperEl.off(e.touchEvents.end, C, i)) : "touchstart" === e.touchEvents.start && (e.$wrapperEl.off(e.touchEvents.start, s, m, i), e.$wrapperEl.off(e.touchEvents.move, s, g, r), e.$wrapperEl.off(e.touchEvents.end, s, v, i), e.touchEvents.cancel && e.$wrapperEl.off(e.touchEvents.cancel, s, v, i)), e.$wrapperEl.off(e.touchEvents.move, `.${e.params.zoom.containerClass}`, y, r) } Object.defineProperty(e.zoom, "scale", { get: () => p, set(e) { if (p !== e) { const t = u.$imageEl ? u.$imageEl[0] : void 0, n = u.$slideEl ? u.$slideEl[0] : void 0; i("zoomChange", e, t, n) } p = e } }), n("init", (() => { e.params.zoom.enabled && D() })), n("destroy", (() => { L() })), n("touchStart", ((t, n) => { e.zoom.enabled && function (t) { const n = e.device; u.$imageEl && 0 !== u.$imageEl.length && (h.isTouched || (n.android && t.cancelable && t.preventDefault(), h.isTouched = !0, h.touchesStart.x = "touchstart" === t.type ? t.targetTouches[0].pageX : t.pageX, h.touchesStart.y = "touchstart" === t.type ? t.targetTouches[0].pageY : t.pageY)) }(n) })), n("touchEnd", ((t, n) => { e.zoom.enabled && function () { const t = e.zoom; if (!u.$imageEl || 0 === u.$imageEl.length) return; if (!h.isTouched || !h.isMoved) return h.isTouched = !1, void (h.isMoved = !1); h.isTouched = !1, h.isMoved = !1; let n = 300, i = 300; const r = d.x * n, s = h.currentX + r, a = d.y * i, o = h.currentY + a; 0 !== d.x && (n = Math.abs((s - h.currentX) / d.x)), 0 !== d.y && (i = Math.abs((o - h.currentY) / d.y)); const l = Math.max(n, i); h.currentX = s, h.currentY = o; const c = h.width * t.scale, p = h.height * t.scale; h.minX = Math.min(u.slideWidth / 2 - c / 2, 0), h.maxX = -h.minX, h.minY = Math.min(u.slideHeight / 2 - p / 2, 0), h.maxY = -h.minY, h.currentX = Math.max(Math.min(h.currentX, h.maxX), h.minX), h.currentY = Math.max(Math.min(h.currentY, h.maxY), h.minY), u.$imageWrapEl.transition(l).transform(`translate3d(${h.currentX}px, ${h.currentY}px,0)`) }() })), n("doubleTap", ((t, n) => { !e.animating && e.params.zoom.enabled && e.zoom.enabled && e.params.zoom.toggle && b(n) })), n("transitionEnd", (() => { e.zoom.enabled && e.params.zoom.enabled && x() })), n("slideChange", (() => { e.zoom.enabled && e.params.zoom.enabled && e.params.cssMode && x() })), Object.assign(e.zoom, { enable: D, disable: L, in: _, out: w, toggle: b }) }, function ({ swiper: e, extendParams: t, on: n, emit: i }) { t({ lazy: { checkInView: !1, enabled: !1, loadPrevNext: !1, loadPrevNextAmount: 1, loadOnTransitionStart: !1, scrollingElement: "", elementClass: "swiper-lazy", loadingClass: "swiper-lazy-loading", loadedClass: "swiper-lazy-loaded", preloaderClass: "swiper-lazy-preloader" } }), e.lazy = {}; let r = !1, s = !1; function a(t, n = !0) { const r = e.params.lazy; if (void 0 === t) return; if (0 === e.slides.length) return; const s = e.virtual && e.params.virtual.enabled ? e.$wrapperEl.children(`.${e.params.slideClass}[data-swiper-slide-index="${t}"]`) : e.slides.eq(t), o = s.find(`.${r.elementClass}:not(.${r.loadedClass}):not(.${r.loadingClass})`); !s.hasClass(r.elementClass) || s.hasClass(r.loadedClass) || s.hasClass(r.loadingClass) || o.push(s[0]), 0 !== o.length && o.each((t => { const o = vy(t); o.addClass(r.loadingClass); const l = o.attr("data-background"), c = o.attr("data-src"), u = o.attr("data-srcset"), h = o.attr("data-sizes"), d = o.parent("picture"); e.loadImage(o[0], c || l, u, h, !1, (() => { if (null != e && e && (!e || e.params) && !e.destroyed) { if (l ? (o.css("background-image", `url("${l}")`), o.removeAttr("data-background")) : (u && (o.attr("srcset", u), o.removeAttr("data-srcset")), h && (o.attr("sizes", h), o.removeAttr("data-sizes")), d.length && d.children("source").each((e => { const t = vy(e); t.attr("data-srcset") && (t.attr("srcset", t.attr("data-srcset")), t.removeAttr("data-srcset")) })), c && (o.attr("src", c), o.removeAttr("data-src"))), o.addClass(r.loadedClass).removeClass(r.loadingClass), s.find(`.${r.preloaderClass}`).remove(), e.params.loop && n) { const t = s.attr("data-swiper-slide-index"); s.hasClass(e.params.slideDuplicateClass) ? a(e.$wrapperEl.children(`[data-swiper-slide-index="${t}"]:not(.${e.params.slideDuplicateClass})`).index(), !1) : a(e.$wrapperEl.children(`.${e.params.slideDuplicateClass}[data-swiper-slide-index="${t}"]`).index(), !1) } i("lazyImageReady", s[0], o[0]), e.params.autoHeight && e.updateAutoHeight() } })), i("lazyImageLoad", s[0], o[0]) })) } function o() { const { $wrapperEl: t, params: n, slides: i, activeIndex: r } = e, o = e.virtual && n.virtual.enabled, l = n.lazy; let c = n.slidesPerView; function u(e) { if (o) { if (t.children(`.${n.slideClass}[data-swiper-slide-index="${e}"]`).length) return !0 } else if (i[e]) return !0; return !1 } function h(e) { return o ? vy(e).attr("data-swiper-slide-index") : vy(e).index() } if ("auto" === c && (c = 0), s || (s = !0), e.params.watchSlidesProgress) t.children(`.${n.slideVisibleClass}`).each((e => { a(o ? vy(e).attr("data-swiper-slide-index") : vy(e).index()) })); else if (c > 1) for (let e = r; e < r + c; e += 1)u(e) && a(e); else a(r); if (l.loadPrevNext) if (c > 1 || l.loadPrevNextAmount && l.loadPrevNextAmount > 1) { const e = l.loadPrevNextAmount, t = c, n = Math.min(r + t + Math.max(e, t), i.length), s = Math.max(r - Math.max(t, e), 0); for (let e = r + c; e < n; e += 1)u(e) && a(e); for (let e = s; e < r; e += 1)u(e) && a(e) } else { const e = t.children(`.${n.slideNextClass}`); e.length > 0 && a(h(e)); const i = t.children(`.${n.slidePrevClass}`); i.length > 0 && a(h(i)) } } function l() { const t = cy(); if (!e || e.destroyed) return; const n = e.params.lazy.scrollingElement ? vy(e.params.lazy.scrollingElement) : vy(t), i = n[0] === t, s = i ? t.innerWidth : n[0].offsetWidth, a = i ? t.innerHeight : n[0].offsetHeight, c = e.$el.offset(), { rtlTranslate: u } = e; let h = !1; u && (c.left -= e.$el[0].scrollLeft); const d = [[c.left, c.top], [c.left + e.width, c.top], [c.left, c.top + e.height], [c.left + e.width, c.top + e.height]]; for (let e = 0; e < d.length; e += 1) { const t = d[e]; if (t[0] >= 0 && t[0] <= s && t[1] >= 0 && t[1] <= a) { if (0 === t[0] && 0 === t[1]) continue; h = !0 } } const p = !("touchstart" !== e.touchEvents.start || !e.support.passiveListener || !e.params.passiveListeners) && { passive: !0, capture: !1 }; h ? (o(), n.off("scroll", l, p)) : r || (r = !0, n.on("scroll", l, p)) } n("beforeInit", (() => { e.params.lazy.enabled && e.params.preloadImages && (e.params.preloadImages = !1) })), n("init", (() => { e.params.lazy.enabled && (e.params.lazy.checkInView ? l() : o()) })), n("scroll", (() => { e.params.freeMode && e.params.freeMode.enabled && !e.params.freeMode.sticky && o() })), n("scrollbarDragMove resize _freeModeNoMomentumRelease", (() => { e.params.lazy.enabled && (e.params.lazy.checkInView ? l() : o()) })), n("transitionStart", (() => { e.params.lazy.enabled && (e.params.lazy.loadOnTransitionStart || !e.params.lazy.loadOnTransitionStart && !s) && (e.params.lazy.checkInView ? l() : o()) })), n("transitionEnd", (() => { e.params.lazy.enabled && !e.params.lazy.loadOnTransitionStart && (e.params.lazy.checkInView ? l() : o()) })), n("slideChange", (() => { const { lazy: t, cssMode: n, watchSlidesProgress: i, touchReleaseOnEdges: r, resistanceRatio: s } = e.params; t.enabled && (n || i && (r || 0 === s)) && o() })), Object.assign(e.lazy, { load: o, loadInSlide: a }) }, function ({ swiper: e, extendParams: t, on: n }) { function i(e, t) { const n = function () { let e, t, n; return (i, r) => { for (t = -1, e = i.length; e - t > 1;)n = e + t >> 1, i[n] <= r ? t = n : e = n; return e } }(); let i, r; return this.x = e, this.y = t, this.lastIndex = e.length - 1, this.interpolate = function (e) { return e ? (r = n(this.x, e), i = r - 1, (e - this.x[i]) * (this.y[r] - this.y[i]) / (this.x[r] - this.x[i]) + this.y[i]) : 0 }, this } function r() { e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline) } t({ controller: { control: void 0, inverse: !1, by: "slide" } }), e.controller = { control: void 0 }, n("beforeInit", (() => { e.controller.control = e.params.controller.control })), n("update", (() => { r() })), n("resize", (() => { r() })), n("observerUpdate", (() => { r() })), n("setTranslate", ((t, n, i) => { e.controller.control && e.controller.setTranslate(n, i) })), n("setTransition", ((t, n, i) => { e.controller.control && e.controller.setTransition(n, i) })), Object.assign(e.controller, { setTranslate: function (t, n) { const r = e.controller.control; let s, a; const o = e.constructor; function l(t) { const n = e.rtlTranslate ? -e.translate : e.translate; "slide" === e.params.controller.by && (function (t) { e.controller.spline || (e.controller.spline = e.params.loop ? new i(e.slidesGrid, t.slidesGrid) : new i(e.snapGrid, t.snapGrid)) }(t), a = -e.controller.spline.interpolate(-n)), a && "container" !== e.params.controller.by || (s = (t.maxTranslate() - t.minTranslate()) / (e.maxTranslate() - e.minTranslate()), a = (n - e.minTranslate()) * s + t.minTranslate()), e.params.controller.inverse && (a = t.maxTranslate() - a), t.updateProgress(a), t.setTranslate(a, e), t.updateActiveIndex(), t.updateSlidesClasses() } if (Array.isArray(r)) for (let e = 0; e < r.length; e += 1)r[e] !== n && r[e] instanceof o && l(r[e]); else r instanceof o && n !== r && l(r) }, setTransition: function (t, n) { const i = e.constructor, r = e.controller.control; let s; function a(n) { n.setTransition(t, e), 0 !== t && (n.transitionStart(), n.params.autoHeight && yy((() => { n.updateAutoHeight() })), n.$wrapperEl.transitionEnd((() => { r && (n.params.loop && "slide" === e.params.controller.by && n.loopFix(), n.transitionEnd()) }))) } if (Array.isArray(r)) for (s = 0; s < r.length; s += 1)r[s] !== n && r[s] instanceof i && a(r[s]); else r instanceof i && n !== r && a(r) } }) }, function ({ swiper: e, extendParams: t, on: n }) { t({ a11y: { enabled: !0, notificationClass: "swiper-notification", prevSlideMessage: "Previous slide", nextSlideMessage: "Next slide", firstSlideMessage: "This is the first slide", lastSlideMessage: "This is the last slide", paginationBulletMessage: "Go to slide {{index}}", slideLabelMessage: "{{index}} / {{slidesLength}}", containerMessage: null, containerRoleDescriptionMessage: null, itemRoleDescriptionMessage: null, slideRole: "group" } }); let i = null; function r(e) { const t = i; 0 !== t.length && (t.html(""), t.html(e)) } function s(e) { e.attr("tabIndex", "0") } function a(e) { e.attr("tabIndex", "-1") } function o(e, t) { e.attr("role", t) } function l(e, t) { e.attr("aria-roledescription", t) } function c(e, t) { e.attr("aria-label", t) } function u(e) { e.attr("aria-disabled", !0) } function h(e) { e.attr("aria-disabled", !1) } function d(t) { if (13 !== t.keyCode && 32 !== t.keyCode) return; const n = e.params.a11y, i = vy(t.target); e.navigation && e.navigation.$nextEl && i.is(e.navigation.$nextEl) && (e.isEnd && !e.params.loop || e.slideNext(), e.isEnd ? r(n.lastSlideMessage) : r(n.nextSlideMessage)), e.navigation && e.navigation.$prevEl && i.is(e.navigation.$prevEl) && (e.isBeginning && !e.params.loop || e.slidePrev(), e.isBeginning ? r(n.firstSlideMessage) : r(n.prevSlideMessage)), e.pagination && i.is(Qy(e.params.pagination.bulletClass)) && i[0].click() } function p() { if (e.params.loop || e.params.rewind || !e.navigation) return; const { $nextEl: t, $prevEl: n } = e.navigation; n && n.length > 0 && (e.isBeginning ? (u(n), a(n)) : (h(n), s(n))), t && t.length > 0 && (e.isEnd ? (u(t), a(t)) : (h(t), s(t))) } function f() { return e.pagination && e.pagination.bullets && e.pagination.bullets.length } function m() { return f() && e.params.pagination.clickable } const g = (e, t, n) => { s(e), "BUTTON" !== e[0].tagName && (o(e, "button"), e.on("keydown", d)), c(e, n), function (e, t) { e.attr("aria-controls", t) }(e, t) }; n("beforeInit", (() => { i = vy(`<span class="${e.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`) })), n("afterInit", (() => { e.params.a11y.enabled && (function () { const t = e.params.a11y; e.$el.append(i); const n = e.$el; t.containerRoleDescriptionMessage && l(n, t.containerRoleDescriptionMessage), t.containerMessage && c(n, t.containerMessage); const r = e.$wrapperEl, s = r.attr("id") || `swiper-wrapper-${function (e = 16) { return "x".repeat(e).replace(/x/g, (() => Math.round(16 * Math.random()).toString(16))) }(16)}`, a = e.params.autoplay && e.params.autoplay.enabled ? "off" : "polite"; var u; u = s, r.attr("id", u), function (e, t) { e.attr("aria-live", t) }(r, a), t.itemRoleDescriptionMessage && l(vy(e.slides), t.itemRoleDescriptionMessage), o(vy(e.slides), t.slideRole); const h = e.params.loop ? e.slides.filter((t => !t.classList.contains(e.params.slideDuplicateClass))).length : e.slides.length; let p, f; e.slides.each(((n, i) => { const r = vy(n), s = e.params.loop ? parseInt(r.attr("data-swiper-slide-index"), 10) : i; c(r, t.slideLabelMessage.replace(/\{\{index\}\}/, s + 1).replace(/\{\{slidesLength\}\}/, h)) })), e.navigation && e.navigation.$nextEl && (p = e.navigation.$nextEl), e.navigation && e.navigation.$prevEl && (f = e.navigation.$prevEl), p && p.length && g(p, s, t.nextSlideMessage), f && f.length && g(f, s, t.prevSlideMessage), m() && e.pagination.$el.on("keydown", Qy(e.params.pagination.bulletClass), d) }(), p()) })), n("toEdge", (() => { e.params.a11y.enabled && p() })), n("fromEdge", (() => { e.params.a11y.enabled && p() })), n("paginationUpdate", (() => { e.params.a11y.enabled && function () { const t = e.params.a11y; f() && e.pagination.bullets.each((n => { const i = vy(n); e.params.pagination.clickable && (s(i), e.params.pagination.renderBullet || (o(i, "button"), c(i, t.paginationBulletMessage.replace(/\{\{index\}\}/, i.index() + 1)))), i.is(`.${e.params.pagination.bulletActiveClass}`) ? i.attr("aria-current", "true") : i.removeAttr("aria-current") })) }() })), n("destroy", (() => { e.params.a11y.enabled && function () { let t, n; i && i.length > 0 && i.remove(), e.navigation && e.navigation.$nextEl && (t = e.navigation.$nextEl), e.navigation && e.navigation.$prevEl && (n = e.navigation.$prevEl), t && t.off("keydown", d), n && n.off("keydown", d), m() && e.pagination.$el.off("keydown", Qy(e.params.pagination.bulletClass), d) }() })) }, function ({ swiper: e, extendParams: t, on: n }) { t({ history: { enabled: !1, root: "", replaceState: !1, key: "slides" } }); let i = !1, r = {}; const s = e => e.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, ""), a = e => { const t = cy(); let n; n = e ? new URL(e) : t.location; const i = n.pathname.slice(1).split("/").filter((e => "" !== e)), r = i.length; return { key: i[r - 2], value: i[r - 1] } }, o = (t, n) => { const r = cy(); if (!i || !e.params.history.enabled) return; let a; a = e.params.url ? new URL(e.params.url) : r.location; const o = e.slides.eq(n); let l = s(o.attr("data-history")); if (e.params.history.root.length > 0) { let n = e.params.history.root; "/" === n[n.length - 1] && (n = n.slice(0, n.length - 1)), l = `${n}/${t}/${l}` } else a.pathname.includes(t) || (l = `${t}/${l}`); const c = r.history.state; c && c.value === l || (e.params.history.replaceState ? r.history.replaceState({ value: l }, null, l) : r.history.pushState({ value: l }, null, l)) }, l = (t, n, i) => { if (n) for (let r = 0, a = e.slides.length; r < a; r += 1) { const a = e.slides.eq(r); if (s(a.attr("data-history")) === n && !a.hasClass(e.params.slideDuplicateClass)) { const n = a.index(); e.slideTo(n, t, i) } } else e.slideTo(0, t, i) }, c = () => { r = a(e.params.url), l(e.params.speed, e.paths.value, !1) }; n("init", (() => { e.params.history.enabled && (() => { const t = cy(); if (e.params.history) { if (!t.history || !t.history.pushState) return e.params.history.enabled = !1, void (e.params.hashNavigation.enabled = !0); i = !0, r = a(e.params.url), (r.key || r.value) && (l(0, r.value, e.params.runCallbacksOnInit), e.params.history.replaceState || t.addEventListener("popstate", c)) } })() })), n("destroy", (() => { e.params.history.enabled && (() => { const t = cy(); e.params.history.replaceState || t.removeEventListener("popstate", c) })() })), n("transitionEnd _freeModeNoMomentumRelease", (() => { i && o(e.params.history.key, e.activeIndex) })), n("slideChange", (() => { i && e.params.cssMode && o(e.params.history.key, e.activeIndex) })) }, function ({ swiper: e, extendParams: t, emit: n, on: i }) { let r = !1; const s = oy(), a = cy(); t({ hashNavigation: { enabled: !1, replaceState: !1, watchState: !1 } }); const o = () => { n("hashChange"); const t = s.location.hash.replace("#", ""); if (t !== e.slides.eq(e.activeIndex).attr("data-hash")) { const n = e.$wrapperEl.children(`.${e.params.slideClass}[data-hash="${t}"]`).index(); if (void 0 === n) return; e.slideTo(n) } }, l = () => { if (r && e.params.hashNavigation.enabled) if (e.params.hashNavigation.replaceState && a.history && a.history.replaceState) a.history.replaceState(null, null, `#${e.slides.eq(e.activeIndex).attr("data-hash")}` || ""), n("hashSet"); else { const t = e.slides.eq(e.activeIndex), i = t.attr("data-hash") || t.attr("data-history"); s.location.hash = i || "", n("hashSet") } }; i("init", (() => { e.params.hashNavigation.enabled && (() => { if (!e.params.hashNavigation.enabled || e.params.history && e.params.history.enabled) return; r = !0; const t = s.location.hash.replace("#", ""); if (t) { const n = 0; for (let i = 0, r = e.slides.length; i < r; i += 1) { const r = e.slides.eq(i); if ((r.attr("data-hash") || r.attr("data-history")) === t && !r.hasClass(e.params.slideDuplicateClass)) { const t = r.index(); e.slideTo(t, n, e.params.runCallbacksOnInit, !0) } } } e.params.hashNavigation.watchState && vy(a).on("hashchange", o) })() })), i("destroy", (() => { e.params.hashNavigation.enabled && e.params.hashNavigation.watchState && vy(a).off("hashchange", o) })), i("transitionEnd _freeModeNoMomentumRelease", (() => { r && l() })), i("slideChange", (() => { r && e.params.cssMode && l() })) }, function ({ swiper: e, extendParams: t, on: n, emit: i }) { let r; function s() { const t = e.slides.eq(e.activeIndex); let n = e.params.autoplay.delay; t.attr("data-swiper-autoplay") && (n = t.attr("data-swiper-autoplay") || e.params.autoplay.delay), clearTimeout(r), r = yy((() => { let t; e.params.autoplay.reverseDirection ? e.params.loop ? (e.loopFix(), t = e.slidePrev(e.params.speed, !0, !0), i("autoplay")) : e.isBeginning ? e.params.autoplay.stopOnLastSlide ? o() : (t = e.slideTo(e.slides.length - 1, e.params.speed, !0, !0), i("autoplay")) : (t = e.slidePrev(e.params.speed, !0, !0), i("autoplay")) : e.params.loop ? (e.loopFix(), t = e.slideNext(e.params.speed, !0, !0), i("autoplay")) : e.isEnd ? e.params.autoplay.stopOnLastSlide ? o() : (t = e.slideTo(0, e.params.speed, !0, !0), i("autoplay")) : (t = e.slideNext(e.params.speed, !0, !0), i("autoplay")), (e.params.cssMode && e.autoplay.running || !1 === t) && s() }), n) } function a() { return void 0 === r && !e.autoplay.running && (e.autoplay.running = !0, i("autoplayStart"), s(), !0) } function o() { return !!e.autoplay.running && void 0 !== r && (r && (clearTimeout(r), r = void 0), e.autoplay.running = !1, i("autoplayStop"), !0) } function l(t) { e.autoplay.running && (e.autoplay.paused || (r && clearTimeout(r), e.autoplay.paused = !0, 0 !== t && e.params.autoplay.waitForTransition ? ["transitionend", "webkitTransitionEnd"].forEach((t => { e.$wrapperEl[0].addEventListener(t, u) })) : (e.autoplay.paused = !1, s()))) } function c() { const t = oy(); "hidden" === t.visibilityState && e.autoplay.running && l(), "visible" === t.visibilityState && e.autoplay.paused && (s(), e.autoplay.paused = !1) } function u(t) { e && !e.destroyed && e.$wrapperEl && t.target === e.$wrapperEl[0] && (["transitionend", "webkitTransitionEnd"].forEach((t => { e.$wrapperEl[0].removeEventListener(t, u) })), e.autoplay.paused = !1, e.autoplay.running ? s() : o()) } function h() { e.params.autoplay.disableOnInteraction ? o() : l(), ["transitionend", "webkitTransitionEnd"].forEach((t => { e.$wrapperEl[0].removeEventListener(t, u) })) } function d() { e.params.autoplay.disableOnInteraction || (e.autoplay.paused = !1, s()) } e.autoplay = { running: !1, paused: !1 }, t({ autoplay: { enabled: !1, delay: 3e3, waitForTransition: !0, disableOnInteraction: !0, stopOnLastSlide: !1, reverseDirection: !1, pauseOnMouseEnter: !1 } }), n("init", (() => { e.params.autoplay.enabled && (a(), oy().addEventListener("visibilitychange", c), e.params.autoplay.pauseOnMouseEnter && (e.$el.on("mouseenter", h), e.$el.on("mouseleave", d))) })), n("beforeTransitionStart", ((t, n, i) => { e.autoplay.running && (i || !e.params.autoplay.disableOnInteraction ? e.autoplay.pause(n) : o()) })), n("sliderFirstMove", (() => { e.autoplay.running && (e.params.autoplay.disableOnInteraction ? o() : l()) })), n("touchEnd", (() => { e.params.cssMode && e.autoplay.paused && !e.params.autoplay.disableOnInteraction && s() })), n("destroy", (() => { e.$el.off("mouseenter", h), e.$el.off("mouseleave", d), e.autoplay.running && o(), oy().removeEventListener("visibilitychange", c) })), Object.assign(e.autoplay, { pause: l, run: s, start: a, stop: o }) }, function ({ swiper: e, extendParams: t, on: n }) { t({ thumbs: { swiper: null, multipleActiveThumbs: !0, autoScrollOffset: 0, slideThumbActiveClass: "swiper-slide-thumb-active", thumbsContainerClass: "swiper-thumbs" } }); let i = !1, r = !1; function s() { const t = e.thumbs.swiper; if (!t) return; const n = t.clickedIndex, i = t.clickedSlide; if (i && vy(i).hasClass(e.params.thumbs.slideThumbActiveClass)) return; if (null == n) return; let r; if (r = t.params.loop ? parseInt(vy(t.clickedSlide).attr("data-swiper-slide-index"), 10) : n, e.params.loop) { let t = e.activeIndex; e.slides.eq(t).hasClass(e.params.slideDuplicateClass) && (e.loopFix(), e._clientLeft = e.$wrapperEl[0].clientLeft, t = e.activeIndex); const n = e.slides.eq(t).prevAll(`[data-swiper-slide-index="${r}"]`).eq(0).index(), i = e.slides.eq(t).nextAll(`[data-swiper-slide-index="${r}"]`).eq(0).index(); r = void 0 === n ? i : void 0 === i ? n : i - t < t - n ? i : n } e.slideTo(r) } function a() { const { thumbs: t } = e.params; if (i) return !1; i = !0; const n = e.constructor; if (t.swiper instanceof n) e.thumbs.swiper = t.swiper, Object.assign(e.thumbs.swiper.originalParams, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), Object.assign(e.thumbs.swiper.params, { watchSlidesProgress: !0, slideToClickedSlide: !1 }); else if (wy(t.swiper)) { const i = Object.assign({}, t.swiper); Object.assign(i, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), e.thumbs.swiper = new n(i), r = !0 } return e.thumbs.swiper.$el.addClass(e.params.thumbs.thumbsContainerClass), e.thumbs.swiper.on("tap", s), !0 } function o(t) { const n = e.thumbs.swiper; if (!n) return; const i = "auto" === n.params.slidesPerView ? n.slidesPerViewDynamic() : n.params.slidesPerView, r = e.params.thumbs.autoScrollOffset, s = r && !n.params.loop; if (e.realIndex !== n.realIndex || s) { let a, o, l = n.activeIndex; if (n.params.loop) { n.slides.eq(l).hasClass(n.params.slideDuplicateClass) && (n.loopFix(), n._clientLeft = n.$wrapperEl[0].clientLeft, l = n.activeIndex); const t = n.slides.eq(l).prevAll(`[data-swiper-slide-index="${e.realIndex}"]`).eq(0).index(), i = n.slides.eq(l).nextAll(`[data-swiper-slide-index="${e.realIndex}"]`).eq(0).index(); a = void 0 === t ? i : void 0 === i ? t : i - l == l - t ? n.params.slidesPerGroup > 1 ? i : l : i - l < l - t ? i : t, o = e.activeIndex > e.previousIndex ? "next" : "prev" } else a = e.realIndex, o = a > e.previousIndex ? "next" : "prev"; s && (a += "next" === o ? r : -1 * r), n.visibleSlidesIndexes && n.visibleSlidesIndexes.indexOf(a) < 0 && (n.params.centeredSlides ? a = a > l ? a - Math.floor(i / 2) + 1 : a + Math.floor(i / 2) - 1 : a > l && n.params.slidesPerGroup, n.slideTo(a, t ? 0 : void 0)) } let a = 1; const o = e.params.thumbs.slideThumbActiveClass; if (e.params.slidesPerView > 1 && !e.params.centeredSlides && (a = e.params.slidesPerView), e.params.thumbs.multipleActiveThumbs || (a = 1), a = Math.floor(a), n.slides.removeClass(o), n.params.loop || n.params.virtual && n.params.virtual.enabled) for (let t = 0; t < a; t += 1)n.$wrapperEl.children(`[data-swiper-slide-index="${e.realIndex + t}"]`).addClass(o); else for (let t = 0; t < a; t += 1)n.slides.eq(e.realIndex + t).addClass(o) } e.thumbs = { swiper: null }, n("beforeInit", (() => { const { thumbs: t } = e.params; t && t.swiper && (a(), o(!0)) })), n("slideChange update resize observerUpdate", (() => { e.thumbs.swiper && o() })), n("setTransition", ((t, n) => { const i = e.thumbs.swiper; i && i.setTransition(n) })), n("beforeDestroy", (() => { const t = e.thumbs.swiper; t && r && t && t.destroy() })), Object.assign(e.thumbs, { init: a, update: o }) }, function ({ swiper: e, extendParams: t, emit: n, once: i }) { t({ freeMode: { enabled: !1, momentum: !0, momentumRatio: 1, momentumBounce: !0, momentumBounceRatio: 1, momentumVelocityRatio: 1, sticky: !1, minimumVelocity: .02 } }), Object.assign(e, { freeMode: { onTouchMove: function () { const { touchEventsData: t, touches: n } = e; 0 === t.velocities.length && t.velocities.push({ position: n[e.isHorizontal() ? "startX" : "startY"], time: t.touchStartTime }), t.velocities.push({ position: n[e.isHorizontal() ? "currentX" : "currentY"], time: xy() }) }, onTouchEnd: function ({ currentPos: t }) { const { params: r, $wrapperEl: s, rtlTranslate: a, snapGrid: o, touchEventsData: l } = e, c = xy() - l.touchStartTime; if (t < -e.minTranslate()) e.slideTo(e.activeIndex); else if (t > -e.maxTranslate()) e.slides.length < o.length ? e.slideTo(o.length - 1) : e.slideTo(e.slides.length - 1); else { if (r.freeMode.momentum) { if (l.velocities.length > 1) { const t = l.velocities.pop(), n = l.velocities.pop(), i = t.position - n.position, s = t.time - n.time; e.velocity = i / s, e.velocity /= 2, Math.abs(e.velocity) < r.freeMode.minimumVelocity && (e.velocity = 0), (s > 150 || xy() - t.time > 300) && (e.velocity = 0) } else e.velocity = 0; e.velocity *= r.freeMode.momentumVelocityRatio, l.velocities.length = 0; let t = 1e3 * r.freeMode.momentumRatio; const c = e.velocity * t; let u = e.translate + c; a && (u = -u); let h, d = !1; const p = 20 * Math.abs(e.velocity) * r.freeMode.momentumBounceRatio; let f; if (u < e.maxTranslate()) r.freeMode.momentumBounce ? (u + e.maxTranslate() < -p && (u = e.maxTranslate() - p), h = e.maxTranslate(), d = !0, l.allowMomentumBounce = !0) : u = e.maxTranslate(), r.loop && r.centeredSlides && (f = !0); else if (u > e.minTranslate()) r.freeMode.momentumBounce ? (u - e.minTranslate() > p && (u = e.minTranslate() + p), h = e.minTranslate(), d = !0, l.allowMomentumBounce = !0) : u = e.minTranslate(), r.loop && r.centeredSlides && (f = !0); else if (r.freeMode.sticky) { let t; for (let e = 0; e < o.length; e += 1)if (o[e] > -u) { t = e; break } u = Math.abs(o[t] - u) < Math.abs(o[t - 1] - u) || "next" === e.swipeDirection ? o[t] : o[t - 1], u = -u } if (f && i("transitionEnd", (() => { e.loopFix() })), 0 !== e.velocity) { if (t = a ? Math.abs((-u - e.translate) / e.velocity) : Math.abs((u - e.translate) / e.velocity), r.freeMode.sticky) { const n = Math.abs((a ? -u : u) - e.translate), i = e.slidesSizesGrid[e.activeIndex]; t = n < i ? r.speed : n < 2 * i ? 1.5 * r.speed : 2.5 * r.speed } } else if (r.freeMode.sticky) return void e.slideToClosest(); r.freeMode.momentumBounce && d ? (e.updateProgress(h), e.setTransition(t), e.setTranslate(u), e.transitionStart(!0, e.swipeDirection), e.animating = !0, s.transitionEnd((() => { e && !e.destroyed && l.allowMomentumBounce && (n("momentumBounce"), e.setTransition(r.speed), setTimeout((() => { e.setTranslate(h), s.transitionEnd((() => { e && !e.destroyed && e.transitionEnd() })) }), 0)) }))) : e.velocity ? (n("_freeModeNoMomentumRelease"), e.updateProgress(u), e.setTransition(t), e.setTranslate(u), e.transitionStart(!0, e.swipeDirection), e.animating || (e.animating = !0, s.transitionEnd((() => { e && !e.destroyed && e.transitionEnd() })))) : e.updateProgress(u), e.updateActiveIndex(), e.updateSlidesClasses() } else { if (r.freeMode.sticky) return void e.slideToClosest(); r.freeMode && n("_freeModeNoMomentumRelease") } (!r.freeMode.momentum || c >= r.longSwipesMs) && (e.updateProgress(), e.updateActiveIndex(), e.updateSlidesClasses()) } } } }) }, function ({ swiper: e, extendParams: t }) { let n, i, r; t({ grid: { rows: 1, fill: "column" } }), e.grid = { initSlides: t => { const { slidesPerView: s } = e.params, { rows: a, fill: o } = e.params.grid; i = n / a, r = Math.floor(t / a), n = Math.floor(t / a) === t / a ? t : Math.ceil(t / a) * a, "auto" !== s && "row" === o && (n = Math.max(n, s * a)) }, updateSlide: (t, s, a, o) => { const { slidesPerGroup: l, spaceBetween: c } = e.params, { rows: u, fill: h } = e.params.grid; let d, p, f; if ("row" === h && l > 1) { const e = Math.floor(t / (l * u)), i = t - u * l * e, r = 0 === e ? l : Math.min(Math.ceil((a - e * u * l) / u), l); f = Math.floor(i / r), p = i - f * r + e * l, d = p + f * n / u, s.css({ "-webkit-order": d, order: d }) } else "column" === h ? (p = Math.floor(t / u), f = t - p * u, (p > r || p === r && f === u - 1) && (f += 1, f >= u && (f = 0, p += 1))) : (f = Math.floor(t / i), p = t - f * i); s.css(o("margin-top"), 0 !== f ? c && `${c}px` : "") }, updateWrapperSize: (t, i, r) => { const { spaceBetween: s, centeredSlides: a, roundLengths: o } = e.params, { rows: l } = e.params.grid; if (e.virtualSize = (t + s) * n, e.virtualSize = Math.ceil(e.virtualSize / l) - s, e.$wrapperEl.css({ [r("width")]: `${e.virtualSize + s}px` }), a) { i.splice(0, i.length); const t = []; for (let n = 0; n < i.length; n += 1) { let r = i[n]; o && (r = Math.floor(r)), i[n] < e.virtualSize + i[0] && t.push(r) } i.push(...t) } } } }, function ({ swiper: e }) { Object.assign(e, { appendSlide: ex.bind(e), prependSlide: tx.bind(e), addSlide: nx.bind(e), removeSlide: ix.bind(e), removeAllSlides: rx.bind(e) }) }, function ({ swiper: e, extendParams: t, on: n }) { t({ fadeEffect: { crossFade: !1, transformEl: null } }), sx({ effect: "fade", swiper: e, on: n, setTranslate: () => { const { slides: t } = e, n = e.params.fadeEffect; for (let i = 0; i < t.length; i += 1) { const t = e.slides.eq(i); let r = -t[0].swiperSlideOffset; e.params.virtualTranslate || (r -= e.translate); let s = 0; e.isHorizontal() || (s = r, r = 0); const a = e.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(t[0].progress), 0) : 1 + Math.min(Math.max(t[0].progress, -1), 0); ax(n, t).css({ opacity: a }).transform(`translate3d(${r}px, ${s}px, 0px)`) } }, setTransition: t => { const { transformEl: n } = e.params.fadeEffect; (n ? e.slides.find(n) : e.slides).transition(t), ox({ swiper: e, duration: t, transformEl: n, allSlides: !0 }) }, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !e.params.cssMode }) }) }, function ({ swiper: e, extendParams: t, on: n }) { t({ cubeEffect: { slideShadows: !0, shadow: !0, shadowOffset: 20, shadowScale: .94 } }), sx({ effect: "cube", swiper: e, on: n, setTranslate: () => { const { $el: t, $wrapperEl: n, slides: i, width: r, height: s, rtlTranslate: a, size: o, browser: l } = e, c = e.params.cubeEffect, u = e.isHorizontal(), h = e.virtual && e.params.virtual.enabled; let d, p = 0; c.shadow && (u ? (d = n.find(".swiper-cube-shadow"), 0 === d.length && (d = vy('<div class="swiper-cube-shadow"></div>'), n.append(d)), d.css({ height: `${r}px` })) : (d = t.find(".swiper-cube-shadow"), 0 === d.length && (d = vy('<div class="swiper-cube-shadow"></div>'), t.append(d)))); for (let e = 0; e < i.length; e += 1) { const t = i.eq(e); let n = e; h && (n = parseInt(t.attr("data-swiper-slide-index"), 10)); let r = 90 * n, s = Math.floor(r / 360); a && (r = -r, s = Math.floor(-r / 360)); const l = Math.max(Math.min(t[0].progress, 1), -1); let d = 0, f = 0, m = 0; n % 4 == 0 ? (d = 4 * -s * o, m = 0) : (n - 1) % 4 == 0 ? (d = 0, m = 4 * -s * o) : (n - 2) % 4 == 0 ? (d = o + 4 * s * o, m = o) : (n - 3) % 4 == 0 && (d = -o, m = 3 * o + 4 * o * s), a && (d = -d), u || (f = d, d = 0); const g = `rotateX(${u ? 0 : -r}deg) rotateY(${u ? r : 0}deg) translate3d(${d}px, ${f}px, ${m}px)`; if (l <= 1 && l > -1 && (p = 90 * n + 90 * l, a && (p = 90 * -n - 90 * l)), t.transform(g), c.slideShadows) { let e = u ? t.find(".swiper-slide-shadow-left") : t.find(".swiper-slide-shadow-top"), n = u ? t.find(".swiper-slide-shadow-right") : t.find(".swiper-slide-shadow-bottom"); 0 === e.length && (e = vy(`<div class="swiper-slide-shadow-${u ? "left" : "top"}"></div>`), t.append(e)), 0 === n.length && (n = vy(`<div class="swiper-slide-shadow-${u ? "right" : "bottom"}"></div>`), t.append(n)), e.length && (e[0].style.opacity = Math.max(-l, 0)), n.length && (n[0].style.opacity = Math.max(l, 0)) } } if (n.css({ "-webkit-transform-origin": `50% 50% -${o / 2}px`, "transform-origin": `50% 50% -${o / 2}px` }), c.shadow) if (u) d.transform(`translate3d(0px, ${r / 2 + c.shadowOffset}px, ${-r / 2}px) rotateX(90deg) rotateZ(0deg) scale(${c.shadowScale})`); else { const e = Math.abs(p) - 90 * Math.floor(Math.abs(p) / 90), t = 1.5 - (Math.sin(2 * e * Math.PI / 360) / 2 + Math.cos(2 * e * Math.PI / 360) / 2), n = c.shadowScale, i = c.shadowScale / t, r = c.shadowOffset; d.transform(`scale3d(${n}, 1, ${i}) translate3d(0px, ${s / 2 + r}px, ${-s / 2 / i}px) rotateX(-90deg)`) } const f = l.isSafari || l.isWebView ? -o / 2 : 0; n.transform(`translate3d(0px,0,${f}px) rotateX(${e.isHorizontal() ? 0 : p}deg) rotateY(${e.isHorizontal() ? -p : 0}deg)`) }, setTransition: t => { const { $el: n, slides: i } = e; i.transition(t).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(t), e.params.cubeEffect.shadow && !e.isHorizontal() && n.find(".swiper-cube-shadow").transition(t) }, perspective: () => !0, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, resistanceRatio: 0, spaceBetween: 0, centeredSlides: !1, virtualTranslate: !0 }) }) }, function ({ swiper: e, extendParams: t, on: n }) { t({ flipEffect: { slideShadows: !0, limitRotation: !0, transformEl: null } }), sx({ effect: "flip", swiper: e, on: n, setTranslate: () => { const { slides: t, rtlTranslate: n } = e, i = e.params.flipEffect; for (let r = 0; r < t.length; r += 1) { const s = t.eq(r); let a = s[0].progress; e.params.flipEffect.limitRotation && (a = Math.max(Math.min(s[0].progress, 1), -1)); const o = s[0].swiperSlideOffset; let l = -180 * a, c = 0, u = e.params.cssMode ? -o - e.translate : -o, h = 0; if (e.isHorizontal() ? n && (l = -l) : (h = u, u = 0, c = -l, l = 0), s[0].style.zIndex = -Math.abs(Math.round(a)) + t.length, i.slideShadows) { let t = e.isHorizontal() ? s.find(".swiper-slide-shadow-left") : s.find(".swiper-slide-shadow-top"), n = e.isHorizontal() ? s.find(".swiper-slide-shadow-right") : s.find(".swiper-slide-shadow-bottom"); 0 === t.length && (t = lx(i, s, e.isHorizontal() ? "left" : "top")), 0 === n.length && (n = lx(i, s, e.isHorizontal() ? "right" : "bottom")), t.length && (t[0].style.opacity = Math.max(-a, 0)), n.length && (n[0].style.opacity = Math.max(a, 0)) } const d = `translate3d(${u}px, ${h}px, 0px) rotateX(${c}deg) rotateY(${l}deg)`; ax(i, s).transform(d) } }, setTransition: t => { const { transformEl: n } = e.params.flipEffect; (n ? e.slides.find(n) : e.slides).transition(t).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(t), ox({ swiper: e, duration: t, transformEl: n }) }, perspective: () => !0, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !e.params.cssMode }) }) }, function ({ swiper: e, extendParams: t, on: n }) { t({ coverflowEffect: { rotate: 50, stretch: 0, depth: 100, scale: 1, modifier: 1, slideShadows: !0, transformEl: null } }), sx({ effect: "coverflow", swiper: e, on: n, setTranslate: () => { const { width: t, height: n, slides: i, slidesSizesGrid: r } = e, s = e.params.coverflowEffect, a = e.isHorizontal(), o = e.translate, l = a ? t / 2 - o : n / 2 - o, c = a ? s.rotate : -s.rotate, u = s.depth; for (let e = 0, t = i.length; e < t; e += 1) { const t = i.eq(e), n = r[e], o = (l - t[0].swiperSlideOffset - n / 2) / n * s.modifier; let h = a ? c * o : 0, d = a ? 0 : c * o, p = -u * Math.abs(o), f = s.stretch; "string" == typeof f && -1 !== f.indexOf("%") && (f = parseFloat(s.stretch) / 100 * n); let m = a ? 0 : f * o, g = a ? f * o : 0, v = 1 - (1 - s.scale) * Math.abs(o); Math.abs(g) < .001 && (g = 0), Math.abs(m) < .001 && (m = 0), Math.abs(p) < .001 && (p = 0), Math.abs(h) < .001 && (h = 0), Math.abs(d) < .001 && (d = 0), Math.abs(v) < .001 && (v = 0); const y = `translate3d(${g}px,${m}px,${p}px)  rotateX(${d}deg) rotateY(${h}deg) scale(${v})`; if (ax(s, t).transform(y), t[0].style.zIndex = 1 - Math.abs(Math.round(o)), s.slideShadows) { let e = a ? t.find(".swiper-slide-shadow-left") : t.find(".swiper-slide-shadow-top"), n = a ? t.find(".swiper-slide-shadow-right") : t.find(".swiper-slide-shadow-bottom"); 0 === e.length && (e = lx(s, t, a ? "left" : "top")), 0 === n.length && (n = lx(s, t, a ? "right" : "bottom")), e.length && (e[0].style.opacity = o > 0 ? o : 0), n.length && (n[0].style.opacity = -o > 0 ? -o : 0) } } }, setTransition: t => { const { transformEl: n } = e.params.coverflowEffect; (n ? e.slides.find(n) : e.slides).transition(t).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(t) }, perspective: () => !0, overwriteParams: () => ({ watchSlidesProgress: !0 }) }) }, function ({ swiper: e, extendParams: t, on: n }) { t({ creativeEffect: { transformEl: null, limitProgress: 1, shadowPerProgress: !1, progressMultiplier: 1, perspective: !0, prev: { translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1 }, next: { translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1 } } }); const i = e => "string" == typeof e ? e : `${e}px`; sx({ effect: "creative", swiper: e, on: n, setTranslate: () => { const { slides: t, $wrapperEl: n, slidesSizesGrid: r } = e, s = e.params.creativeEffect, { progressMultiplier: a } = s, o = e.params.centeredSlides; if (o) { const t = r[0] / 2 - e.params.slidesOffsetBefore || 0; n.transform(`translateX(calc(50% - ${t}px))`) } for (let n = 0; n < t.length; n += 1) { const r = t.eq(n), l = r[0].progress, c = Math.min(Math.max(r[0].progress, -s.limitProgress), s.limitProgress); let u = c; o || (u = Math.min(Math.max(r[0].originalProgress, -s.limitProgress), s.limitProgress)); const h = r[0].swiperSlideOffset, d = [e.params.cssMode ? -h - e.translate : -h, 0, 0], p = [0, 0, 0]; let f = !1; e.isHorizontal() || (d[1] = d[0], d[0] = 0); let m = { translate: [0, 0, 0], rotate: [0, 0, 0], scale: 1, opacity: 1 }; c < 0 ? (m = s.next, f = !0) : c > 0 && (m = s.prev, f = !0), d.forEach(((e, t) => { d[t] = `calc(${e}px + (${i(m.translate[t])} * ${Math.abs(c * a)}))` })), p.forEach(((e, t) => { p[t] = m.rotate[t] * Math.abs(c * a) })), r[0].style.zIndex = -Math.abs(Math.round(l)) + t.length; const g = d.join(", "), v = `rotateX(${p[0]}deg) rotateY(${p[1]}deg) rotateZ(${p[2]}deg)`, y = u < 0 ? `scale(${1 + (1 - m.scale) * u * a})` : `scale(${1 - (1 - m.scale) * u * a})`, x = u < 0 ? 1 + (1 - m.opacity) * u * a : 1 - (1 - m.opacity) * u * a, _ = `translate3d(${g}) ${v} ${y}`; if (f && m.shadow || !f) { let e = r.children(".swiper-slide-shadow"); if (0 === e.length && m.shadow && (e = lx(s, r)), e.length) { const t = s.shadowPerProgress ? c * (1 / s.limitProgress) : c; e[0].style.opacity = Math.min(Math.max(Math.abs(t), 0), 1) } } const w = ax(s, r); w.transform(_).css({ opacity: x }), m.origin && w.css("transform-origin", m.origin) } }, setTransition: t => { const { transformEl: n } = e.params.creativeEffect; (n ? e.slides.find(n) : e.slides).transition(t).find(".swiper-slide-shadow").transition(t), ox({ swiper: e, duration: t, transformEl: n, allSlides: !0 }) }, perspective: () => e.params.creativeEffect.perspective, overwriteParams: () => ({ watchSlidesProgress: !0, virtualTranslate: !e.params.cssMode }) }) }, function ({ swiper: e, extendParams: t, on: n }) { t({ cardsEffect: { slideShadows: !0, transformEl: null } }), sx({ effect: "cards", swiper: e, on: n, setTranslate: () => { const { slides: t, activeIndex: n } = e, i = e.params.cardsEffect, { startTranslate: r, isTouched: s } = e.touchEventsData, a = e.translate; for (let o = 0; o < t.length; o += 1) { const l = t.eq(o), c = l[0].progress, u = Math.min(Math.max(c, -4), 4); let h = l[0].swiperSlideOffset; e.params.centeredSlides && !e.params.cssMode && e.$wrapperEl.transform(`translateX(${e.minTranslate()}px)`), e.params.centeredSlides && e.params.cssMode && (h -= t[0].swiperSlideOffset); let d = e.params.cssMode ? -h - e.translate : -h, p = 0; const f = -100 * Math.abs(u); let m = 1, g = -2 * u, v = 8 - .75 * Math.abs(u); const y = (o === n || o === n - 1) && u > 0 && u < 1 && (s || e.params.cssMode) && a < r, x = (o === n || o === n + 1) && u < 0 && u > -1 && (s || e.params.cssMode) && a > r; if (y || x) { const e = (1 - Math.abs((Math.abs(u) - .5) / .5)) ** .5; g += -28 * u * e, m += -.5 * e, v += 96 * e, p = -25 * e * Math.abs(u) + "%" } if (d = u < 0 ? `calc(${d}px + (${v * Math.abs(u)}%))` : u > 0 ? `calc(${d}px + (-${v * Math.abs(u)}%))` : `${d}px`, !e.isHorizontal()) { const e = p; p = d, d = e } const _ = `\n        translate3d(${d}, ${p}, ${f}px)\n        rotateZ(${g}deg)\n        scale(${u < 0 ? "" + (1 + (1 - m) * u) : "" + (1 - (1 - m) * u)})\n      `; if (i.slideShadows) { let e = l.find(".swiper-slide-shadow"); 0 === e.length && (e = lx(i, l)), e.length && (e[0].style.opacity = Math.min(Math.max((Math.abs(u) - .5) / .5, 0), 1)) } l[0].style.zIndex = -Math.abs(Math.round(c)) + t.length, ax(i, l).transform(_) } }, setTransition: t => { const { transformEl: n } = e.params.cardsEffect; (n ? e.slides.find(n) : e.slides).transition(t).find(".swiper-slide-shadow").transition(t), ox({ swiper: e, duration: t, transformEl: n }) }, perspective: () => !0, overwriteParams: () => ({ watchSlidesProgress: !0, virtualTranslate: !e.params.cssMode }) }) }]; Ky.use(cx), Ci.registerPlugin(fa); const ux = { beforeEnter(e) { const t = e.next.container, n = document.head, i = e.next.html.match(/<head[^>]*>([\s\S.]*)<\/head>/i)[0], r = document.createElement("head"); r.innerHTML = i; const s = ["meta[name='keywords']", "meta[name='description']", "meta[property^='og']", "meta[name^='twitter']", "meta[itemprop]", "link[itemprop]", "link[rel='prev']", "link[rel='next']", "link[rel='canonical']"].join(","), a = n.querySelectorAll(s); for (let e = 0; e < a.length; e++)n.removeChild(a[e]); const o = r.querySelectorAll(s); for (let e = 0; e < o.length; e++)n.appendChild(o[e]); null === removeEventFunctions && (removeEventFunctions = []), null === pageLoadObjects && (pageLoadObjects = []), removeEventFunctions.push(function (e) { let t = ty(); const n = document.querySelector(".js-header"), i = e.querySelectorAll(".js_fullHeight"), r = function () { const e = .01 * window.innerHeight; for (let t = 0; t < i.length; t++)i[t].style.setProperty("--initVh", `${e}px`) }; window.addEventListener("resize", r); const s = e.querySelectorAll(".js-link-btn"); s && s.forEach((e => { const n = e.dataset.href; n && t.addEventListener(e, "click", (e => { window.location.href = n })) })), document.querySelectorAll(".button,.button-strong").forEach((e => { e.classList.add("animation-text-btn", "relative"), e.setAttribute("data-hover", e.textContent); const t = '<span class="animation-button-text inline-block">' + e.textContent + "</span>"; e.innerHTML = t })); const a = e.querySelectorAll(".js-list-link-title"); a.forEach((e => { const n = e.offsetHeight, i = e.querySelector(".js-list-link-desc"), r = e.querySelector(".js-list-link-desc-2"); if (window.innerWidth > 1023 ? e.classList.contains("in-desc") ? e.style.transform = "translateY(calc(100% - 37px))" : e.style.transform = "translateY(calc(100% - 55px))" : document.documentElement.clientWidth > 767 ? e.classList.contains("in-desc") ? e.style.transform = "translateY(calc(100% - 2.7rem))" : e.style.transform = "translateY(calc(100% - 2.2rem))" : 2 == a.length ? e.style.transform = "translateY(calc(100% - 62px))" : e.style.transform = "translateY(calc(100% - 49px))", n < 80) { if (!i) return; i.style.top = 0 } if (r.clientHeight > 10) { if (void 0 !== window.ontouchstart && 0 < navigator.maxTouchPoints) return; const n = e.closest(".js-link-title-hover"); t.addEventListener(n, "mouseenter", (e => { e.preventDefault(), e.target.querySelector(".js-list-link-title").style.transform = "translateY(calc(100% - 120px))" })), t.addEventListener(n, "mouseleave", (e => { e.preventDefault(), e.target.querySelector(".js-list-link-title").style.transform = "translateY(calc(100% - 37px))" })) } })); const o = e.querySelectorAll(".js_pager"); let l, c, u; const h = function (e) { const t = document.querySelector(".js-button-pager.active"), n = parseInt(null == t ? void 0 : t.getAttribute("data-index")), i = parseInt(e.target.getAttribute("data-index")), r = document.querySelectorAll(".js-button-pager"), s = r.length - 1, a = document.querySelector(".js-button-pager-circle"), o = n - i; a.classList.remove("bg-solution-color-" + (n + 1)), a.classList.add("bg-solution-color-" + (i + 1)), fa.matchMedia({ "(min-width: 768px)": () => { c = 2, u = "rem" }, "(max-width: 767px)": () => { c = 40, u = "px" } }), l && l.kill(), l = Ci.timeline(), o < 0 ? (l.set(a, { left: n * c + u, right: "auto", x: 5 }), l.to(a, { width: c + Math.abs(n - i) * c + u, duration: .2, ease: "power3.in" }), l.set(a, { left: "auto", right: (s - i) * c + u, x: -5 })) : (l.set(a, { left: "auto", right: (s - n) * c + u, x: -5 }), l.to(a, { width: c + Math.abs(n - i) * c + u, duration: .2, ease: "power3.in" }), l.set(a, { left: i * c + u, right: "auto", x: 5 })), l.to(a, { width: c + u, duration: .4, ease: "power3.out" }), r[n].classList.remove("active"), r[i].classList.add("active") }; o.forEach((e => { const n = e.querySelectorAll(".js-button-pager"), i = e.querySelector(".js-button-pager.active"), r = null == i ? void 0 : i.getAttribute("data-index"); e.querySelector(".js-button-pager-circle").style.transform = `translateX(${100 * r}%)`, n.forEach((e => { t.addEventListener(e, "click", h) })) })), e.querySelectorAll(".js-link-line").forEach((e => { t.addEventListener(e, "mouseenter", (t => { if (t.preventDefault(), t.target.classList.contains("js-link-line-self")) t.target.classList.add("is-active"); else { const t = e.closest(".js-link-line-parent"); t && t.classList.add("is-active") } })), t.addEventListener(e, "mouseleave", (t => { if (t.preventDefault(), t.target.classList.contains("js-link-line-self")) t.target.classList.remove("is-active"); else { const t = e.closest(".js-link-line-parent"); t && t.classList.remove("is-active") } })) })), e.querySelectorAll(".js-hover-class").forEach((e => { t.addEventListener(e, "mouseenter", (e => { e.preventDefault(); const t = e.target; t.classList.remove(t.dataset.unHover), t.classList.add(t.dataset.hover), t.classList.add("hover") })), t.addEventListener(e, "mouseleave", (e => { e.preventDefault(); const t = e.target; t.classList.remove(t.dataset.hover), t.classList.add(t.dataset.unHover), t.classList.remove("hover") })) })); const d = e.querySelector("#breadcrumbs-list"); let p; function f() { let e = 0; d.querySelectorAll("li").forEach((t => { e += t.clientWidth })), d.clientWidth < e ? d.classList.add("active") : d.classList.remove("active") } d && (n.classList.contains("bg-header-white") && d.classList.add("is-bg-white"), f(), t.addEventListener(window, "resize", (() => { p || (p = setTimeout((function () { p = 0, f() }), 200)) }))); const m = e.querySelector(".js-solution-kv"); if (m) { let e = function () { if (window.innerWidth > 1024) { const e = i.offsetTop; m.clientHeight - e < 140 && Ci.set(m, { height: m.clientHeight + 140 }) } }, n = null; const i = m.querySelector("a"); e(), t.addEventListener(window, "resize", (() => { n || (n = setTimeout((function () { n = 0, e() }), 200)) })) } e.querySelectorAll(".js-next-member").forEach((e => { const n = e.querySelector(".js-arrow-box"); t.addEventListener(e, "mouseover", (() => { Ci.to(n, 1, { ease: "expo.out", x: "130%", duration: .9 }) })), t.addEventListener(e, "mouseleave", (() => { Ci.to(n, 1, { ease: "expo.out", x: 0, duration: .9 }) })) })); const g = e.querySelector("#js-sp-sns"); if (g) { const i = e.querySelectorAll(".js-show-sp-sns"), r = e.querySelector("#js-hide-sp-sns"), s = e.querySelector("#js-sp-sns-container"); if (window.innerWidth < 768 && i && r) { i.forEach((e => { t.addEventListener(e, "click", (() => { g.classList.contains("js-hidden") && (g.classList.remove("js-hidden", "pointer-events-none", "bg-transparent"), document.querySelector("html").classList.add("overflow-hidden"), g.classList.add("bg-[rgba(47,47,47,.4)]", "js-show"), s.classList.remove("translate-y-full"), s.classList.add("translate-y-0"), Ci.set(n, { zIndex: 10 })) })) })), r.addEventListener("click", (() => { g.classList.contains("js-show") && (g.classList.add("js-hidden", "pointer-events-none", "bg-transparent"), document.querySelector("html").classList.remove("overflow-hidden"), g.classList.remove("bg-[rgba(47,47,47,.4)]", "js-show"), s.classList.remove("translate-y-0"), s.classList.add("translate-y-full"), Ci.set(n, { clearProps: "z-index" })) })); const a = e.querySelector("#js-copy-url"); e.querySelector("#js-copy-url-text"), t.addEventListener(a, "click", (e => { e.preventDefault(); const t = document.createElement("input"); t.value = location.href, document.body.appendChild(t), t.select(), document.execCommand("copy"), document.body.removeChild(t), alert("コピーしました") })) } } return function () { window.removeEventListener("resize", r), t.destroy() } }(t)), removeEventFunctions.push(function (e) { e.querySelectorAll(".js-large-image").forEach((e => { const t = e.querySelector(".large-image-animate"), n = e.querySelector(".large-image-parent"); Ci.timeline({ scrollTrigger: { trigger: e, start: () => "top bottom", once: !0, toggleClass: { targets: [t, n], className: "js-scrollShow" }, invalidateOnRefresh: !0 } }) })); const t = e.querySelectorAll(".js-animated-text-mask"); t && (0, t.forEach((e => { if (0 == e.clientHeight) return; const t = new ho(e, { type: "lines" }); Ci.timeline({ scrollTrigger: { trigger: e, start: () => "top 90%", once: !0, invalidateOnRefresh: !0 } }).set(t.lines, { delay: 0, y: "0%", opacity: 1, stagger: .2 }) }))); const n = e.querySelectorAll(".js-animated-text-head"); n && n.forEach((e => { 0 != e.clientHeight && Ci.to(e, { y: "0%", opacity: 1 }) })); const i = e.querySelectorAll(".js-animated-head-split"); return i && (e => { e.forEach((e => { if (0 == e.clientHeight) return; const t = new ho(e, { type: "chars" }); Ci.set(t.chars, { yPercent: 110, opacity: 0 }), Ci.to(t.chars, { yPercent: 0, opacity: 1, stagger: .05, onStart: () => { e.classList.add("js-splitLines") } }) })) })(i), function () { } }(t)), removeEventFunctions.push(function (e) { const t = e.querySelectorAll(".scroll-text-container"); Ci.registerPlugin(fa); const n = function (e, t) { document.querySelector("html").classList.contains("wf-active") ? ((e, t, n = !1) => { const i = document.querySelector(e), r = i.classList.contains("js_mvScrollText"), s = r ? "center center" : "top bottom", a = r ? .4 : 0; if (r) { const t = new ho(e, { type: "chars" }); Ci.set(t.chars, { yPercent: 110, opacity: 0 }), Ci.to(t.chars, { delay: a, yPercent: 0, opacity: 1, stagger: .05, onStart: () => { i.querySelectorAll(".scroll-text").forEach((e => { e.classList.add("js-splitLines") })) } }) } Ci.timeline().to(e, { delay: a, x: () => -1 * t.clientWidth, duration: () => t.clientWidth / window.innerWidth * 10, repeat: -1, ease: "none" }), Ci.timeline().to(e, { xPercent: -100, scrollTrigger: { start: s, end: "bottom top", trigger: e, ease: "power3.inOut", scrub: .8 } }) })(e, t, !1) : requestAnimationFrame((() => { n(e, t) })) }; for (let e = 0; e < t.length; e++) { const i = "#" + t[e].getAttribute("id"), r = t[e].querySelectorAll(".scroll-text")[0]; n(i, r) } return function () { } }(t)), removeEventFunctions.push(function (e, t = !1) { let n = ty(); const i = e.querySelector("#js-scroll-button"); if ((t ? document.querySelectorAll(".js-scroll-button-selection") : e.querySelectorAll(".js-scroll-button-selection")).forEach((t => { n.addEventListener(t, "click", (t => { t.preventDefault(); const n = e.querySelector(t.target.closest("a").getAttribute("href")); let i = n.offsetTop - document.querySelector(".js-header").offsetHeight; n.dataset.scrollajust && (i += parseInt(n.dataset.scrollajust)), window.scrollTo({ top: i, left: 0, behavior: "smooth" }); const r = t.target.closest("a").parentElement; if (r.parentElement.classList.contains("sticky-position") && t.target.closest("a").classList.contains("inactive-link")) { const e = r.parentElement.querySelector(".active-link"); e.classList.remove("active-link"), e.classList.add("inactive-link"), t.target.closest("a").classList.remove("inactive-link"), t.target.closest("a").classList.add("active-link") } })) })), i) return n.addEventListener(i, "click", (e => { e.preventDefault(), window.scrollTo({ top: `${document.querySelector(i.getAttribute("href")).offsetTop}`, left: 0, behavior: "smooth" }) })), function () { n.destroy() } }(t)), removeEventFunctions.push(function (e) { const t = new Ky(e.querySelector(".js-slider-specialist"), { touchReleaseOnEdges: !0, grabCursor: !0, direction: "horizontal", freeMode: { enabled: !0, momentumRatio: .6, momentumVelocityRatio: .6 }, mousewheel: { forceToAxis: !0 }, breakpoints: { 320: { slidesPerView: "auto" }, 768: { slidesPerView: "3" } } }); return function () { t.destroy(!0, !1) } }(t)), removeEventFunctions.push(function (e) { const t = e.querySelector("#js-sticky-scroll"); if (!t) return; let n = Ci.utils.toArray(t.querySelectorAll(".js-sticky-scroll-item")), i = Ci.utils.toArray(t.querySelectorAll(".js-scroll-button-selection")); const r = document.querySelector(".js-header").offsetHeight; return n.forEach(((e, t, n) => { let s = "start " + r; e.dataset.minus && (s = e.dataset.minus + " " + r), fa.create({ trigger: "#" + e.dataset.target, start: s, end: "bottom " + r, markers: !1, toggleClass: { targets: i[t], className: "active-link" } }) })), function () { } }(t)), removeEventFunctions.push(function (e) { const t = new Ky(e.querySelector(".js-swiper"), { slidesPerView: "auto", autoHeight: !0, touchReleaseOnEdges: !0, grabCursor: !0, freeMode: { enabled: !0, momentumRatio: .8, momentumVelocityRatio: .8 }, keyboard: { enabled: !0, onlyInViewport: !0 }, mousewheel: { forceToAxis: !0 } }); return function () { t.destroy(!0, !1) } }(t)), removeEventFunctions.push(function (e) { let t = null; return window.LIG.mql.matches && (t = new Ky(e.querySelector("#js-side-scroller"), { slidesPerView: "auto", grabCursor: !0, touchReleaseOnEdges: !0, freeMode: { enabled: !0, momentumRatio: .8, momentumVelocityRatio: .8 }, keyboard: { enabled: !0, onlyInViewport: !1 }, mousewheel: { forceToAxis: !0 }, scrollbar: { el: "#js-progress" } })), function () { t && t.destroy(!0, !1) } }(t)), removeEventFunctions.push(function (e) { let t = ty(); e.querySelectorAll(".js-toggle-list").forEach((e => { e.querySelectorAll(".js-toggle").forEach(((e, t) => { e.classList.remove("js-toggle-active"), e.classList.add("js-toggle-inactive") })) })); const n = e.querySelectorAll(".js-toggle-header"); return n.forEach((e => { const i = e.parentElement; t.addEventListener(e, "click", (() => { const e = i.classList.contains("js-toggle-active"); n.forEach((e => { e.parentElement.classList.remove("js-toggle-active"), e.parentElement.classList.add("js-toggle-inactive") })), e ? (i.classList.remove("js-toggle-active"), i.classList.add("js-toggle-inactive")) : (i.classList.add("js-toggle-active"), i.classList.remove("js-toggle-inactive")) })) })), function () { t.destroy() } }(t)), removeEventFunctions.push(function (e) { let t = ty(); return e.querySelectorAll(".js-hover-move-btn").forEach((e => { let n = { x: 0, y: 0 }, i = { x: 0, y: 0 }, r = 1, s = null; t.addEventListener(e, "mousemove", (function (t) { e.classList.add("isMoving"), n.x = .5 * (t.offsetX - t.currentTarget.clientWidth / 2), n.y = .5 * (t.offsetY - t.currentTarget.clientWidth / 2), null === s && a() })), t.addEventListener(e, "mouseout", (function (t) { e.classList.remove("isMoving"), n = { x: 0, y: 0 }, i = { x: 0, y: 0 }, r = 1, Ci.set(e, { clearProps: "all" }), o() })); const a = function () { i.x += .08 * (n.x - i.x), i.y += .08 * (n.y - i.y), r += .1 * (1.1 - r), Ci.set(e, { x: i.x, y: i.y, scale: r }), s = requestAnimationFrame((() => { a() })) }, o = function () { cancelAnimationFrame(s), s = null } })), function () { t.destroy() } }(t)), window.scrollTo({ top: 0, left: 0, behavior: "smooth" }) }, afterEnter(e) { const t = e.next.container; pageLoadObjects = null, "front_page" != e.next.namespace && ("blog_single_page" == e.next.namespace || removeEventFunctions.push(iy(t))) }, beforeLeave(e) { removeEventFunctions.forEach((e => { e && e() })) }, leave() { }, afterLeave() { removeEventFunctions = null, fa.getAll().forEach((e => { e.kill() })) } }; function hx(e, t) { const n = e.querySelector("#slider"), i = n.querySelector(".js_sliderImg"), r = n.querySelectorAll(".js_sliderHdg").length, s = n.querySelectorAll(".js_sliderHdg"), a = n.querySelectorAll(".js_sliderTxt"), o = n.querySelector(".js_sliderLink"), l = n.querySelector(".js_sliderUI"); let c, u, h, d = new Array(r); s[0].classList.add("js_sliderFadeOutBottom"), a[0].classList.add("js_sliderFadeOutBottom"), i.classList.add("js_sliderFadeOutBottom"), o.classList.add("js_sliderFadeOutBottom"), l.classList.add("js_sliderFadeOutBottom"); const p = n.querySelector(".js_sliderBg").querySelector("div"); Ci.to(p, { scaleY: 0 }); let f = 0, m = { progress: 0 }; const g = Ci.timeline({ scrollTrigger: { trigger: n, start: () => "center center", end: () => "+=" + t * r * 1.5, pin: !0, invalidateOnRefresh: !0, onEnter: () => { s[0].classList.remove("js_sliderFadeOutBottom"), a[0].classList.remove("js_sliderFadeOutBottom"), i.classList.remove("js_sliderFadeOutBottom"), o.classList.remove("js_sliderFadeOutBottom"), l.classList.remove("js_sliderFadeOutBottom"), Ci.to(p, { scaleY: 1, duration: .8, ease: "expo.out", transformOrigin: "50% bottom" }), d[f] = i.querySelectorAll("video")[f].play() }, onLeaveBack: () => { s[0].classList.add("js_sliderFadeOutBottom"), a[0].classList.add("js_sliderFadeOutBottom"), i.classList.add("js_sliderFadeOutBottom"), o.classList.add("js_sliderFadeOutBottom"), l.classList.add("js_sliderFadeOutBottom"), Ci.to(p, { scaleY: 0, duration: .8, ease: "expo.out", transformOrigin: "50% bottom" }), void 0 !== d[f] && d[f].then((() => { i.querySelectorAll("video")[f].pause() })) }, onLeave: () => { s[r - 1].classList.add("js_sliderFadeOutTop"), a[r - 1].classList.add("js_sliderFadeOutTop"), i.classList.add("js_sliderFadeOutTop"), o.classList.add("js_sliderFadeOutTop"), l.classList.add("js_sliderFadeOutTop"), Ci.to(p, { scaleY: 0, duration: .4, ease: "circ.out", transformOrigin: "50% top" }), void 0 !== d[f] && d[f].then((() => { i.querySelectorAll("video")[f].pause() })) }, onEnterBack: () => { s[r - 1].classList.remove("js_sliderFadeOutTop"), a[r - 1].classList.remove("js_sliderFadeOutTop"), i.classList.remove("js_sliderFadeOutTop"), o.classList.remove("js_sliderFadeOutTop"), l.classList.remove("js_sliderFadeOutTop"), Ci.to(p, { scaleY: 1, duration: .4, ease: "circ.out", transformOrigin: "50% top" }), d[f] = i.querySelectorAll("video")[f].play() }, onUpdate: t => { const n = ((o = Math.floor(t.progress / .2)) < 0 && (o = 0), o > (l = r - 1) && (o = l), o); var o, l; if (f === n) return; for (let e = 0; e < r; e++)e === n ? (s[e].classList.remove("js_sliderBefore"), s[e].classList.remove("js_sliderAfter"), a[e].classList.remove("js_sliderBefore"), a[e].classList.remove("js_sliderAfter")) : e < n ? (s[e].classList.add("js_sliderAfter"), a[e].classList.add("js_sliderAfter")) : (s[e].classList.add("js_sliderBefore"), a[e].classList.add("js_sliderBefore")); Ci.set(i, { y: -100 * n + "%" }), p.classList.remove("bg-solution-color-" + (f + 1)), p.classList.add("bg-solution-color-" + (n + 1)), d[n] = i.querySelectorAll("video")[n].play(); const m = f; void 0 !== d[m] && d[m].then((() => { i.querySelectorAll("video")[m].pause() })), function (t, n) { const i = e.querySelector("#slider").querySelectorAll(".js_sliderHdg").length - 1, r = e.querySelector(".js-button-pager-slider-circle"), s = e.querySelectorAll(".js-button-pager-slider"), a = t - n, o = e.querySelector("#slider").querySelector(".js_sliderLink"); r.classList.remove("bg-solution-color-" + (t + 1)), r.classList.add("bg-solution-color-" + (n + 1)), fa.matchMedia({ "(min-width: 1024px)": () => { c = 2, u = "rem" }, "(max-width: 1023px)": () => { c = 40, u = "px" } }), h && h.kill(), h = Ci.timeline(), a < 0 ? (h.set(r, { left: t * c + u, right: "auto", x: 5 }), h.to(r, { width: c + Math.abs(t - n) * c + u, duration: .2, ease: "power3.in" }), h.set(r, { left: "auto", right: (i - n) * c + u, x: -5 })) : (h.set(r, { left: "auto", right: (i - t) * c + u, x: -5 }), h.to(r, { width: c + Math.abs(t - n) * c + u, duration: .2, ease: "power3.in" }), h.set(r, { left: n * c + u, right: "auto", x: 5 })), h.to(r, { width: c + u, duration: .2, ease: "power3.out" }), s[t].classList.remove("active"), s[n].classList.add("active"), o.setAttribute("href", s[n].getAttribute("data-href")) }(f, n), f = n } } }); function v(e) { const t = parseInt(e.currentTarget.getAttribute("data-index")) + 1; g.scrollTrigger.scroll(g.scrollTrigger.labelToScroll(t.toString())) } function y() { fa.matchMedia({ "(min-width: 768px)": () => { c = 2, u = "rem" }, "(max-width: 767px)": () => { c = 40, u = "px" } }) } return g.to(m, { progress: .1, duration: .2 }).addLabel("1").to(m, { progress: .3, duration: .2 }).addLabel("2").to(m, { progress: .5, duration: .2 }).addLabel("3").to(m, { progress: .7, duration: .2 }).addLabel("4").to(m, { progress: .9, duration: .2 }).addLabel("5").to(m, { progress: 1, duration: .2 }), y(), function () { const t = e.querySelectorAll(".js-button-pager-slider"), n = e.querySelectorAll(".js-button-pager-slider-circle"), i = e.querySelector(".js-button-pager-slider.active"), r = null == i ? void 0 : i.getAttribute("data-index"), s = e.querySelector("#slider").querySelector(".js_sliderLink"); n.forEach((function (e) { e.style.transform = `translateX(${100 * r}%)` })), s.setAttribute("href", t[0].getAttribute("data-href")), t.forEach((e => { e.addEventListener("click", v) })), window.addEventListener("resize", y) }(), { scrollTrigger: g.scrollTrigger, destroy: function () { e.querySelectorAll(".js-button-pager-slider").forEach((e => { e.removeEventListener("click", v) })), window.addEventListener("resize", y), h && (h.kill(), c = void 0, u = void 0) } } } function dx(e) { if (e.length < 1) return; const t = []; for (let n = 0; n < e.length; n++)t.push(e[n]); let n = { index: 0, progress: 0, notPinPosition: !1 }; function i() { let e = !1; for (let i = 0; i < t.length; i++)t[i].progress > 0 && t[i].progress < 1 && !e && (n.index = i, n.progress = t[i].progress, n.notPinPosition = !1, e = !0); e || (n.notPinPosition = !0, n.progress = window.scrollY) } function r() { const e = t[n.index]; n.notPinPosition ? e.scroll(n.progress) : e.scroll(e.start + (e.end - e.start) * n.progress); for (let e = 0; e < t.length; e++)t[e].refresh(); n = { index: 0, progress: 0, notPinPosition: !1 } } return fa.addEventListener("refreshInit", i), fa.addEventListener("refresh", r), function () { n = void 0, fa.removeEventListener("refreshInit", i), fa.removeEventListener("refresh", r) } } Ci.registerPlugin(fa), Ci.registerPlugin(fa), Ci.registerPlugin(fa, Va), Ci.registerPlugin(fa, ho); const px = { namespace: "front_page", beforeEnter(e) { const t = e.next.container; removeEventFunctions.push(function (e) { const t = e.querySelector(".js-w-full"), n = e.querySelector("#js-preload"), i = document.querySelector(".js-header"), r = document.querySelector(".js-header-logo"), s = e.querySelector("#js-lig-svg"), a = e.querySelector(".js-lig-motion"), o = e.querySelector(".lig-motion-pc"), l = (e.querySelectorAll("#js-lig-svg .lig-item"), e.querySelector(".js-mask-box")), c = e.querySelectorAll(".js-mv-last-object"), u = document.querySelector("#lower-motion-logo"); let h, d, p = ty(), f = sessionStorage.getItem("isTop"); f || (sessionStorage.setItem("isTop", "1"), i.classList.add("bgImageNone")), a && Ci.set(u, { display: "none" }); const m = window.innerWidth, g = window.innerHeight, v = m - document.body.clientWidth; let y = 0; var x, _, w, b, S, E, M, T, C, D; if (!o) return; if (i.style.setProperty("--scrollBar", `${v}px`), Ci.set("body", { overflow: "hidden", height: "100%" }), l) { const e = Math.floor(m / 2), t = window.innerWidth < 768 ? 15 : 50; C = x = Math.floor(e - t), M = x, S = w = Math.floor(e + t), b = _ = g, E = _, T = _, D = _, l.setAttribute("d", "M " + x + " " + _ + " L " + w + " " + b + " L " + S + " " + E + " L " + M + " " + T + " L " + C + " " + D) } let L = o.clientHeight; Ci.set(o, { height: L }); const A = () => { setTimeout((n => { t.classList.remove("opacity-0", "pointer-events-none"); const i = Ci.timeline({ onComplete: () => { const t = e.querySelector(".js-loading-btn-none"), n = e.querySelector(".js-top-modal"), i = n.querySelector("video"), r = e.querySelector(".js-video-play"), s = e.querySelector(".js-video-play-on"), a = e.querySelector(".js-video-play-off"), o = e.querySelector(".js-video-volume"), l = e.querySelector(".js-video-volume-on"), c = e.querySelector(".js-video-volume-off"), u = e.querySelector(".js-video-seek-bar-now"), h = window.LIG.mql.matches ? e.querySelector(".js-video-time-now") : e.querySelector(".js-video-time-now-sp"), d = window.LIG.mql.matches ? e.querySelector(".js-video-time-total") : e.querySelector(".js-video-time-total-sp"); let f = !1; function m(e) { let t = ""; const n = e / 3600 | 0, i = e % 3600 / 60 | 0, r = Math.ceil(e % 60), s = e => { const t = "00" + e; return t.substr(t.length - 2, 2) }; return t = 0 != n ? n + ":" + s(i) + ":" + s(r) : 0 != i ? i + ":" + s(r) : "00:" + s(r), t } p.addEventListener(i, "canplay", (e => { if (!1 === f) { let e = m(i.duration); d.innerHTML = e, i.volume = .6, i.muted = !1, f = !0 } })), p.addEventListener(i, "timeupdate", (e => { let t = m(i.currentTime); h.innerHTML = t; let n = Math.ceil(i.currentTime / i.duration * 100); n > 100 && (n = 100), Ci.set(u, { width: n + "%" }) })), p.addEventListener(r, "click", (e => { e.preventDefault(), !0 === i.paused ? (i.play(), Ci.set(a, { display: "none" }), Ci.set(s, { display: "block" })) : (i.pause(), Ci.set(a, { display: "block" }), Ci.set(s, { display: "none" })) })), p.addEventListener(o, "click", (e => { e.preventDefault(), i.muted ? (i.volume = .6, i.muted = !1, Ci.set(c, { display: "none" }), Ci.set(l, { display: "block" })) : (i.volume = 0, i.muted = !0, Ci.set(c, { display: "block" }), Ci.set(l, { display: "none" })) })), p.addEventListener(t, "click", (() => { n.style.setProperty("--scrollBar", window.innerWidth - document.body.clientWidth + "px"), Ci.set(n, { display: "block" }), i.play(), Ci.to(n, { opacity: 1, pointerEvents: "auto", duration: 1, delay: .1, onComplete: () => { } }) })); let g = document.querySelector(".js-top-modal-close"); p.addEventListener(g, "click", (() => { i.pause(), Ci.to(n, { opacity: 0, duration: 1, onComplete: () => { Ci.set(n, { display: "none" }) } }) })), t.classList.remove("pointer-events-none") } }); i.set(n.lines, { yPercent: 0, opacity: 1, stagger: .2 }), i.set(c, { opacity: 1, y: 0, delay: .45 }), i.play() })(h), 1200), Ci.fromTo(r, { autoAlpha: 1 }, { duration: 0, autoAlpha: 1, delay: 0, ease: "circ.out", onComplete: function () { document.body.removeAttribute("style"), r.removeAttribute("style"), Ci.set(".logo-main", { opacity: 0 }), i.style.setProperty("--scrollBar", "0px"), d = function (e) { const t = window.LIG.mql.matche ? 1100 : 800, n = new ho(".js_scrollHdg_01", { split: "lines chars" }); Ci.set(n.chars, { yPercent: 110, opacity: 0 }), Ci.set(n.lines, { className: "js-splitLines" }), Ci.set(".js_scrollText", { y: () => "" + .1 * t, opacity: 0 }), Ci.timeline({ scrollTrigger: { trigger: "#js-copy-section", start: () => "center bottom", end: () => `+=${t}`, scrub: 1, invalidateOnRefresh: !0, onEnter: () => { Ci.set(n.chars, { yPercent: 0, opacity: 1, stagger: .03 }) } } }).set(".js_scrollText", { y: () => "" + .2 * t, opacity: 0 }).addLabel("start").to(".js_scrollText", { opacity: 1, duration: .4, ease: "circ.out" }, "start").to(".js_scrollText", { y: () => 0, duration: 1, ease: "linear" }, "start"); const i = hx(e, t), r = e.querySelectorAll(".js-propose-text"); r && r.forEach((e => { const t = new ho(e); Ci.set(t.lines, { opacity: 0, yPercent: 110 }), Ci.timeline({ scrollTrigger: { trigger: "#js-propose-section", start: "top bottom-=40%", markers: window.isDebug, once: !0, invalidateOnRefresh: !0 } }).set(t.lines, { delay: 0, yPercent: 0, opacity: 1, stagger: .1 }) })); const s = e.querySelector(".js-topBlog-hdg"), a = e.querySelector(".js-top-blog-section"); Ci.timeline({ scrollTrigger: { trigger: s, start: () => "center center", end: () => "+=" + (a.clientHeight - s.clientHeight), markers: window.LIG.isDebug, pin: !0, pinSpacing: !1, invalidateOnRefresh: !0, toggleClass: { targets: s, className: "js-scrollShow" } } }), e.querySelectorAll(".js-top-blog-image").forEach((e => { const t = e.querySelector(".top-blog-image"), n = e.querySelector(".top-blog-image-parent"); Ci.timeline({ scrollTrigger: { trigger: e, start: () => "center bottom", markers: window.isDebug, once: !0, toggleClass: { targets: [t, n], className: "js-scrollShow" }, invalidateOnRefresh: !0 } }) })); const o = dx([i.scrollTrigger]); return function () { o(), i.destroy() } }(e), iy(e), i.classList.remove("bgImageNone") } }) }, P = () => { n.style.paddingTop = "0"; const e = Ci.timeline(), t = n.querySelectorAll(".letter-fade-1"), r = n.querySelectorAll(".letter-fade-2"), s = n.querySelector(".lig-is"), a = n.querySelector(".lig-life"), o = n.querySelector(".lig-good"), l = n.querySelector(".logo-main"), c = l.clientHeight; if (window.LIG.mql.matches) { const u = 48 / c, h = window.LIG.isIOS ? 520 : 490; e.fromTo(l, { scale: 1 }, { duration: 1, scale: u, ease: "circ.inOut" }).to(n, { onStart: () => { n.style.setProperty("--tw-translate-y", "calc(" + (-c / 2 + 24 + 11) + "px)") } }, "-=1.0").to(n, { onStart: () => { Ci.set(i, { y: 0 }), i.classList.remove("opacity-0") } }, "-=0.6").fromTo(t, { opacity: 1 }, { duration: .7, opacity: 0, ease: "circ.inOut" }, "-=0.95").fromTo(r, { opacity: 1 }, { duration: .7, opacity: 0, ease: "circ.inOut" }, "-=0.95").fromTo(s, { x: 0 }, { duration: .8, x: h - 362, ease: "circ.inOut" }, "-=0.95").fromTo(a, { x: 0 }, { duration: .8, x: h, ease: "circ.inOut" }, "-=0.95").fromTo(o, { x: 0 }, { duration: .8, x: h - 560, ease: "circ.inOut" }, "-=0.95").call(A, { delay: 0 }) } else { const u = 31 / c, h = (window.LIG.isIOS, -20); e.fromTo(l, { scale: 1 }, { duration: 1, scale: u, transformOrigin: "left center", ease: "circ.inOut" }).to(n, { onStart: () => { let e = window.outerWidth; e /= 400; let t = 15; t > 1 && (t += Math.ceil(e)), n.style.setProperty("left", "calc(1rem + " + t + "px - " + 30 * u + "px)"), n.style.setProperty("--tw-translate-y", "calc(" + (-c / 2 + 24 + 2) + "px)") } }, "-=1.0").to(n, { onStart: () => { Ci.set(i, { y: 0 }), i.classList.remove("opacity-0") } }, "-=0.6").fromTo(t, { opacity: 1 }, { duration: .6, opacity: 0, ease: "circ.inOut" }, "-=0.85").fromTo(r, { opacity: 1 }, { duration: .6, opacity: 0, ease: "circ.inOut" }, "-=0.85").call((() => { n.querySelector("#lig-inital-l").style.setProperty("transform", "translateX(10px)") }), {}, "-=0.84").fromTo(s, { x: 0 }, { duration: .8, x: h - 350, ease: "circ.inOut" }, "-=0.85").fromTo(a, { x: 0 }, { duration: .8, x: h, ease: "circ.inOut" }, "-=0.85").fromTo(o, { x: 0 }, { duration: .8, x: h - 550, ease: "circ.inOut" }, "-=0.85").call(A, { delay: 0 }) } }; let R = n.dataset.video; if ((window.LIG.mqlTab.matches || !window.LIG.mql.matches && n.hasAttribute("data-video-sp")) && (R = n.dataset.videoSp), !R) return; const O = document.createElement("video"); return O.crossOrigin = "anonymous", O.src = R, O.setAttribute("playsinline", ""), window.LIG.isIOS && (O.autoplay = !0), O.style.display = "none", O.muted = "true", O.loop = "true", p.addEventListener(O, "loadedmetadata", (e => { window.ThreeHandler.addTopMovie(O), f ? window.ThreeHandler.introLowerMovie(.4, "circ.out", (() => { A() })) : (() => { s.classList.add("opacity-0"), a.classList.remove("opacity-0"); for (let e = 0; e < 9; e++) { let t = L / 450; 6 == e && (t = window.LIG.mql.matches ? (L + window.outerWidth / 3) / 450 : (L + 100) / 450); let i = -1 * Math.abs(L * e) - t * e; setTimeout((() => { Ci.set(o, { backgroundPositionY: i, backgroundPositionX: 0 }), ThreeHandler.introTopMovie(1.2, "expo.out", 1, "expo.inOut", .6, (() => { })) }), y), y += 100, 8 === e && (setTimeout((() => { a.classList.add("opacity-0"), s.classList.remove("opacity-0"), Ci.set(".lig-svg", { autoAlpha: 1 }) }), y), setTimeout((() => { if (window.LIG.mql.matches) { let e = window.navigator.userAgent.toLowerCase(); 0 == v ? -1 != e.indexOf("chrome") ? (n.style.top = "-1px", n.classList.remove("md:left-[9px]"), n.classList.add("md:left-[10px]")) : n.style.top = "-1px" : (n.classList.remove("md:left-[9px]"), n.style.top = "0%") } else n.style.top = "0%"; n.style.paddingTop = window.LIG.mql.matches ? "100px" : "0px", n.style.setProperty("--tw-translate-y", 0), P() }), y + 400)) } })() })), p.addEventListener(window, "scroll", (() => { window.ThreeHandler.scrollTopMovie(window.pageYOffset) })), n && (f || Ci.set(r, { autoAlpha: 0 }), Ci.set(".lig-svg", { autoAlpha: 0 }), h = new ho(".js-preload-animated-text-mask", { type: "lines" }), Ci.set(h.lines, { yPercent: 110, opacity: 0 }), Ci.set(c, { opacity: 0, y: 10 })), function () { p.destroy(), d() } }(t)), removeEventFunctions.push(function (e) { const t = new Ky(e.querySelector(".js_sliderTop"), { slidesPerView: "auto", grabCursor: !0, freeMode: { enabled: !0, momentumRatio: .8, momentumVelocityRatio: .8 }, keyboard: { enabled: !0, onlyInViewport: !0 }, mousewheel: { forceToAxis: !0 }, scrollbar: { el: e.querySelector("#js-progress") } }); return function () { t.destroy(!0, !1) } }(t)) }, afterEnter() { }, beforeLeave() { }, afterLeave() { } }; Ci.registerPlugin(fa); let fx = null; const mx = { namespace: "solutions_page", beforeEnter(e) { const t = e.next.container; fx = function (e, t) { const n = window.ThreeHandler; let i, r, s, a, o, l, c, u, h, d, p = { progress: 0 }, f = { progress: .25 }, m = { progress: .5 }, g = { progress: .9 }; return n.addLiquidSolution(), n.solutionTransitionIn(.8, .6, (function () { })), function () { const t = window.LIG.mql.matche ? 1e3 : 800; i = Ci.timeline({ scrollTrigger: { trigger: "#dxglobal", start: () => "center center", end: () => `+=${t}`, pin: !0, scrub: 1, invalidateOnRefresh: !0 } }), i.set(".js_scrollText_01", { y: () => "" + .05 * t, opacity: 0 }).addLabel("start").to(".js_scrollText_01", { opacity: 1, duration: .1, ease: "circ.out" }, "start").to(".js_scrollText_01", { y: () => 0, duration: 1, ease: "linear" }, "start").to(".js_scrollText_01", { opacity: 0, duration: .2, ease: "circ.out" }, "start+=0.8"), r = Ci.timeline({ scrollTrigger: { trigger: "#buildteam", start: () => "center center", end: () => `+=${t}`, pin: !0, scrub: 1, invalidateOnRefresh: !0 } }), r.set(".js_scrollText_02", { y: () => "" + .05 * t, opacity: 0 }).addLabel("start").to(".js_scrollText_02", { opacity: 1, duration: .1, ease: "circ.out" }, "start").to(".js_scrollText_02", { y: () => 0, duration: 1, ease: "linear" }, "start").to(".js_scrollText_02", { opacity: 0, duration: .2, ease: "circ.out" }, "start+=0.8"), s = Ci.timeline({ scrollTrigger: { trigger: "#message", start: () => "center center", end: () => `+=${t}`, pin: !0, scrub: 1, invalidateOnRefresh: !0 } }), s.set(".js_scrollText_03", { y: () => "" + .05 * t, opacity: 0 }).addLabel("start").to(".js_scrollText_03", { opacity: 1, duration: .2, ease: "circ.out" }, "start").to(".js_scrollText_03", { y: () => "-" + .05 * t, duration: 1, ease: "linear" }, "start").to(".js_scrollText_03", { opacity: 0, duration: .2, ease: "circ.out" }, "start+=0.8"); const v = e.querySelector(".js_graphCircle_01"); Ci.set(v, { opacity: 0, scale: .6 }); const y = e.querySelector(".js_graphWord_01"); Ci.set(y, { opacity: 0, y: -20 }); const x = e.querySelector(".js_graphLine_01"); Ci.set(x, { scaleY: 0 }); const _ = e.querySelector(".js_graphWord_02"); Ci.set(_, { opacity: 0, y: -20 }); const w = e.querySelector(".js_graphCircle_02"); Ci.set(w, { opacity: 0, scale: .6 }); const b = e.querySelector(".js_graphWord_03"); Ci.set(b, { opacity: 0, y: -20 }); const S = e.querySelectorAll(".js_graphCircle_03"); Ci.set(S, { opacity: 0, scale: .6 }); const E = e.querySelectorAll(".js_graphWord_04"); Ci.set(E, { opacity: 0, y: -20 }), a = Ci.timeline({ scrollTrigger: { trigger: "#graph", start: () => "center center", end: () => "+=" + 2 * t, pin: !0, scrub: 1, invalidateOnRefresh: !0 }, ease: "circ.out" }), a.addLabel("graphStart").to(v, { scale: 1, opacity: 1, duration: .2, ease: "circ.out" }, "graphStart").to(y, { y: 0, opacity: 1, duration: .2, ease: "circ.out" }, "graphStart+=0.1").addLabel("firstCircle").to(x, { scaleY: 1, duration: .15, ease: "circ.easeIn" }, "firstCircle").to(_, { y: 0, opacity: 1, duration: .3, ease: "circ.out" }, "firstCircle+=0.1").to(w, { scale: 1, opacity: 1, duration: .15, ease: "circ.out" }, "firstCircle+=0.15").addLabel("secondCircle").to(b, { y: 0, opacity: 1, duration: .2, ease: "circ.out" }, "secondCircle").to(S, { opacity: 1, scale: 1, duration: .2, ease: "circ.out" }, "secondCircle+=0.1").to(E, { y: 0, opacity: 1, duration: .15, ease: "circ.out" }, "secondCircle+=0.15").addLabel("wait").to({ wait: 0 }, { wait: 1, duration: .2, ease: "circ.out" }, "wait").addLabel("finish"), o = hx(e, t), l = Ci.to(p, { progress: .25, scrollTrigger: { trigger: "#title", start: () => 0, end: () => `+=${t}`, scrub: 2, invalidateOnRefresh: !0, onEnter: () => { p.progress = 0, n.solutionScroll(p.progress) }, onLeaveBack: () => { p.progress = 0, n.solutionScroll(p.progress) }, onLeave: () => { p.progress = .25, n.solutionScroll(p.progress) }, onEnterBack: () => { p.progress = .25, n.solutionScroll(p.progress) }, onUpdate: e => { e.isActive && n.solutionScroll(p.progress) } }, ease: "circ.out" }), c = Ci.to(f, { progress: .5, scrollTrigger: { trigger: "#dxglobal", start: () => "center center", end: () => `+=${t}`, scrub: 2, invalidateOnRefresh: !0, onEnter: () => { f.progress = .25, n.solutionScroll(f.progress) }, onLeaveBack: () => { f.progress = .25, n.solutionScroll(f.progress) }, onLeave: () => { f.progress = .5, n.solutionScroll(f.progress) }, onEnterBack: () => { f.progress = .5, n.solutionScroll(f.progress) }, onUpdate: e => { e.isActive && n.solutionScroll(f.progress) } }, ease: "circ.out" }), u = Ci.to(m, { progress: .9, scrollTrigger: { trigger: "#buildteam", start: () => "top bottom", end: () => "+=" + 2 * t, scrub: 2, invalidateOnRefresh: !0, onEnter: () => { m.progress = .5, n.solutionScroll(m.progress) }, onLeaveBack: () => { m.progress = .5, n.solutionScroll(m.progress) }, onLeave: () => { m.progress = .9, n.solutionScroll(m.progress) }, onEnterBack: () => { m.progress = .9, n.solutionScroll(m.progress) }, onUpdate: e => { e.isActive && n.solutionScroll(m.progress) } }, ease: "circ.out" }), h = Ci.to(g, { progress: 1, scrollTrigger: { trigger: "#graph", start: () => "top bottom", end: () => "+=" + .5 * t, scrub: 2, invalidateOnRefresh: !0, onEnter: () => { g.progress = .9, n.solutionScroll(g.progress) }, onLeaveBack: () => { g.progress = .9, n.solutionScroll(g.progress) }, onLeave: () => { g.progress = 1, n.solutionScroll(g.progress) }, onEnterBack: () => { g.progress = 1, n.solutionScroll(g.progress) }, onUpdate: e => { e.isActive && n.solutionScroll(g.progress) } }, ease: "circ.out" }), d = dx([l.scrollTrigger, i.scrollTrigger, r.scrollTrigger, s.scrollTrigger, a.scrollTrigger, o.scrollTrigger]) }(), function () { d(), o.destroy() } }(t) }, afterEnter() { }, beforeLeave() { fx && fx() }, afterLeave() { } }; function gx(e) { Ci.registerPlugin(fa); const t = e.querySelector("#js-video-load"); let n = ty(); if (!t) return; let i = t.hasAttribute("data-video") ? t.dataset.video : 0; if (t.style.webkitMaskImage = "-webkit-gradient(linear, 0% 0%, 0% 100%, from(rgb(0, 0, 0)), to(rgba(0, 0, 0, 0)));", (window.LIG.mqlTab.matches || !window.LIG.mql.matches && t.dataset.videoSp) && (i = t.dataset.videoSp), !i) return; const r = document.createElement("video"); function s() { window.ThreeHandler.scrollTopMovie(window.pageYOffset) } r.offsetTop !== window.scrollY || (window.innerHeight, window.scrollY), r.crossOrigin = "anonymous", r.src = i, r.setAttribute("playsinline", ""), r.style.display = "none", r.muted = "true", r.loop = "true", r.autoplay = "true", window.addEventListener("scroll", s); const a = new Promise((function (e, t) { n.addEventListener(r, "loadeddata", (t => { e(), window.ThreeHandler.addTopMovie(r), window.ThreeHandler.introLowerMovie(.8, "circ.out") })) })); return pageLoadObjects.push(a), function () { n.destroy(), window.removeEventListener("scroll", s), r.remove() } } const vx = n(306); class yx { constructor() { this.ANIMATION_CLASS = "is-fade"; let e = document.querySelectorAll(".js-scroll-fade:not(.is-fade)"); if (null === e.length) return; let t = new vx.Controller; for (let n = 0; n < e.length; n++) { let i = new vx.Scene({ triggerElement: e[n], triggerHook: "onEnter", reverse: !1, offset: 100 }).addTo(t); i.on("enter", (() => { e[n].classList.add(this.ANIMATION_CLASS) })), i.on("end", (() => { i.destroy(!0) })) } } } const xx = { namespace: "solutions_child_page", beforeEnter(e) { const t = e.next.container; !function (e) { new Ky(e.querySelector(".js-swiper-technology"), { loop: !0, slidesPerView: 7, speed: 4e3, allowTouchMove: !1, spaceBetween: 14, autoplay: { delay: 0 } }), new Ky(e.querySelector(".js-swiper-technology-sp2"), { loop: !0, slidesPerView: 4, speed: 4500, allowTouchMove: !1, spaceBetween: 14, autoplay: { delay: 0 }, breakpoints: { 320: { slidesPerView: 3 }, 375: { slidesPerView: 3 } } }), new Ky(e.querySelector(".js-swiper-technology-sp3"), { loop: !0, slidesPerView: 3, speed: 6e3, allowTouchMove: !1, spaceBetween: 14, autoplay: { delay: 0 }, breakpoints: { 320: { slidesPerView: 2 }, 375: { slidesPerView: 2 } } }) }(t), null === removeEventFunctions && (removeEventFunctions = []), removeEventFunctions.push(gx(t)), removeEventFunctions.push(function (e) { Ci.registerPlugin(fa); const t = !1, n = e.querySelector(".js-solutions-strength"); if (!n) return; let i; if (window.LIG.mql.matches) { const r = n.querySelector("#js-video-mask"), s = e.querySelector("#js-outer-gray-circle"), a = e.querySelector("#js-line-circle"), o = e.querySelector(".js-pager"), l = e.querySelector(".full-bg-video"); let c = e.querySelector("#js-pink-line"), u = c.getTotalLength(); Ci.set(c, { strokeDasharray: u + " " + u, strokeDashoffset: u }); let h = e.querySelectorAll(".js-solution-content"); const d = 900, p = 1; let f, m = Ci.timeline({ scrollTrigger: { trigger: n, start: () => "center center", end: () => `+=${d + h.length * (2 * d)}`, pin: !0, markers: t } }), g = Ci.timeline({ scrollTrigger: { trigger: n, start: () => "top bottom", end: () => "+=" + (2 * d + h.length * (2 * d)), scrub: 1.5, markers: t, invalidateOnRefresh: !0, onEnter: () => { f = l.play() }, onLeaveBack: () => { void 0 !== f && f.then((() => { l.pause() })) }, onLeave: () => { void 0 !== f && f.then((() => { l.pause() })) }, onEnterBack: () => { f = l.play() }, onRefresh: e => { e.progress > 0 && e.progress < 1 ? f = l.play() : void 0 !== f && f.then((() => { l.pause() })) } }, ease: "circ.inOut" }); Ci.set([s, a], { transformOrigin: "50% 50%" }), Ci.set(".js-solution-title", { xPercent: -110, opacity: 1 }), new ho(e.querySelector(".js-solution-sub-title"), { type: "lines" }); let v = new ho(e.querySelector(".js-solution-title"), { type: "lines" }), y = []; Ci.set(v.lines, { overflow: "hidden" }), v.lines.forEach((e => { let t = new ho(e, { type: "lines" }); y.push(t.lines) })); const x = .2 * p; g.set(y, { y: 180, duration: x }).addLabel("openingStart").to(n, { opacity: 1, duration: .5 * x, ease: "circ.inOut" }).to(r, { opacity: .7, duration: .8 * x, ease: "circ.inOut" }, "openingStart").to(s, { scale: 1, duration: .6 * x, ease: "circ.inOut" }, "openingStart+=" + .2 * x).to(a, { scale: 1, duration: .6 * x, ease: "circ.inOut" }, "openingStart+=" + .4 * x), y.forEach(((e, t) => { g.to(e, { y: 0, duration: .2 * p, ease: "circ.inOut" }, "openingStart+='" + .1 * x * t) })), g.addLabel("contentsStart"); let _ = "contentsStart"; const w = .8 * p / h.length; h.forEach(((e, t) => { const n = "Content" + t + "End"; let i = new ho(e.querySelector(".js-solution-content-title"), { type: "lines" }), r = new ho(e.querySelector(".js-solution-content-desc"), { type: "lines" }); Ci.set(i.lines, { y: "100%", opacity: 0 }), Ci.set(r.lines, { y: "100%", opacity: 0 }), g.call((() => { o.innerHTML = "0" + (t + 1) }), {}, _).set(c, { strokeDashoffset: u, opacity: 1 }, _).to(o, { opacity: 1, duration: .2 * w }, _).to(c, { strokeDashoffset: 0, duration: w }, _), t !== h.length - 1 ? g.to(e, { y: -1 * (.5 * window.innerHeight + e.clientHeight), duration: w }, _) : g.to(e, { y: -1 * (.25 * window.innerHeight + .5 * e.clientHeight), duration: w }, _), i.lines.forEach((e => { g.to(e, { y: 0, duration: .2 * w, opacity: 1, ease: "circ.out" }, _) })), r.lines.forEach((e => { g.to(e, { y: 0, duration: .2 * w, opacity: 1, ease: "circ.out" }, _) })), t !== h.length - 1 ? (i.lines.forEach((e => { g.to(e, { duration: .3 * w, opacity: 0, ease: "circ.in" }, _ + "+=" + .7 * w) })), r.lines.forEach((e => { g.to(e, { duration: .3 * w, opacity: 0, ease: "circ.in" }, _ + "+=" + .7 * w) })), g.to([o, c], { opacity: 0, duration: .2 * w }, _ + "+=" + w).call((() => { o.innerHTML = "0" + (t + 1) }), {}, _ + "+=" + 1.2 * w).addLabel(n)) : g.addLabel(n), _ = n })), i = dx([m.scrollTrigger]) } else { const n = e.querySelector("#js-solutions-strength-sp"), i = e.querySelector("#js-outer-gray-circle-sp"), r = e.querySelector("#js-line-circle-sp"), s = e.querySelector("#js-solution-title-sp"); let a = e.querySelector("#js-solution-pager-sp"), o = e.querySelectorAll(".js-solution-content-sp"); const l = e.querySelector(".solution-video"), c = 800, u = 1; let h, d = e.querySelector("#js-pink-line-sp"), p = d.getTotalLength(); Ci.set(d, { strokeDasharray: p + " " + p, strokeDashoffset: p }), Ci.set([i, r], { transformOrigin: "50% 50%" }); let f = new ho(s, { type: "lines" }), m = Ci.timeline({ scrollTrigger: { trigger: n, start: () => "center center", end: () => `+=${c + o.length * (2 * c)}`, pin: !0, markers: t, invalidateOnRefresh: !0 } }), g = Ci.timeline({ scrollTrigger: { trigger: n, start: () => "top bottom", end: () => "+=" + (2 * c + o.length * (2 * c)), scrub: 1.5, invalidateOnRefresh: !0, onEnter: () => { h = l.play() }, onLeaveBack: () => { void 0 !== h && h.then((() => { l.pause() })) }, onLeave: () => { void 0 !== h && h.then((() => { l.pause() })) }, onEnterBack: () => { h = l.play() } }, ease: "circ.inOut" }); const v = .2 * u; g.set([f.lines], { y: 120, minHeight: 50 }).addLabel("openingStart").to(n, { opacity: 1, duration: .5 * v, ease: "circ.inOut" }).to(i, { scale: 1, opacity: 0, duration: .6 * v, ease: "circ.inOut" }, "openingStart+=" + .2 * v).to(r, { scale: 1, duration: .6 * v, ease: "circ.inOut" }, "openingStart+=" + .4 * v).to(f.lines, { y: 0, duration: .2 * u, ease: "circ.inOut" }, "openingStart+=" + .1 * v).addLabel("contentsStart"); let y = "contentsStart"; const x = .8 * u / o.length; o.forEach(((e, t) => { const n = "Content" + t + "End"; let i = new ho(e.querySelector(".js-solution-content-title"), { linesClass: "lineChild" }), r = new ho(e.querySelector(".js-solution-content-desc"), { type: "lines" }); Ci.set(i.lines, { y: 20, opacity: 0 }), Ci.set(r.lines, { y: 20, opacity: 0 }), g.call((() => { a.innerHTML = "0" + (t + 1) }), {}, y).set(d, { strokeDashoffset: p, opacity: 1 }, y).set(e, { opacity: 1 }, y).to(a, { opacity: 1, duration: .2 * x }, y).to(d, { strokeDashoffset: 0, duration: x }, y), g.to(i.lines, { y: 0, duration: .2 * x, opacity: 1, ease: "circ.out" }, y), g.to(r.lines, { y: 0, duration: .2 * x, opacity: 1, ease: "circ.out" }, y), t !== o.length - 1 ? g.to(r.lines, { y: 20, opacity: 0, duration: .2 * x, ease: "circ.out" }, y + "+=" + .8 * x).to(i.lines, { y: 20, opacity: 0, duration: .2 * x, ease: "circ.out" }, y + "+=" + .8 * x).to([a, d], { opacity: 0, duration: .2 * x, ease: "circ.out" }, y + "+=" + .8 * x).call((() => { a.innerHTML = "0" + (t + 1) }), {}, y + "+=" + 1.2 * x).addLabel(n) : g.addLabel(n), y = n })), dx([m.scrollTrigger]) } return function () { i() } }(t)) }, afterEnter() { new yx }, beforeLeave() { }, afterLeave() { } }, _x = { namespace: "solutions_grand_child_page", beforeEnter(e) { const t = e.next.container, n = document.querySelector(".js-header-solution-child-box"), i = document.querySelector(".js-header-solution-child-box-text"), r = document.querySelector(".js-header-solution-child-box-color"), s = t.querySelector(".js-solution-child-content"); i.innerText = s.dataset.solutionTitle, r.classList.add("bg-solution-" + s.dataset.solutionColor), n.classList.add("active") }, afterEnter() { new yx }, beforeLeave(e) { }, afterLeave(e) { const t = e.current.container, n = document.querySelector(".js-header-solution-child-box"), i = document.querySelector(".js-header-solution-child-box-color"), r = t.querySelector(".js-solution-child-content"); i.classList.remove("bg-solution-" + r.dataset.solutionColor), n.classList.remove("active") } }, wx = { namespace: "normal_page", beforeEnter(e) { }, afterEnter() { }, beforeLeave() { }, afterLeave() { } }; function bx(e) { const t = e.querySelector("#js-list-banner-pc"), n = e.querySelector("#js-list-banner-sp"), i = e.querySelector("#js-detail-banner-bottom"), r = e.querySelector("#js-blog-content"); let s = new ty; const a = "banner-event"; function o(e) { for (var t = e.length - 1; t > 0; t--) { var n = Math.floor(Math.random() * (t + 1));[e[t], e[n]] = [e[n], e[t]] } } return (t && n || r) && fetch(document.body.dataset.bannerApi).then((e => e.json())).then((l => { if (t && n) { let e = l.list, i = [], r = 0; Object.keys(e).forEach((t => { e[t].length > 1 && o(e[t]), i.push(e[t][0]) })), o(i); let s = ""; i.forEach((e => { r >= 2 || (s += '<div class="rounded-[5px] md:rounded-[8px] overflow-hidden mb-[15px]"><a href="' + e.url + '" class="js-banner-click banner-image-parent" target="_blank" data-client="' + e.client + '" data-banner-name="' + e["banner-name"] + '" rel="noopener noreferrer"><picture><img src="' + e.pc_image + '" class="w-full blog-image"></picture></a></div>', dataLayer.push({ event: a, eventCategory: "バナー表示", eventAction: e.client, eventLabel: e["banner-name"], eventValue: 1 }), r++) })), t.innerHTML = s, s = "", r = 0, i.forEach((e => { r >= 2 || (s += '<div class=" rounded-[5px] md:rounded-[4px] overflow-hidden mb-[15px] last:mb-0"><a href="' + e.url + '" data-banner-name="' + e["banner-name"] + '" class="js-banner-click" target="_blank" data-client="' + e.client + '" rel="noopener noreferrer"><picture><img src="' + e.pc_image + '" class="w-full blog-image"></picture></a></div>', r++) })), n.innerHTML = s } else { let t = l.detail; o(t); let n = [], s = "", c = 0; const u = e.querySelector(".js-blog-content"), h = u.dataset.adBottomBlock, d = u.dataset.adDetailBlock; if ("1" != h ? (c = 0, Object.keys(t).forEach((e => { t[e].length > 1 && o(t[e]), n.push(t[e][0]) })), o(n), n.forEach((e => { if (c >= 2) return; let t = "mb-[0]"; 0 === c && (t = "mb-[15px]"), s += '<div class="w-full mb-[15px] md:' + t + ' overflow-hidden md:min-h-[204px] rounded-[5px] md:rounded-[4px]"><a href="' + e.url + '" class="js-banner-click banner-image-parent" target="_blank" data-client="' + e.client + '" data-banner-name="' + e["banner-name"] + '" rel="noopener noreferrer"><picture><source media="(max-width: 750px)" srcset="' + e.sp_image + ' "><img src="' + e.pc_image + '" class="w-full blog-image"></picture></a></div>', c++, dataLayer.push({ event: a, eventCategory: "バナー表示", eventAction: e.client, eventLabel: e["banner-name"], eventValue: 1 }) })), i.innerHTML = s) : i.classList.add("hidden"), "1" != d) { const e = r.querySelectorAll("h2"); if (e.length >= 3) { const i = e[2]; c = 0, n = [], Object.keys(t).forEach((e => { t[e].length > 1 && o(t[e]), n.push(t[e][0]) })), o(n), s = "", c = 0, n.forEach((e => { if (c >= 1) return; let t = "mb-[0] md:mb-[15px]"; 0 === c && (t = "mb-[15px] md:mb-[0px]"); let n = ""; 1 === c && (n = " md:hidden"), s += '<div class="w-full ' + t + n + ' overflow-hidden md:min-h-[204px] rounded-[5px] md:rounded-[4px]"><a href="' + e.url + '" class="js-banner-click ad banner-image-parent" target="_blank" data-client="' + e.client + '" data-banner-name="' + e["banner-name"] + '" rel="noopener noreferrer"><picture><source media="(max-width: 750px)" srcset="' + e.sp_image + ' "><img src="' + e.pc_image + '" class="w-full md:mt-[0]"></picture></a></div>', dataLayer.push({ event: a, eventCategory: "バナー表示", eventAction: e.client, eventLabel: e["banner-name"], eventValue: 1 }), c++ })), s = '<h4 class="ad-title">AD</h4><div class="md:flex md:flex-wrap md:mt-[0px] border-gray-100/10 border p-[25px] rounded-[5px] md:rounded-[4px]">' + s + "</div>", i.insertAdjacentHTML("beforebegin", s) } } iy(document) } e.querySelectorAll(".js-banner-click").forEach((e => { s.addEventListener(e, "click", (t => { dataLayer.push({ event: a, eventCategory: "バナークリック", eventAction: e.dataset.client, eventLabel: e.dataset.bannerName, eventValue: 1 }) })) })) })), function () { s.destroy() } } const Sx = { namespace: "blog_archive_page", beforeEnter(e) { const t = e.next.container; null === removeEventFunctions && (removeEventFunctions = []), removeEventFunctions.push(bx(t)), removeEventFunctions.push(function (e) { let t = ty(), n = ty(); const i = "s_history", r = (e.querySelector(".js-pc-search-box"), e.querySelector(".js-validation-form")), s = e.querySelector(".js-search-input"), a = e.querySelector(".js-search-recommend-box"), o = e.querySelector(".js-search-recommend"), l = e.querySelector(".js-search-history"), c = e.querySelector(".js-search-icon-wrap"), u = e.querySelector(".js-search-input-sp-wrap"), h = u.querySelector(".js-search-input-sp"), d = document.querySelector(".js-search-blog-menu"), p = d.querySelector(".js-search-input-sp-main"), f = d.querySelector(".js-search-blog-menu-inner"), m = d.querySelector(".js-search-recommend-sp-wrap"), g = d.querySelector(".js-search-recommend-sp"), v = d.querySelector(".js-search-history-sp"), y = d.querySelector(".js-hide-blog-menu"), x = document.querySelector(".js-search-form-sp"), _ = d.querySelector(".js-search-icon-sp"), w = d.querySelector(".js-cancel-search-icon-sp"), b = d.querySelector(".js-search-tag-sp"); let S = []; fetch(s.getAttribute("data-search-api")).then((e => e.json())).then((e => { S = e })); let E = localStorage.getItem(i); if (E) { E = JSON.parse(E); let e = "", n = ""; for (let t in E) e += '<li class="mt-[8px] md:mt-[0] font-bold cursor-pointer text-gray-100 js-keyword-set md:text-[20px]"><a href="/?s=' + encodeURI(E[t]) + '">' + E[t] + "</a></li>", n += '<li><a href="/?s=' + encodeURI(E[t]) + '">' + E[t] + "</a></li>"; l.querySelector("ul").innerHTML = e, v.querySelector("ul").innerHTML = n, v.querySelectorAll("li a").forEach((e => { t.addEventListener(e, "click", (t => { h.value = e.innerText, p.value = e.innerText, window.LIG.barba.force(t.target.getAttribute("href")) })) })), l.classList.remove("hidden"), v.classList.remove("hidden"), m.classList.remove("hidden") } function M() { null == E && (E = []), E.includes(s.value) || E.unshift(s.value), E.length >= 5 && E.splice(4), localStorage.setItem(i, JSON.stringify(E)) } function T() { null == E && (E = []), E.includes(p.value) || E.unshift(p.value), E.length >= 5 && E.splice(5), localStorage.setItem(i, JSON.stringify(E)) } return t.addEventListener(s, "input", (e => { if ("" == s.value) o.classList.add("hidden"), a.classList.add("hidden"); else if (S.length) { let e = []; n.destroy(); for (let t in S) if (S[t].toLowerCase().startsWith(s.value.toLowerCase()) && e.push(S[t]), 5 == e.length) break; if (e.length > 0) { let t = ""; for (let n in e) t += '<li class="mt-[8px] md:mt-[0] font-bold text-gray-100 cursor-pointer js-keyword-set md:text-[20px]"><a href="/?s=' + encodeURI(e[n]) + '">' + e[n] + "<a></a></li>"; o.querySelector("ul").innerHTML = t, o.querySelectorAll("li").forEach((e => { n.addEventListener(e, "click", (() => { s.value = e.innerText })) })), o.classList.remove("hidden") } else o.querySelector("ul").innerHTML = ""; a.classList.remove("hidden") } })), t.addEventListener(s, "focus", (() => { "" != s.value && a.classList.remove("hidden") })), t.addEventListener(r, "submit", (e => { M() })), t.addEventListener(c, "click", (() => { M(), r.submit() })), t.addEventListener(p, "input", (e => { if (h.value = p.value, "" == p.value) w.classList.add("hidden"), g.classList.add("hidden"), E || m.classList.add("hidden"); else if (w.classList.remove("hidden"), S.length) { let e = []; n.destroy(); for (let t in S) if (S[t].toLowerCase().startsWith(h.value.toLowerCase()) && e.push(S[t]), 5 == e.length) break; if (e.length > 0) { let t = ""; for (let n in e) t += '<li><a href="/?s=' + encodeURI(e[n]) + '">' + e[n] + "</li>"; g.querySelector("ul").innerHTML = t, g.querySelectorAll("li a").forEach((e => { n.addEventListener(e, "click", (t => { h.value = e.innerText, p.value = e.innerText, window.LIG.barba.force(t.target.getAttribute("href")) })) })), g.classList.remove("hidden"), m.classList.remove("hidden") } else g.querySelector("ul").innerHTML = "", E || m.classList.add("hidden") } })), t.addEventListener(x, "submit", (e => { T() })), t.addEventListener(_, "click", (e => { e.preventDefault(), T(), x.submit() })), t.addEventListener(w, "click", (e => { h.value = "", p.value = "", g.querySelector("ul").innerHTML = "", n.destroy(), g.classList.add("hidden"), w.classList.add("hidden") })), t.addEventListener(u, "click", (e => { e.preventDefault(), d.classList.remove("hidden"), p.focus(), Ci.set(document.body, { overflow: "hidden", height: "100%", width: "100%", position: "fixed" }), window.LIG.isIOS && Ci.set(b, { paddingBottom: "60px" }), Ci.set(d, { opacity: 1 }), Ci.set(f, { y: 0 }) })), t.addEventListener(y, "click", (() => { f.addEventListener("transitionend", (() => { Ci.set(d, { opacity: 0 }) }), { once: !0 }), d.addEventListener("transitionend", (() => { d.classList.add("hidden"), Ci.set(b, { clearProps: "all" }), Ci.set(document.body, { clearProps: "all" }) }), { once: !0 }), Ci.set(f, { y: "100%" }) })), function () { t.destroy() } }(t)) }, afterEnter() { }, beforeLeave() { }, afterLeave() { } }, Ex = { namespace: "blog_single_page", beforeEnter(e) { const t = e.next.container; null === removeEventFunctions && (removeEventFunctions = []), t.querySelectorAll(".single-page-content a[target='_blank']").forEach((e => { e.querySelectorAll("img").length > 0 && e.classList.add("no-icon") })); const n = t.querySelectorAll(".box_tweet"); n && n.forEach((e => { e.innerHTML = e.innerHTML.replace("<br>", ""), e.innerHTML = e.innerHTML.replace("<br/>", ""), e.innerHTML = e.innerHTML.replace("<p>", ""), e.innerHTML = e.innerHTML.replace("</p>", ""); let t = e.childNodes[1], n = 0; if ("STRONG" == e.childNodes[0].tagName && (e.childNodes[0].outerHTML = e.childNodes[0].innerHTML), null == t.tagName || "STRONG" == t.tagName) { let i = t.outerHTML; if (null != i && 2 == e.childNodes.length) t.outerHTML = '<span class="box_tweet-text">' + i + "</span>"; else if (e.childNodes.length > 2) { let t = ""; for (n = 1; n < e.childNodes.length; n++)null == e.childNodes[n].outerHTML ? t += e.childNodes[n].textContent : t += e.childNodes[n].outerHTML; e.innerHTML = e.childNodes[0].outerHTML + '<span class="box_tweet-text">' + t + "</span>" } else e.innerHTML = e.childNodes[0].outerHTML + '<span class="box_tweet-text">' + t.textContent + "</span>" } })), removeEventFunctions.push(bx(t)); const i = t.querySelectorAll(".toc_list li a"), r = document.querySelector(".js-header").offsetHeight; function s(e) { e.preventDefault(); const t = document.getElementById(e.target.closest("a").getAttribute("href").substring(1)), n = "H2" === t.parentNode.nodeName ? -40 : -35, i = window.LIG.mql.matches ? n : -28, s = t.offsetTop - r + i; window.scrollTo({ top: s, left: 0, behavior: "smooth" }) } i.forEach((e => { e.addEventListener("click", s) })), document.querySelectorAll(".single-page-content table.fix").forEach((function (e) { let t = document.createElement("div"); t.classList.add("scroll-auto"), t.appendChild(e.cloneNode(!0)), e.parentNode.replaceChild(t, e) })), document.querySelectorAll(".single-page-content #toc_container p.toc_title").forEach((e => { let t = document.createElement("span"); t.innerHTML = "閉じる", e.classList.add("cursor-pointer"), e.innerHTML += "&nbsp;[", e.appendChild(t), e.insertAdjacentText("beforeend", "]"), e.addEventListener("click", (function () { let n = this.nextElementSibling; n.classList.contains("hidden") ? (n.classList.remove("hidden"), t.innerHTML = "閉じる", e.insertBefore(t, e.lastChild)) : (n.classList.add("hidden"), t.innerHTML = "開く", e.insertBefore(t, e.lastChild)) })) })), document.querySelectorAll("a[rel='noopener'][target='_blank']").forEach((e => { let t = e.getAttribute("href"), n = e.getAttribute("class"); if (!t || !t.includes("amazon.co.jp") || n) return; let i = e.parentNode, r = document.createElement("span"); r.classList.add("amazonjs_link-note"), r.innerHTML = "※こちらのリンクから商品を購入されると、一部の利益が弊社に還元されることがございます。", i.insertBefore(r, e.nextSibling), i.insertBefore(document.createElement("br"), e.nextSibling) })), document.querySelectorAll(".cta .contents").forEach((e => { const t = e.querySelectorAll("ul"), n = e.querySelectorAll("ol"); if (t.length > 0) { const n = t[t.length - 1], i = n.nextElementSibling, r = e.querySelectorAll("p")[0]; let s = r.previousSibling; i && "P" === i.tagName && "" === i.innerHTML.trim() && n.classList.add("last-of-type"), r && "P" === r.tagName && "" === r.innerHTML.trim() && !s && (r.style.marginBottom = "0") } if (n.length > 0) { const t = n[n.length - 1], i = t.nextElementSibling, r = e.querySelectorAll("p")[0]; let s = r.previousSibling; i && "P" === i.tagName && "" === i.innerHTML.trim() && t.classList.add("last-of-type"), r && "P" === r.tagName && "" === r.innerHTML.trim() && !s && (r.style.marginBottom = "0") } })), $(".codeBlock-snippet #codeBlock > code").each((function () { const e = window.matchMedia("(max-width: 768px)").matches, t = $(this), n = t.height(); e ? (n > 10.3984 && n < 60 && t.parent().addClass("sp-cut-off"), n > 60 && t.parent().addClass("sp-inherit")) : (n < 15 && n < 60 && t.parent().addClass("pc-cut-off minimum"), n > 11.9375 && n < 60 && t.parent().addClass("pc-cut-off"), n > 60 && t.parent().addClass("pc-inherit")) })), $(document).on("click", ".copy-btn", (function () { const e = $(this).closest(".codeBlock-snippet").find("section pre code").text(); console.log("codeText: ", e); const t = $("<textarea>"); $("body").append(t), t.val(e).select(), navigator.clipboard.writeText(e), t.remove(); const n = $(this); n.text("Copied!"), setTimeout((() => { n.text("Copy") }), 2e3) })), $("pre#codeBlock > code br:first-of-type, pre#codeBlock > code br:last-of-type").remove(), $("p > code").each((function () { const e = $(this), t = e.parent(); e.insertAfter(t), t.remove() })); const a = window.matchMedia("(max-width: 768px)").matches; $("table").each((function () { const e = $(this), t = e.find("tbody tr"); let n = !1; t.each((function () { const t = $(this).children().length; 2 === t && a && $(this).children().first().addClass("two-column"), 3 === t && a && $(this).children().addClass("three-column"), t > 3 && a && !n && (e.wrap('<div class="table-scroll"></div>'), n = !0, $(this).children().addClass("four-column"), e.parent(".table-scroll").on("touchstart", (function (e) { e.stopPropagation() }))) })) })), $(document).on("click", ".prompt-btn", (function () { const e = $(this).closest(".codeBlock-snippet.prompt").find("#promptBlock").text(); console.log("codeText: ", e); const t = $("<textarea>"); $("body").append(t), t.val(e).select(), navigator.clipboard.writeText(e), t.remove(); const n = $(this); n.text("Copied!"), setTimeout((() => { n.text("Copy") }), 2e3) })), $("#promptBlock p").each((function () { const e = $(this); e.is(":last-of-type") || e.after("<br>"), e.is(":empty") && (e.is(":last-of-type") || e.is(":first-of-type")) && e.remove() })), $("#promptBlock br:first-of-type, #promptBlock br:last-of-type").remove(); const o = $("#toc_container"), l = window.innerHeight, c = o.find(".toc_title"), u = o.find("ul"); if (a && o.outerHeight() > l) { o.addClass("collapse").css("height", `${l}px`); const e = $('<button class="toc-toggle"><span>もっと見る</span></button>'); o.append(e), c.on("click", (function () { const t = "開く" === $(this).find("span").text() && (o.hasClass("collapse") || o.hasClass("expanded")); o.hasClass("expanded") && o.removeClass("expanded"), o.toggleClass("collapse", !t).css("height", t ? "auto" : `${l}px`), e.toggle(!t) })), e.on("click", (function () { const e = $(this).find("span"), t = o.hasClass("collapse"), n = t ? u.outerHeight() + 2 * c.outerHeight() + 60 : l; o.toggleClass("collapse", !t).toggleClass("expanded", t).animate({ height: n }, 300, (function () { e.text(t ? "折りたたむ" : "もっと見る") })) })) } }, afterEnter() { }, beforeLeave() { }, afterLeave() { } }; function Mx(e) { let t = ty(); const n = e.querySelector("#jsMemberModalClose"), i = e.querySelector("#jsMemberModalContainer"), r = e.querySelector("#jsMemberModalOverlay"), s = e.querySelector("#jsMemberModalOpen"); return t.addEventListener(n, "click", (() => { null == i || i.classList.remove("translate-y-[0]"), null == i || i.classList.add("translate-y-full"), null == r || r.classList.add("z-[-1]"), null == r || r.classList.remove("z-10"), document.body.classList.remove("overflow-hidden") })), t.addEventListener(s, "click", (e => { e.preventDefault(), null == i || i.classList.remove("translate-y-full"), null == i || i.classList.add("translate-y-[0]"), null == r || r.classList.remove("z-[-1]"), null == r || r.classList.add("z-10"), document.body.classList.add("overflow-hidden") })), function () { t.destroy() } } Ci.registerPlugin(fa); const Tx = { namespace: "members_page", beforeEnter(e) { const t = e.next.container; null === removeEventFunctions && (removeEventFunctions = []), removeEventFunctions.push(function (e) { const t = e.querySelectorAll(".js-author-avatar"), n = e.querySelectorAll(".js-solution-author-selection"), i = document.querySelector(".js-header").offsetHeight, r = e.querySelector(".js-member-content"), s = e.querySelector(".jsMemberModalSelected"); function a(e) { e.preventDefault(), n.forEach((e => { e.classList.contains("text-white-30") || e.classList.add("text-white-30") })); let a = e.target, o = a; const l = o.innerHTML; s.innerHTML = l, "span" === a.tagName.toLowerCase() && (o = a.closest("a")); let c = o.getAttribute("href").substring(1); o.classList.remove("text-white-30"); const u = [], h = []; t.forEach((e => { "all" === c || e.getAttribute("data-" + c) ? u.push(e) : h.push(e) })); let d = 0; if (h.length > 0 && (d = .2, Ci.to(t, .2, { opacity: 0, onComplete: () => { h.forEach((e => { !function (e) { e.classList.add("hidden") }(e), e.removeAttribute("style") })) } })), u.length > 0) { Ci.fromTo(u, { opacity: 0, y: 40 }, { duration: .4, opacity: 1, delay: d, y: 0, stagger: .1, ease: "circ.out", onStart: () => { u.forEach((e => { !function (e) { e.classList.contains("hidden") && e.classList.remove("hidden") }(e) })), fa.getAll().forEach((e => { e.refresh() })) } }); let e = r.offsetTop - i; window.scrollTo({ top: e, left: 0, behavior: "smooth" }) } } return n.forEach((e => { e.addEventListener("click", a) })), function () { n.forEach((e => { e.removeEventListener("click", a) })) } }(t)), removeEventFunctions.push(Mx(t)) }, afterEnter() { }, beforeLeave() { }, afterLeave() { } }; function Cx(e) { var t; const n = document.getElementById("jsFooter"), i = e.querySelector("j#sMemberReadAll"), r = e.querySelector("#jsEducationReadAll"); n && "member" == (null == (t = location.pathname) ? void 0 : t.split("/")[1]) && n.classList.remove("pt-[30px]"), i && document.documentElement.clientWidth <= 767 ? i.children[0].innerHTML = "全て読む" : i && (i.children[0].innerHTML = "このメンバーの記事をもっと読む"), r && document.documentElement.clientWidth <= 767 ? r.children[0].innerHTML = "全て読む" : r && (r.children[0].innerHTML = "全ての記事を読む") } const Dx = { namespace: "member_detail_page", beforeEnter(e) { const t = e.next.container; null === removeEventFunctions && (removeEventFunctions = []), removeEventFunctions.push(Cx(t)) }, afterEnter() { }, beforeLeave() { }, afterLeave() { } }; Ci.registerPlugin(fa); const Lx = { namespace: "culture_page", beforeEnter(e) { const t = e.next.container; removeEventFunctions.push(gx(t)), removeEventFunctions.push(function (e) { const t = e.querySelectorAll(".js-scroll-section"), n = []; let i = []; if (!t) return; t.forEach((e => { let t = e.querySelector(".js-scroll-section-image-before"), r = e.querySelector(".js-scroll-section-image-after"), s = e.querySelector(".js-scroll-section-text-before"), a = e.querySelector(".js-scroll-section-text-after"), o = e.querySelector(".js-scroll-section-text-2"), l = !0, c = Ci.timeline({ scrollTrigger: { trigger: e, start: () => "center center", end: () => "+=" + (window.LIG.mql.matche ? 2200 : 1600), scrub: 1, markers: !1, invalidateOnRefresh: !0 }, ease: "circ.out" }); c.to(s, { y: -60, duration: .3, opacity: 0 }), screen.width <= 768 ? c.to(a, { opacity: 1, duration: .5, y: 0 }, .5).to(a, { y: -60, duration: .3, opacity: 0 }, .8).to(o, { opacity: 1, duration: .3, y: 0 }, 1).to(o, { duration: .2 }, 1.5) : c.to(a, { opacity: 1, duration: .3, y: 0 }, .5).to(a, { duration: .2 }, .8); let u = Ci.timeline({ scrollTrigger: { trigger: e, start: () => "center center", end: () => "+=" + (window.LIG.mql.matche ? 2200 : 1600), pin: !0, scrub: 1, markers: !1, invalidateOnRefresh: !0, onEnter: () => { l = !1 }, onLeaveBack: () => { l = !0, e.classList.remove("js_cultureImage") } }, ease: "circ.out" }); n.push(u.scrollTrigger), u.to([t, r], { scale: 1, duration: screen.width <= 768 ? 1.2 : .3 }).to(t, { borderRadius: 0, duration: screen.width <= 768 ? 1.1 : .2 }, "-=0.2").call((() => { l || e.classList.add("js_cultureImage") }), {}, .2).to(t, { opacity: 0, duration: (screen.width, .3) }, .4).to(r, { opacity: .8, duration: .3 }, .4).to(r, { duration: .3 }, .7), i.push(c), i.push(u) })), e.querySelectorAll(".js-cultureColumn-image").forEach((e => { const t = e.querySelectorAll("img"), n = e.querySelectorAll("picture"); Ci.timeline({ scrollTrigger: { trigger: e, start: "center bottom", once: !0, invalidateOnRefresh: !0, toggleClass: { targets: [t, n], className: "js-scrollShow" } } }) })); const r = dx(n); return function () { r() } }(t)) }, afterEnter() { }, beforeLeave() { }, afterLeave() { } }; class Ax extends Qm { constructor(e) { super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function (e) { return new Fx(e) })), this.register((function (e) { return new Ux(e) })), this.register((function (e) { return new Vx(e) })), this.register((function (e) { return new zx(e) })), this.register((function (e) { return new kx(e) })), this.register((function (e) { return new Nx(e) })), this.register((function (e) { return new Bx(e) })), this.register((function (e) { return new Hx(e) })), this.register((function (e) { return new Ox(e) })), this.register((function (e) { return new Gx(e) })) } load(e, t, n, i) { const r = this; let s; s = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : wg.extractUrlBase(e), this.manager.itemStart(e); const a = function (t) { i ? i(t) : console.error(t), r.manager.itemError(e), r.manager.itemEnd(e) }, o = new tg(this.manager); o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, (function (n) { try { r.parse(n, s, (function (n) { t(n), r.manager.itemEnd(e) }), a) } catch (e) { a(e) } }), n, a) } setDRACOLoader(e) { return this.dracoLoader = e, this } setDDSLoader() { throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".') } setKTX2Loader(e) { return this.ktx2Loader = e, this } setMeshoptDecoder(e) { return this.meshoptDecoder = e, this } register(e) { return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this } unregister(e) { return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this } parse(e, t, n, i) { let r; const s = {}, a = {}; if ("string" == typeof e) r = e; else if (wg.decodeText(new Uint8Array(e, 0, 4)) === jx) { try { s[Rx.KHR_BINARY_GLTF] = new Wx(e) } catch (e) { return void (i && i(e)) } r = s[Rx.KHR_BINARY_GLTF].content } else r = wg.decodeText(new Uint8Array(e)); const o = JSON.parse(r); if (void 0 === o.asset || o.asset.version[0] < 2) return void (i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."))); const l = new p_(o, { path: t || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder }); l.fileLoader.setRequestHeader(this.requestHeader); for (let e = 0; e < this.pluginCallbacks.length; e++) { const t = this.pluginCallbacks[e](l); a[t.name] = t, s[t.name] = !0 } if (o.extensionsUsed) for (let e = 0; e < o.extensionsUsed.length; ++e) { const t = o.extensionsUsed[e], n = o.extensionsRequired || []; switch (t) { case Rx.KHR_MATERIALS_UNLIT: s[t] = new Ix; break; case Rx.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: s[t] = new Yx; break; case Rx.KHR_DRACO_MESH_COMPRESSION: s[t] = new qx(o, this.dracoLoader); break; case Rx.KHR_TEXTURE_TRANSFORM: s[t] = new $x; break; case Rx.KHR_MESH_QUANTIZATION: s[t] = new Zx; break; default: n.indexOf(t) >= 0 && void 0 === a[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".') } } l.setExtensions(s), l.setPlugins(a), l.parse(n, i) } parseAsync(e, t) { const n = this; return new Promise((function (i, r) { n.parse(e, t, i, r) })) } } function Px() { let e = {}; return { get: function (t) { return e[t] }, add: function (t, n) { e[t] = n }, remove: function (t) { delete e[t] }, removeAll: function () { e = {} } } } const Rx = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness", KHR_MATERIALS_SHEEN: "KHR_materials_sheen", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression" }; class Ox { constructor(e) { this.parser = e, this.name = Rx.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} } } _markDefs() { const e = this.parser, t = this.parser.json.nodes || []; for (let n = 0, i = t.length; n < i; n++) { const i = t[n]; i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && e._addNodeRef(this.cache, i.extensions[this.name].light) } } _loadLight(e) { const t = this.parser, n = "light:" + e; let i = t.cache.get(n); if (i) return i; const r = t.json, s = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e]; let a; const o = new _l(16777215); void 0 !== s.color && o.fromArray(s.color); const l = void 0 !== s.range ? s.range : 0; switch (s.type) { case "directional": a = new yg(o), a.target.position.set(0, 0, -1), a.add(a.target); break; case "point": a = new gg(o), a.distance = l; break; case "spot": a = new hg(o), a.distance = l, s.spot = s.spot || {}, s.spot.innerConeAngle = void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0, s.spot.outerConeAngle = void 0 !== s.spot.outerConeAngle ? s.spot.outerConeAngle : Math.PI / 4, a.angle = s.spot.outerConeAngle, a.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle, a.target.position.set(0, 0, -1), a.add(a.target); break; default: throw new Error("THREE.GLTFLoader: Unexpected light type: " + s.type) }return a.position.set(0, 0, 0), a.decay = 2, void 0 !== s.intensity && (a.intensity = s.intensity), a.name = t.createUniqueName(s.name || "light_" + e), i = Promise.resolve(a), t.cache.add(n, i), i } createNodeAttachment(e) { const t = this, n = this.parser, i = n.json.nodes[e], r = (i.extensions && i.extensions[this.name] || {}).light; return void 0 === r ? null : this._loadLight(r).then((function (e) { return n._getNodeRef(t.cache, r, e) })) } } class Ix { constructor() { this.name = Rx.KHR_MATERIALS_UNLIT } getMaterialType() { return Xc } extendParams(e, t, n) { const i = []; e.color = new _l(1, 1, 1), e.opacity = 1; const r = t.pbrMetallicRoughness; if (r) { if (Array.isArray(r.baseColorFactor)) { const t = r.baseColorFactor; e.color.fromArray(t), e.opacity = t[3] } void 0 !== r.baseColorTexture && i.push(n.assignTexture(e, "map", r.baseColorTexture)) } return Promise.all(i) } } class Fx { constructor(e) { this.parser = e, this.name = Rx.KHR_MATERIALS_CLEARCOAT } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? Dm : null } extendMaterialParams(e, t) { const n = this.parser, i = n.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const r = [], s = i.extensions[this.name]; if (void 0 !== s.clearcoatFactor && (t.clearcoat = s.clearcoatFactor), void 0 !== s.clearcoatTexture && r.push(n.assignTexture(t, "clearcoatMap", s.clearcoatTexture)), void 0 !== s.clearcoatRoughnessFactor && (t.clearcoatRoughness = s.clearcoatRoughnessFactor), void 0 !== s.clearcoatRoughnessTexture && r.push(n.assignTexture(t, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)), void 0 !== s.clearcoatNormalTexture && (r.push(n.assignTexture(t, "clearcoatNormalMap", s.clearcoatNormalTexture)), void 0 !== s.clearcoatNormalTexture.scale)) { const e = s.clearcoatNormalTexture.scale; t.clearcoatNormalScale = new ul(e, e) } return Promise.all(r) } } class zx { constructor(e) { this.parser = e, this.name = Rx.KHR_MATERIALS_SHEEN } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? Dm : null } extendMaterialParams(e, t) { const n = this.parser, i = n.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const r = []; t.sheenColor = new _l(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1; const s = i.extensions[this.name]; return void 0 !== s.sheenColorFactor && t.sheenColor.fromArray(s.sheenColorFactor), void 0 !== s.sheenRoughnessFactor && (t.sheenRoughness = s.sheenRoughnessFactor), void 0 !== s.sheenColorTexture && r.push(n.assignTexture(t, "sheenColorMap", s.sheenColorTexture)), void 0 !== s.sheenRoughnessTexture && r.push(n.assignTexture(t, "sheenRoughnessMap", s.sheenRoughnessTexture)), Promise.all(r) } } class kx { constructor(e) { this.parser = e, this.name = Rx.KHR_MATERIALS_TRANSMISSION } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? Dm : null } extendMaterialParams(e, t) { const n = this.parser, i = n.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const r = [], s = i.extensions[this.name]; return void 0 !== s.transmissionFactor && (t.transmission = s.transmissionFactor), void 0 !== s.transmissionTexture && r.push(n.assignTexture(t, "transmissionMap", s.transmissionTexture)), Promise.all(r) } } class Nx { constructor(e) { this.parser = e, this.name = Rx.KHR_MATERIALS_VOLUME } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? Dm : null } extendMaterialParams(e, t) { const n = this.parser, i = n.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const r = [], s = i.extensions[this.name]; t.thickness = void 0 !== s.thicknessFactor ? s.thicknessFactor : 0, void 0 !== s.thicknessTexture && r.push(n.assignTexture(t, "thicknessMap", s.thicknessTexture)), t.attenuationDistance = s.attenuationDistance || 0; const a = s.attenuationColor || [1, 1, 1]; return t.attenuationColor = new _l(a[0], a[1], a[2]), Promise.all(r) } } class Bx { constructor(e) { this.parser = e, this.name = Rx.KHR_MATERIALS_IOR } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? Dm : null } extendMaterialParams(e, t) { const n = this.parser.json.materials[e]; if (!n.extensions || !n.extensions[this.name]) return Promise.resolve(); const i = n.extensions[this.name]; return t.ior = void 0 !== i.ior ? i.ior : 1.5, Promise.resolve() } } class Hx { constructor(e) { this.parser = e, this.name = Rx.KHR_MATERIALS_SPECULAR } getMaterialType(e) { const t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? Dm : null } extendMaterialParams(e, t) { const n = this.parser, i = n.json.materials[e]; if (!i.extensions || !i.extensions[this.name]) return Promise.resolve(); const r = [], s = i.extensions[this.name]; t.specularIntensity = void 0 !== s.specularFactor ? s.specularFactor : 1, void 0 !== s.specularTexture && r.push(n.assignTexture(t, "specularIntensityMap", s.specularTexture)); const a = s.specularColorFactor || [1, 1, 1]; return t.specularColor = new _l(a[0], a[1], a[2]), void 0 !== s.specularColorTexture && r.push(n.assignTexture(t, "specularColorMap", s.specularColorTexture).then((function (e) { e.encoding = Wo }))), Promise.all(r) } } class Ux { constructor(e) { this.parser = e, this.name = Rx.KHR_TEXTURE_BASISU } loadTexture(e) { const t = this.parser, n = t.json, i = n.textures[e]; if (!i.extensions || !i.extensions[this.name]) return null; const r = i.extensions[this.name], s = t.options.ktx2Loader; if (!s) { if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"); return null } return t.loadTextureImage(e, r.source, s) } } class Vx { constructor(e) { this.parser = e, this.name = Rx.EXT_TEXTURE_WEBP, this.isSupported = null } loadTexture(e) { const t = this.name, n = this.parser, i = n.json, r = i.textures[e]; if (!r.extensions || !r.extensions[t]) return null; const s = r.extensions[t], a = i.images[s.source]; let o = n.textureLoader; if (a.uri) { const e = n.options.manager.getHandler(a.uri); null !== e && (o = e) } return this.detectSupport().then((function (r) { if (r) return n.loadTextureImage(e, a, o); if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported."); return n.loadTexture(e) })) } detectSupport() { return this.isSupported || (this.isSupported = new Promise((function (e) { const t = new Image; t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function () { e(1 === t.height) } }))), this.isSupported } } class Gx { constructor(e) { this.name = Rx.EXT_MESHOPT_COMPRESSION, this.parser = e } loadBufferView(e) { const t = this.parser.json, n = t.bufferViews[e]; if (n.extensions && n.extensions[this.name]) { const e = n.extensions[this.name], i = this.parser.getDependency("buffer", e.buffer), r = this.parser.options.meshoptDecoder; if (!r || !r.supported) { if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"); return null } return Promise.all([i, r.ready]).then((function (t) { const n = e.byteOffset || 0, i = e.byteLength || 0, s = e.count, a = e.byteStride, o = new ArrayBuffer(s * a), l = new Uint8Array(t[0], n, i); return r.decodeGltfBuffer(new Uint8Array(o), s, a, l, e.mode, e.filter), o })) } return null } } const jx = "glTF"; class Wx { constructor(e) { this.name = Rx.KHR_BINARY_GLTF, this.content = null, this.body = null; const t = new DataView(e, 0, 12); if (this.header = { magic: wg.decodeText(new Uint8Array(e.slice(0, 4))), version: t.getUint32(4, !0), length: t.getUint32(8, !0) }, this.header.magic !== jx) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header."); if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected."); const n = this.header.length - 12, i = new DataView(e, 12); let r = 0; for (; r < n;) { const t = i.getUint32(r, !0); r += 4; const n = i.getUint32(r, !0); if (r += 4, 1313821514 === n) { const n = new Uint8Array(e, 12 + r, t); this.content = wg.decodeText(n) } else if (5130562 === n) { const n = 12 + r; this.body = e.slice(n, n + t) } r += t } if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.") } } class qx { constructor(e, t) { if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided."); this.name = Rx.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload() } decodePrimitive(e, t) { const n = this.json, i = this.dracoLoader, r = e.extensions[this.name].bufferView, s = e.extensions[this.name].attributes, a = {}, o = {}, l = {}; for (const e in s) { const t = r_[e] || e.toLowerCase(); a[t] = s[e] } for (const t in e.attributes) { const i = r_[t] || t.toLowerCase(); if (void 0 !== s[t]) { const r = n.accessors[e.attributes[t]], s = e_[r.componentType]; l[i] = s, o[i] = !0 === r.normalized } } return t.getDependency("bufferView", r).then((function (e) { return new Promise((function (t) { i.decodeDracoFile(e, (function (e) { for (const t in e.attributes) { const n = e.attributes[t], i = o[t]; void 0 !== i && (n.normalized = i) } t(e) }), a, l) })) })) } } class $x { constructor() { this.name = Rx.KHR_TEXTURE_TRANSFORM } extendTexture(e, t) { return void 0 !== t.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === t.offset && void 0 === t.rotation && void 0 === t.scale || (e = e.clone(), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e } } class Xx extends Cm { constructor(e) { super(), this.isGLTFSpecularGlossinessMaterial = !0; const t = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"), n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"), i = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"), r = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"), s = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"), a = { specular: { value: (new _l).setHex(16777215) }, glossiness: { value: 1 }, specularMap: { value: null }, glossinessMap: { value: null } }; this._extraUniforms = a, this.onBeforeCompile = function (e) { for (const t in a) e.uniforms[t] = a[t]; e.fragmentShader = e.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", i).replace("#include <metalnessmap_fragment>", r).replace("#include <lights_physical_fragment>", s) }, Object.defineProperties(this, { specular: { get: function () { return a.specular.value }, set: function (e) { a.specular.value = e } }, specularMap: { get: function () { return a.specularMap.value }, set: function (e) { a.specularMap.value = e, e ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP } }, glossiness: { get: function () { return a.glossiness.value }, set: function (e) { a.glossiness.value = e } }, glossinessMap: { get: function () { return a.glossinessMap.value }, set: function (e) { a.glossinessMap.value = e, e ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV) } } }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e) } copy(e) { return super.copy(e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this } } class Yx { constructor() { this.name = Rx.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"] } getMaterialType() { return Xx } extendParams(e, t, n) { const i = t.extensions[this.name]; e.color = new _l(1, 1, 1), e.opacity = 1; const r = []; if (Array.isArray(i.diffuseFactor)) { const t = i.diffuseFactor; e.color.fromArray(t), e.opacity = t[3] } if (void 0 !== i.diffuseTexture && r.push(n.assignTexture(e, "map", i.diffuseTexture)), e.emissive = new _l(0, 0, 0), e.glossiness = void 0 !== i.glossinessFactor ? i.glossinessFactor : 1, e.specular = new _l(1, 1, 1), Array.isArray(i.specularFactor) && e.specular.fromArray(i.specularFactor), void 0 !== i.specularGlossinessTexture) { const t = i.specularGlossinessTexture; r.push(n.assignTexture(e, "glossinessMap", t)), r.push(n.assignTexture(e, "specularMap", t)) } return Promise.all(r) } createMaterial(e) { const t = new Xx(e); return t.fog = !0, t.color = e.color, t.map = void 0 === e.map ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = void 0 === e.aoMap ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = 1, t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap, t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = void 0 === e.normalMap ? null : e.normalMap, t.normalMapType = 0, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = void 0 === e.specularMap ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = void 0 === e.envMap ? null : e.envMap, t.envMapIntensity = 1, t.refractionRatio = .98, t } } class Zx { constructor() { this.name = Rx.KHR_MESH_QUANTIZATION } } class Kx extends km { constructor(e, t, n, i) { super(e, t, n, i) } copySampleValue_(e) { const t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = e * i * 3 + i; for (let e = 0; e !== i; e++)t[e] = n[r + e]; return t } } Kx.prototype.beforeStart_ = Kx.prototype.copySampleValue_, Kx.prototype.afterEnd_ = Kx.prototype.copySampleValue_, Kx.prototype.interpolate_ = function (e, t, n, i) { const r = this.resultBuffer, s = this.sampleValues, a = this.valueSize, o = 2 * a, l = 3 * a, c = i - t, u = (n - t) / c, h = u * u, d = h * u, p = e * l, f = p - l, m = -2 * d + 3 * h, g = d - h, v = 1 - m, y = g - h + u; for (let e = 0; e !== a; e++) { const t = s[f + e + a], n = s[f + e + o] * c, i = s[p + e + a], l = s[p + e] * c; r[e] = v * t + y * n + m * i + g * l } return r }; const Jx = new Pl; class Qx extends Kx { interpolate_(e, t, n, i) { const r = super.interpolate_(e, t, n, i); return Jx.fromArray(r).normalize().toArray(r), r } } const e_ = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, t_ = { 9728: _o, 9729: So, 9984: wo, 9985: 1007, 9986: bo, 9987: Eo }, n_ = { 33071: yo, 33648: xo, 10497: vo }, i_ = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, r_ = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, s_ = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, a_ = { CUBICSPLINE: void 0, LINEAR: Bo, STEP: No }; function o_(e, t, n) { for (const i in n.extensions) void 0 === e[i] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[i] = n.extensions[i]) } function l_(e, t) { void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras)) } function c_(e, t) { if (e.updateMorphTargets(), void 0 !== t.weights) for (let n = 0, i = t.weights.length; n < i; n++)e.morphTargetInfluences[n] = t.weights[n]; if (t.extras && Array.isArray(t.extras.targetNames)) { const n = t.extras.targetNames; if (e.morphTargetInfluences.length === n.length) { e.morphTargetDictionary = {}; for (let t = 0, i = n.length; t < i; t++)e.morphTargetDictionary[n[t]] = t } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.") } } function u_(e) { const t = e.extensions && e.extensions[Rx.KHR_DRACO_MESH_COMPRESSION]; let n; return n = t ? "draco:" + t.bufferView + ":" + t.indices + ":" + h_(t.attributes) : e.indices + ":" + h_(e.attributes) + ":" + e.mode, n } function h_(e) { let t = ""; const n = Object.keys(e).sort(); for (let i = 0, r = n.length; i < r; i++)t += n[i] + ":" + e[n[i]] + ";"; return t } function d_(e) { switch (e) { case Int8Array: return 1 / 127; case Uint8Array: return 1 / 255; case Int16Array: return 1 / 32767; case Uint16Array: return 1 / 65535; default: throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.") } } class p_ { constructor(e = {}, t = {}) { this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new Px, this.associations = new Map, this.primitiveCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {}, "undefined" != typeof createImageBitmap && !1 === /Firefox|^((?!chrome|android).)*safari/i.test(navigator.userAgent) ? this.textureLoader = new bg(this.options.manager) : this.textureLoader = new rg(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new tg(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0) } setExtensions(e) { this.extensions = e } setPlugins(e) { this.plugins = e } parse(e, t) { const n = this, i = this.json, r = this.extensions; this.cache.removeAll(), this._invokeAll((function (e) { return e._markDefs && e._markDefs() })), Promise.all(this._invokeAll((function (e) { return e.beforeRoot && e.beforeRoot() }))).then((function () { return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")]) })).then((function (t) { const s = { scene: t[0][i.scene || 0], scenes: t[0], animations: t[1], cameras: t[2], asset: i.asset, parser: n, userData: {} }; o_(r, s, i), l_(s, i), Promise.all(n._invokeAll((function (e) { return e.afterRoot && e.afterRoot(s) }))).then((function () { e(s) })) })).catch(t) } _markDefs() { const e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || []; for (let n = 0, i = t.length; n < i; n++) { const i = t[n].joints; for (let t = 0, n = i.length; t < n; t++)e[i[t]].isBone = !0 } for (let t = 0, i = e.length; t < i; t++) { const i = e[t]; void 0 !== i.mesh && (this._addNodeRef(this.meshCache, i.mesh), void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)), void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera) } } _addNodeRef(e, t) { void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++) } _getNodeRef(e, t, n) { if (e.refs[t] <= 1) return n; const i = n.clone(), r = (e, t) => { const n = this.associations.get(e); null != n && this.associations.set(t, n); for (const [n, i] of e.children.entries()) r(i, t.children[n]) }; return r(n, i), i.name += "_instance_" + e.uses[t]++, i } _invokeOne(e) { const t = Object.values(this.plugins); t.push(this); for (let n = 0; n < t.length; n++) { const i = e(t[n]); if (i) return i } return null } _invokeAll(e) { const t = Object.values(this.plugins); t.unshift(this); const n = []; for (let i = 0; i < t.length; i++) { const r = e(t[i]); r && n.push(r) } return n } getDependency(e, t) { const n = e + ":" + t; let i = this.cache.get(n); if (!i) { switch (e) { case "scene": i = this.loadScene(t); break; case "node": i = this.loadNode(t); break; case "mesh": i = this._invokeOne((function (e) { return e.loadMesh && e.loadMesh(t) })); break; case "accessor": i = this.loadAccessor(t); break; case "bufferView": i = this._invokeOne((function (e) { return e.loadBufferView && e.loadBufferView(t) })); break; case "buffer": i = this.loadBuffer(t); break; case "material": i = this._invokeOne((function (e) { return e.loadMaterial && e.loadMaterial(t) })); break; case "texture": i = this._invokeOne((function (e) { return e.loadTexture && e.loadTexture(t) })); break; case "skin": i = this.loadSkin(t); break; case "animation": i = this.loadAnimation(t); break; case "camera": i = this.loadCamera(t); break; default: throw new Error("Unknown type: " + e) }this.cache.add(n, i) } return i } getDependencies(e) { let t = this.cache.get(e); if (!t) { const n = this, i = this.json[e + ("mesh" === e ? "es" : "s")] || []; t = Promise.all(i.map((function (t, i) { return n.getDependency(e, i) }))), this.cache.add(e, t) } return t } loadBuffer(e) { const t = this.json.buffers[e], n = this.fileLoader; if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported."); if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[Rx.KHR_BINARY_GLTF].body); const i = this.options; return new Promise((function (e, r) { n.load(wg.resolveURL(t.uri, i.path), e, void 0, (function () { r(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')) })) })) } loadBufferView(e) { const t = this.json.bufferViews[e]; return this.getDependency("buffer", t.buffer).then((function (e) { const n = t.byteLength || 0, i = t.byteOffset || 0; return e.slice(i, i + n) })) } loadAccessor(e) { const t = this, n = this.json, i = this.json.accessors[e]; if (void 0 === i.bufferView && void 0 === i.sparse) return Promise.resolve(null); const r = []; return void 0 !== i.bufferView ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null), void 0 !== i.sparse && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(r).then((function (e) { const r = e[0], s = i_[i.type], a = e_[i.componentType], o = a.BYTES_PER_ELEMENT, l = o * s, c = i.byteOffset || 0, u = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0, h = !0 === i.normalized; let d, p; if (u && u !== l) { const e = Math.floor(c / u), n = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + e + ":" + i.count; let l = t.cache.get(n); l || (d = new a(r, e * u, i.count * u / o), l = new Cp(d, u / o), t.cache.add(n, l)), p = new Lp(l, s, c % u / o, h) } else d = null === r ? new a(i.count * s) : new a(r, c, i.count * s), p = new Kc(d, s, h); if (void 0 !== i.sparse) { const t = i_.SCALAR, n = e_[i.sparse.indices.componentType], o = i.sparse.indices.byteOffset || 0, l = i.sparse.values.byteOffset || 0, c = new n(e[1], o, i.sparse.count * t), u = new a(e[2], l, i.sparse.count * s); null !== r && (p = new Kc(p.array.slice(), p.itemSize, p.normalized)); for (let e = 0, t = c.length; e < t; e++) { const t = c[e]; if (p.setX(t, u[e * s]), s >= 2 && p.setY(t, u[e * s + 1]), s >= 3 && p.setZ(t, u[e * s + 2]), s >= 4 && p.setW(t, u[e * s + 3]), s >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.") } } return p })) } loadTexture(e) { const t = this.json, n = this.options, i = t.textures[e].source, r = t.images[i]; let s = this.textureLoader; if (r.uri) { const e = n.manager.getHandler(r.uri); null !== e && (s = e) } return this.loadTextureImage(e, i, s) } loadTextureImage(e, t, n) { const i = this, r = this.json, s = r.textures[e], a = r.images[t], o = (a.uri || a.bufferView) + ":" + s.sampler; if (this.textureCache[o]) return this.textureCache[o]; const l = this.loadImageSource(t, n).then((function (t) { t.flipY = !1, s.name && (t.name = s.name); const n = (r.samplers || {})[s.sampler] || {}; return t.magFilter = t_[n.magFilter] || So, t.minFilter = t_[n.minFilter] || Eo, t.wrapS = n_[n.wrapS] || vo, t.wrapT = n_[n.wrapT] || vo, i.associations.set(t, { textures: e }), t })).catch((function () { return null })); return this.textureCache[o] = l, l } loadImageSource(e, t) { const n = this.json, i = this.options; if (void 0 !== this.sourceCache[e]) return this.sourceCache[e].then((function (e) { return e.clone() })).catch((function (e) { throw e })); const r = n.images[e], s = self.URL || self.webkitURL; let a = r.uri || "", o = !1; if (void 0 !== r.bufferView) a = this.getDependency("bufferView", r.bufferView).then((function (e) { o = !0; const t = new Blob([e], { type: r.mimeType }); return a = s.createObjectURL(t), a })); else if (void 0 === r.uri) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"); const l = Promise.resolve(a).then((function (e) { return new Promise((function (n, r) { let s = n; !0 === t.isImageBitmapLoader && (s = function (e) { const t = new Tl(e); t.needsUpdate = !0, n(t) }), t.load(wg.resolveURL(e, i.path), s, void 0, r) })) })).then((function (e) { var t; return !0 === o && s.revokeObjectURL(a), e.userData.mimeType = r.mimeType || ((t = r.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/) ? "image/jpeg" : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/) ? "image/webp" : "image/png"), e })).catch((function (e) { throw console.error("THREE.GLTFLoader: Couldn't load texture", a), e })); return this.sourceCache[e] = l, l } assignTexture(e, t, n) { const i = this; return this.getDependency("texture", n.index).then((function (r) { if (void 0 === n.texCoord || 0 == n.texCoord || "aoMap" === t && 1 == n.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + t + " not yet supported."), i.extensions[Rx.KHR_TEXTURE_TRANSFORM]) { const e = void 0 !== n.extensions ? n.extensions[Rx.KHR_TEXTURE_TRANSFORM] : void 0; if (e) { const t = i.associations.get(r); r = i.extensions[Rx.KHR_TEXTURE_TRANSFORM].extendTexture(r, e), i.associations.set(r, t) } } return e[t] = r, r })) } assignFinalMaterial(e) { const t = e.geometry; let n = e.material; const i = void 0 === t.attributes.tangent, r = void 0 !== t.attributes.color, s = void 0 === t.attributes.normal; if (e.isPoints) { const e = "PointsMaterial:" + n.uuid; let t = this.cache.get(e); t || (t = new xf, $c.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, t.sizeAttenuation = !1, this.cache.add(e, t)), n = t } else if (e.isLine) { const e = "LineBasicMaterial:" + n.uuid; let t = this.cache.get(e); t || (t = new lf, $c.prototype.copy.call(t, n), t.color.copy(n.color), this.cache.add(e, t)), n = t } if (i || r || s) { let e = "ClonedMaterial:" + n.uuid + ":"; n.isGLTFSpecularGlossinessMaterial && (e += "specular-glossiness:"), i && (e += "derivative-tangents:"), r && (e += "vertex-colors:"), s && (e += "flat-shading:"); let t = this.cache.get(e); t || (t = n.clone(), r && (t.vertexColors = !0), s && (t.flatShading = !0), i && (t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(e, t), this.associations.set(t, this.associations.get(n))), n = t } n.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute("uv2", t.attributes.uv), e.material = n } getMaterialType() { return Cm } loadMaterial(e) { const t = this, n = this.json, i = this.extensions, r = n.materials[e]; let s; const a = {}, o = r.extensions || {}, l = []; if (o[Rx.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) { const e = i[Rx.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]; s = e.getMaterialType(), l.push(e.extendParams(a, r, t)) } else if (o[Rx.KHR_MATERIALS_UNLIT]) { const e = i[Rx.KHR_MATERIALS_UNLIT]; s = e.getMaterialType(), l.push(e.extendParams(a, r, t)) } else { const n = r.pbrMetallicRoughness || {}; if (a.color = new _l(1, 1, 1), a.opacity = 1, Array.isArray(n.baseColorFactor)) { const e = n.baseColorFactor; a.color.fromArray(e), a.opacity = e[3] } void 0 !== n.baseColorTexture && l.push(t.assignTexture(a, "map", n.baseColorTexture)), a.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, a.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (l.push(t.assignTexture(a, "metalnessMap", n.metallicRoughnessTexture)), l.push(t.assignTexture(a, "roughnessMap", n.metallicRoughnessTexture))), s = this._invokeOne((function (t) { return t.getMaterialType && t.getMaterialType(e) })), l.push(Promise.all(this._invokeAll((function (t) { return t.extendMaterialParams && t.extendMaterialParams(e, a) })))) } !0 === r.doubleSided && (a.side = 2); const c = r.alphaMode || "OPAQUE"; if ("BLEND" === c ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, "MASK" === c && (a.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : .5)), void 0 !== r.normalTexture && s !== Xc && (l.push(t.assignTexture(a, "normalMap", r.normalTexture)), a.normalScale = new ul(1, 1), void 0 !== r.normalTexture.scale)) { const e = r.normalTexture.scale; a.normalScale.set(e, e) } return void 0 !== r.occlusionTexture && s !== Xc && (l.push(t.assignTexture(a, "aoMap", r.occlusionTexture)), void 0 !== r.occlusionTexture.strength && (a.aoMapIntensity = r.occlusionTexture.strength)), void 0 !== r.emissiveFactor && s !== Xc && (a.emissive = (new _l).fromArray(r.emissiveFactor)), void 0 !== r.emissiveTexture && s !== Xc && l.push(t.assignTexture(a, "emissiveMap", r.emissiveTexture)), Promise.all(l).then((function () { let n; return n = s === Xx ? i[Rx.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a) : new s(a), r.name && (n.name = r.name), n.map && (n.map.encoding = Wo), n.emissiveMap && (n.emissiveMap.encoding = Wo), n.sheenColorMap && (n.sheenColorMap.encoding = Wo), n.specularColorMap && (n.specularColorMap.encoding = Wo), n.specularMap && (n.specularMap.encoding = Wo), l_(n, r), t.associations.set(n, { materials: e }), r.extensions && o_(i, n, r), n })) } createUniqueName(e) { const t = kg.sanitizeNodeName(e || ""); let n = t; for (let e = 1; this.nodeNamesUsed[n]; ++e)n = t + "_" + e; return this.nodeNamesUsed[n] = !0, n } loadGeometries(e) { const t = this, n = this.extensions, i = this.primitiveCache; function r(e) { return n[Rx.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function (n) { return m_(n, e, t) })) } const s = []; for (let n = 0, a = e.length; n < a; n++) { const a = e[n], o = u_(a), l = i[o]; if (l) s.push(l.promise); else { let e; e = a.extensions && a.extensions[Rx.KHR_DRACO_MESH_COMPRESSION] ? r(a) : m_(new lu, a, t), i[o] = { primitive: a, promise: e }, s.push(e) } } return Promise.all(s) } loadMesh(e) { const t = this, n = this.json, i = this.extensions, r = n.meshes[e], s = r.primitives, a = []; for (let e = 0, t = s.length; e < t; e++) { const t = void 0 === s[e].material ? (void 0 === (o = this.cache).DefaultMaterial && (o.DefaultMaterial = new Cm({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: 0 })), o.DefaultMaterial) : this.getDependency("material", s[e].material); a.push(t) } var o; return a.push(t.loadGeometries(s)), Promise.all(a).then((function (n) { const a = n.slice(0, n.length - 1), o = n[n.length - 1], l = []; for (let n = 0, c = o.length; n < c; n++) { const c = o[n], u = s[n]; let h; const d = a[n]; if (4 === u.mode || 5 === u.mode || 6 === u.mode || void 0 === u.mode) h = !0 === r.isSkinnedMesh ? new Zp(c, d) : new Tu(c, d), !0 !== h.isSkinnedMesh || h.geometry.attributes.skinWeight.normalized || h.normalizeSkinWeights(), 5 === u.mode ? h.geometry = g_(h.geometry, 1) : 6 === u.mode && (h.geometry = g_(h.geometry, 2)); else if (1 === u.mode) h = new vf(c, d); else if (3 === u.mode) h = new ff(c, d); else if (2 === u.mode) h = new yf(c, d); else { if (0 !== u.mode) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + u.mode); h = new Ef(c, d) } Object.keys(h.geometry.morphAttributes).length > 0 && c_(h, r), h.name = t.createUniqueName(r.name || "mesh_" + e), l_(h, r), u.extensions && o_(i, h, u), t.assignFinalMaterial(h), l.push(h) } for (let n = 0, i = l.length; n < i; n++)t.associations.set(l[n], { meshes: e, primitives: n }); if (1 === l.length) return l[0]; const c = new vp; t.associations.set(c, { meshes: e }); for (let e = 0, t = l.length; e < t; e++)c.add(l[e]); return c })) } loadCamera(e) { let t; const n = this.json.cameras[e], i = n[n.type]; if (i) return "perspective" === n.type ? t = new Iu(cl.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : "orthographic" === n.type && (t = new rh(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (t.name = this.createUniqueName(n.name)), l_(t, n), Promise.resolve(t); console.warn("THREE.GLTFLoader: Missing camera parameters.") } loadSkin(e) { const t = this.json.skins[e], n = { joints: t.joints }; return void 0 === t.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", t.inverseBindMatrices).then((function (e) { return n.inverseBindMatrices = e, n })) } loadAnimation(e) { const t = this.json.animations[e], n = [], i = [], r = [], s = [], a = []; for (let e = 0, o = t.channels.length; e < o; e++) { const o = t.channels[e], l = t.samplers[o.sampler], c = o.target, u = void 0 !== c.node ? c.node : c.id, h = void 0 !== t.parameters ? t.parameters[l.input] : l.input, d = void 0 !== t.parameters ? t.parameters[l.output] : l.output; n.push(this.getDependency("node", u)), i.push(this.getDependency("accessor", h)), r.push(this.getDependency("accessor", d)), s.push(l), a.push(c) } return Promise.all([Promise.all(n), Promise.all(i), Promise.all(r), Promise.all(s), Promise.all(a)]).then((function (n) { const i = n[0], r = n[1], s = n[2], a = n[3], o = n[4], l = []; for (let e = 0, t = i.length; e < t; e++) { const t = i[e], n = r[e], c = s[e], u = a[e], h = o[e]; if (void 0 === t) continue; let d; switch (t.updateMatrix(), t.matrixAutoUpdate = !0, s_[h.path]) { case s_.weights: d = jm; break; case s_.rotation: d = qm; break; default: d = Xm }const p = t.name ? t.name : t.uuid, f = void 0 !== u.interpolation ? a_[u.interpolation] : Bo, m = []; s_[h.path] === s_.weights ? t.traverse((function (e) { e.morphTargetInfluences && m.push(e.name ? e.name : e.uuid) })) : m.push(p); let g = c.array; if (c.normalized) { const e = d_(g.constructor), t = new Float32Array(g.length); for (let n = 0, i = g.length; n < i; n++)t[n] = g[n] * e; g = t } for (let e = 0, t = m.length; e < t; e++) { const t = new d(m[e] + "." + s_[h.path], n.array, g, f); "CUBICSPLINE" === u.interpolation && (t.createInterpolant = function (e) { return new (this instanceof qm ? Qx : Kx)(this.times, this.values, this.getValueSize() / 3, e) }, t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), l.push(t) } } const c = t.name ? t.name : "animation_" + e; return new Ym(c, void 0, l) })) } createNodeMesh(e) { const t = this.json, n = this, i = t.nodes[e]; return void 0 === i.mesh ? null : n.getDependency("mesh", i.mesh).then((function (e) { const t = n._getNodeRef(n.meshCache, i.mesh, e); return void 0 !== i.weights && t.traverse((function (e) { if (e.isMesh) for (let t = 0, n = i.weights.length; t < n; t++)e.morphTargetInfluences[t] = i.weights[t] })), t })) } loadNode(e) { const t = this.json, n = this.extensions, i = this, r = t.nodes[e], s = r.name ? i.createUniqueName(r.name) : ""; return function () { const t = [], n = i._invokeOne((function (t) { return t.createNodeMesh && t.createNodeMesh(e) })); return n && t.push(n), void 0 !== r.camera && t.push(i.getDependency("camera", r.camera).then((function (e) { return i._getNodeRef(i.cameraCache, r.camera, e) }))), i._invokeAll((function (t) { return t.createNodeAttachment && t.createNodeAttachment(e) })).forEach((function (e) { t.push(e) })), Promise.all(t) }().then((function (t) { let a; if (a = !0 === r.isBone ? new Kp : t.length > 1 ? new vp : 1 === t.length ? t[0] : new Ic, a !== t[0]) for (let e = 0, n = t.length; e < n; e++)a.add(t[e]); if (r.name && (a.userData.name = r.name, a.name = s), l_(a, r), r.extensions && o_(n, a, r), void 0 !== r.matrix) { const e = new cc; e.fromArray(r.matrix), a.applyMatrix4(e) } else void 0 !== r.translation && a.position.fromArray(r.translation), void 0 !== r.rotation && a.quaternion.fromArray(r.rotation), void 0 !== r.scale && a.scale.fromArray(r.scale); return i.associations.has(a) || i.associations.set(a, {}), i.associations.get(a).nodes = e, a })) } loadScene(e) { const t = this.json, n = this.extensions, i = this.json.scenes[e], r = this, s = new vp; i.name && (s.name = r.createUniqueName(i.name)), l_(s, i), i.extensions && o_(n, s, i); const a = i.nodes || [], o = []; for (let e = 0, n = a.length; e < n; e++)o.push(f_(a[e], s, t, r)); return Promise.all(o).then((function () { return r.associations = (e => { const t = new Map; for (const [e, n] of r.associations) (e instanceof $c || e instanceof Tl) && t.set(e, n); return e.traverse((e => { const n = r.associations.get(e); null != n && t.set(e, n) })), t })(s), s })) } } function f_(e, t, n, i) { const r = n.nodes[e]; return i.getDependency("node", e).then((function (e) { if (void 0 === r.skin) return e; let t; return i.getDependency("skin", r.skin).then((function (e) { t = e; const n = []; for (let e = 0, r = t.joints.length; e < r; e++)n.push(i.getDependency("node", t.joints[e])); return Promise.all(n) })).then((function (n) { return e.traverse((function (e) { if (!e.isMesh) return; const i = [], r = []; for (let e = 0, s = n.length; e < s; e++) { const s = n[e]; if (s) { i.push(s); const n = new cc; void 0 !== t.inverseBindMatrices && n.fromArray(t.inverseBindMatrices.array, 16 * e), r.push(n) } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[e]) } e.bind(new tf(i, r), e.matrixWorld) })), e })) })).then((function (e) { t.add(e); const s = []; if (r.children) { const t = r.children; for (let r = 0, a = t.length; r < a; r++) { const a = t[r]; s.push(f_(a, e, n, i)) } } return Promise.all(s) })) } function m_(e, t, n) { const i = t.attributes, r = []; function s(t, i) { return n.getDependency("accessor", t).then((function (t) { e.setAttribute(i, t) })) } for (const t in i) { const n = r_[t] || t.toLowerCase(); n in e.attributes || r.push(s(i[t], n)) } if (void 0 !== t.indices && !e.index) { const i = n.getDependency("accessor", t.indices).then((function (t) { e.setIndex(t) })); r.push(i) } return l_(e, t), function (e, t, n) { const i = t.attributes, r = new Fl; if (void 0 === i.POSITION) return; { const e = n.json.accessors[i.POSITION], t = e.min, s = e.max; if (void 0 === t || void 0 === s) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION."); if (r.set(new Rl(t[0], t[1], t[2]), new Rl(s[0], s[1], s[2])), e.normalized) { const t = d_(e_[e.componentType]); r.min.multiplyScalar(t), r.max.multiplyScalar(t) } } const s = t.targets; if (void 0 !== s) { const e = new Rl, t = new Rl; for (let i = 0, r = s.length; i < r; i++) { const r = s[i]; if (void 0 !== r.POSITION) { const i = n.json.accessors[r.POSITION], s = i.min, a = i.max; if (void 0 !== s && void 0 !== a) { if (t.setX(Math.max(Math.abs(s[0]), Math.abs(a[0]))), t.setY(Math.max(Math.abs(s[1]), Math.abs(a[1]))), t.setZ(Math.max(Math.abs(s[2]), Math.abs(a[2]))), i.normalized) { const e = d_(e_[i.componentType]); t.multiplyScalar(e) } e.max(t) } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.") } } r.expandByVector(e) } e.boundingBox = r; const a = new ec; r.getCenter(a.center), a.radius = r.min.distanceTo(r.max) / 2, e.boundingSphere = a }(e, t, n), Promise.all(r).then((function () { return void 0 !== t.targets ? function (e, t, n) { let i = !1, r = !1, s = !1; for (let e = 0, n = t.length; e < n; e++) { const n = t[e]; if (void 0 !== n.POSITION && (i = !0), void 0 !== n.NORMAL && (r = !0), void 0 !== n.COLOR_0 && (s = !0), i && r && s) break } if (!i && !r && !s) return Promise.resolve(e); const a = [], o = [], l = []; for (let c = 0, u = t.length; c < u; c++) { const u = t[c]; if (i) { const t = void 0 !== u.POSITION ? n.getDependency("accessor", u.POSITION) : e.attributes.position; a.push(t) } if (r) { const t = void 0 !== u.NORMAL ? n.getDependency("accessor", u.NORMAL) : e.attributes.normal; o.push(t) } if (s) { const t = void 0 !== u.COLOR_0 ? n.getDependency("accessor", u.COLOR_0) : e.attributes.color; l.push(t) } } return Promise.all([Promise.all(a), Promise.all(o), Promise.all(l)]).then((function (t) { const n = t[0], a = t[1], o = t[2]; return i && (e.morphAttributes.position = n), r && (e.morphAttributes.normal = a), s && (e.morphAttributes.color = o), e.morphTargetsRelative = !0, e })) }(e, t.targets, n) : e })) } function g_(e, t) { let n = e.getIndex(); if (null === n) { const t = [], i = e.getAttribute("position"); if (void 0 === i) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e; for (let e = 0; e < i.count; e++)t.push(e); e.setIndex(t), n = e.getIndex() } const i = n.count - 2, r = []; if (2 === t) for (let e = 1; e <= i; e++)r.push(n.getX(0)), r.push(n.getX(e)), r.push(n.getX(e + 1)); else for (let e = 0; e < i; e++)e % 2 == 0 ? (r.push(n.getX(e)), r.push(n.getX(e + 1)), r.push(n.getX(e + 2))) : (r.push(n.getX(e + 2)), r.push(n.getX(e + 1)), r.push(n.getX(e))); r.length / 3 !== i && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."); const s = e.clone(); return s.setIndex(r), s } var v_ = (e, t, n) => new Promise(((i, r) => { var s = e => { try { o(n.next(e)) } catch (e) { r(e) } }, a = e => { try { o(n.throw(e)) } catch (e) { r(e) } }, o = e => e.done ? i(e.value) : Promise.resolve(e.value).then(s, a); o((n = n.apply(e, t)).next()) })); const y_ = { namespace: "404_page", beforeEnter(e) { const t = e.next.container; null === removeEventFunctions && (removeEventFunctions = []), removeEventFunctions.push(function (e) { const t = e.querySelector("#contents_404"), n = e.querySelector("#click_404"), i = e.querySelector("#content-body-404"); let r, s; if (!t) return; function a(e) { return v_(this, null, (function* () { const t = new rg; return new Promise((n => { t.load(e, (function (e) { n(e) })) })) })) } const o = new Promise((e => { (new Ax).load("/wp-content/themes/ligblog2022/assets/model/404_packed.glb", (function (t) { s = t, e() })) })), l = function () { const e = t.getAttribute("data-json"); return new Promise((t => { fetch(e).then((e => e.json())).then((e => { r = new Array(e.length), (() => { v_(this, null, (function* () { const n = []; for (let t = 0; t < e.length; t += 1)n[t] = a(e[t].image_s); const i = yield Promise.all(n); for (let t = 0; t < e.length; t += 1)r[t] = { smallTexture: i[t], largeTexturePath: e[t].image_l, url: e[t].url, title: e[t].title }; !function (e) { for (var t = e.length - 1; t > 0; t--) { var n = Math.floor(Math.random() * (t + 1));[e[t], e[n]] = [e[n], e[t]] } }(r), t() })) })() })) })) }(); Promise.all([o, l]).then((() => { var e, i; e = s, i = r, window.ThreeHandler.add404component(i, e, !window.LIG.isTouch, t, (e => { console.log(e), location.href = e })), setTimeout((() => { window.ThreeHandler.intro404component(1, .02, "power3.easeOut", 1.2, .008, .8, .6, "Power3.easeInOut", "Power2.easeInOut", (() => { n.classList.add("js_introFinish"), n.addEventListener("click", c) })) }), 100) })); const c = () => { n.classList.remove("js_introFinish"), n.removeEventListener("click", c), i.addEventListener("transitionend", (() => { i.querySelector("a").classList.remove("pointer-events-none") }), { once: !0 }), i.classList.add("is-active"), window.ThreeHandler.zoom404component(1.3, "power3.easeInOut", 2, (() => { console.log("finish zoom animation") })) } }(t)) }, afterEnter() { }, beforeLeave() { }, afterLeave() { } }, x_ = { namespace: "cookie_page", beforeEnter(e) { const t = e.next.container; removeEventFunctions.push(function (e) { return e.querySelectorAll("[data-slider-top]").forEach((e => { new Ky(e, { slidesPerView: "auto", grabCursor: !0, freeMode: { enabled: !0, momentumRatio: .8, momentumVelocityRatio: .8 }, keyboard: { enabled: !0, onlyInViewport: !0 }, mousewheel: { forceToAxis: !0 }, scrollbar: { el: e.querySelector("#js-progress") } }) })), function () { (void 0).forEach((e => { e.destroy(!0, !1) })) } }(t)) }, afterEnter() { }, beforeLeave() { }, afterLeave() { } }; Ci.registerPlugin(fa); const __ = { namespace: "works_page", beforeEnter(e) { const t = e.next.container; null === removeEventFunctions && (removeEventFunctions = []), removeEventFunctions.push(function (e) { new URLSearchParams(window.location.search).get("category"); const t = e.querySelectorAll(".js-works-avatar"), n = e.querySelectorAll(".js-solution-works-selection"), i = document.querySelector(".js-header").offsetHeight, r = e.querySelector(".js-member-content"), s = e.querySelector(".jsMemberModalSelected"); function a(e) { e.preventDefault(), n.forEach((e => { e.classList.contains("text-white-30") || e.classList.add("text-white-30") })); let a = e.target, o = a; const l = o.innerHTML; let c; s.innerHTML = l, "span" === a.tagName.toLowerCase() && (o = a.closest("a"), c = o.parentNode); let u = o.getAttribute("href").substring(1); c.querySelector("a").classList.remove("text-white-30"); const h = [], d = []; t.forEach((e => { "all" === u || e.getAttribute("data-" + u) ? h.push(e) : d.push(e) })); let p = 0; if (d.length > 0 && (p = .2, Ci.to(t, .2, { opacity: 0, onComplete: () => { d.forEach((e => { !function (e) { e.classList.add("hidden") }(e), e.removeAttribute("style") })) } })), h.length > 0) { Ci.fromTo(h, { opacity: 0, y: 40 }, { duration: .4, opacity: 1, delay: p, y: 0, stagger: .1, ease: "circ.out", onStart: () => { h.forEach((e => { !function (e) { e.classList.contains("hidden") && e.classList.remove("hidden") }(e) })), fa.getAll().forEach((e => { e.refresh() })) } }); let e = r.offsetTop - i; window.scrollTo({ top: e, left: 0, behavior: "smooth" }) } } return n.forEach((e => { e.addEventListener("click", a) })), function () { n.forEach((e => { e.removeEventListener("click", a) })) } }(t)), removeEventFunctions.push(Mx(t)) }, afterEnter() { }, beforeLeave() { }, afterLeave() { } }, w_ = { namespace: "work_page_detail", beforeEnter(e) { const t = e.next.container; null === removeEventFunctions && (removeEventFunctions = []), removeEventFunctions.push(Cx(t)); let n = document.querySelector("[data-work-detail-video]"); new IntersectionObserver((function (e, t) { e.forEach((e => { e.isIntersecting ? n.play() : n.pause() })) }), { root: null, rootMargin: "0px", threshold: .5 }).observe(n); let i = document.querySelector("[data-work-detail-play_button]"); n.addEventListener("play", (function () { i.style.display = "none" })), n.addEventListener("pause", (function () { i.style.display = "block" })) }, afterEnter() { }, beforeLeave() { }, afterLeave() { } }; Ci.registerPlugin(fa); const b_ = { namespace: "casestudy_page", beforeEnter(e) { const t = e.next.container; let n = !0, i = 0; const r = $(window), s = window.matchMedia("(max-width: 767px)").matches; n && (n = !1, i = r.width()), $(document).ready((function () { g(), v(), y() })); let a = 0, o = 0, l = 0, c = 0; const u = $(".overview-content", t), h = $(".tech-stack", t), d = $(".case-category", t), p = $(".casestudy-link", t), f = $(".casestudy-link-sp", t); let m = p; function g() { u.each((function () { const e = $(this).outerHeight(); e > a && (a = e) })), u.css("height", a + "px") } function v() { h.each((function () { const e = $(this).outerHeight(); e > o && (o = e) })), h.css("height", o + "px") } function y() { d.each((function () { const e = $(this).outerHeight(); e > l && (l = e) })), d.css("height", l + "px") } s && (m = f), m.each((function () { $(this).on("click", (function () { setTimeout((() => { const e = $(".js-casestudy-avatar:not(.hidden) .overview-content", t); e.each((function () { $(this).css("height", "") })), c = 0, function (e = null) { e && (e.each((function () { const e = $(this).outerHeight(); e > c && (c = e) })), e.css("height", c + "px")) }(e) }), 500) })) })), r.resize(function (e, t) { let n; return function () { const t = this, i = arguments; clearTimeout(n), n = setTimeout((function () { e.apply(t, i) }), 100) } }((function () { u.each((function () { $(this).css("height", "") })), g(), h.each((function () { $(this).css("height", "") })), v(), d.each((function () { $(this).css("height", "") })), y(), i === r.width() && location.reload() }))), null === removeEventFunctions && (removeEventFunctions = []), removeEventFunctions.push(function (e) { const t = e.querySelectorAll(".js-casestudy-avatar"), n = e.querySelectorAll(".js-solution-casestudy-selection"), i = document.querySelector(".js-header").offsetHeight, r = e.querySelector(".js-casestudy-content"), s = e.querySelector(".jsCaseModalSelected"); function a(e) { e.preventDefault(), n.forEach((e => { e.classList.contains("text-white-30") || e.classList.add("text-white-30") })); let a = e.target, o = a; const l = o.innerHTML; let c; s.innerHTML = l, "span" === a.tagName.toLowerCase() && (o = a.closest("a"), c = o.parentNode); let u = o.getAttribute("href").substring(1); c.querySelector("a").classList.remove("text-white-30"); const h = [], d = []; t.forEach((e => { "all" === u || e.getAttribute("data-" + u) ? h.push(e) : d.push(e) })); let p = 0; if (d.length > 0 && (p = .2, Ci.to(t, .2, { opacity: 0, onComplete: () => { d.forEach((e => { !function (e) { e.classList.add("hidden") }(e), e.removeAttribute("style") })) } })), h.length > 0) { Ci.fromTo(h, { opacity: 0, y: 40 }, { duration: .4, opacity: 1, delay: p, y: 0, stagger: .1, ease: "circ.out", onStart: () => { h.forEach((e => { !function (e) { e.classList.contains("hidden") && e.classList.remove("hidden") }(e) })), fa.getAll().forEach((e => { e.refresh() })) } }); let e = r.offsetTop - i; window.scrollTo({ top: e, left: 0, behavior: "smooth" }) } } return n.forEach((e => { e.addEventListener("click", a) })), function () { n.forEach((e => { e.removeEventListener("click", a) })) } }(t)), removeEventFunctions.push(function (e) { const t = ty(), n = { modalClose: e.querySelector("#jsCaseModalClose"), modalContainer: e.querySelector("#jsCaseModalContainer"), modalOverlay: e.querySelector("#jsCaseModalOverlay"), modalOpen: e.querySelector("#jsCaseModalOpen") }; return t.addEventListener(n.modalClose, "click", (() => { var e, t, i, r; null == (e = n.modalContainer) || e.classList.remove("translate-y-[0]"), null == (t = n.modalContainer) || t.classList.add("translate-y-full"), null == (i = n.modalOverlay) || i.classList.add("z-[-1]"), null == (r = n.modalOverlay) || r.classList.remove("z-10"), document.body.classList.remove("overflow-hidden") })), t.addEventListener(n.modalOpen, "click", (e => { var t, i, r, s; e.preventDefault(), null == (t = n.modalContainer) || t.classList.remove("translate-y-full"), null == (i = n.modalContainer) || i.classList.add("translate-y-[0]"), null == (r = n.modalOverlay) || r.classList.remove("z-[-1]"), null == (s = n.modalOverlay) || s.classList.add("z-10"), document.body.classList.add("overflow-hidden") })), function () { t.destroy() } }(t)) }, afterEnter() { }, beforeLeave() { }, afterLeave() { } }, S_ = { namespace: "casestudy_page_detail", beforeEnter(e) { const t = e.next.container; null === removeEventFunctions && (removeEventFunctions = []), removeEventFunctions.push(Cx(t)); let n = document.querySelector("[data-work-detail-video]"); new IntersectionObserver((function (e, t) { e.forEach((e => { e.isIntersecting ? n.play() : n.pause() })) }), { root: null, rootMargin: "0px", threshold: .5 }).observe(n); let i = document.querySelector("[data-work-detail-play_button]"); n.addEventListener("play", (function () { i.style.display = "none" })), n.addEventListener("pause", (function () { i.style.display = "block" })) }, afterEnter() { }, beforeLeave() { }, afterLeave() { } }; var E_ = (e, t, n) => new Promise(((i, r) => { var s = e => { try { o(n.next(e)) } catch (e) { r(e) } }, a = e => { try { o(n.throw(e)) } catch (e) { r(e) } }, o = e => e.done ? i(e.value) : Promise.resolve(e.value).then(s, a); o((n = n.apply(e, t)).next()) })); window.addEventListener("pageshow", (e => { !0 === e.persisted && location.reload() })), function () { const e = navigator.userAgent.toLowerCase(); window.LIG = { mql: matchMedia("(min-width: 768px)"), mqlTab: matchMedia("(min-width:768px) and (max-width:1023px)"), isBgBlack: !0, isDebug: !1, isTouch: void 0 !== window.ontouchstart && 0 < navigator.maxTouchPoints, isMobile: /android|ipad|ipod|iphone|macintosh/.test(e) && "ontouchend" in document, isIOS: /ipad|ipod|iphone|macintosh/.test(e) && "ontouchend" in document, isAndroid: !1, current_name_space: "", next_name_space: "", headerClose: null, lowerPageMotion: null }, history.scrollRestoration && (history.scrollRestoration = "manual"), window.removeEventFunctions = null, window.pageLoadObjects = null, Ci.registerPlugin(fa, Va, ho), window.LIG.isTouch && /android/i.test(navigator.userAgent) && (window.LIG.isAndroid = !0, fa.normalizeScroll(!0)); const t = new Qv; if (document.querySelector(".js-header").classList.contains("bg-header-white")) t.init(document.querySelector("#bgCanvas"), 16777215), window.LIG.isBgBlack = !1; else { t.init(document.querySelector("#bgCanvas"), 3092271), t.addNoiseBG(); const e = () => { requestAnimationFrame((() => { e() })), t.update() }; e() } window.ThreeHandler = t; const n = document.querySelector(":root"); n.style.setProperty("--w", "calc(100vw/60)"), n.style.setProperty("--wsp", "calc(100vw/25)"), document.body.querySelector(".barba-container").classList.add("js_showContents"), window.LIG.headerClose = ey(), function () { if (Ci.registerPlugin(fa), document.querySelector(".js-lig-motion")) return; let e = null; const t = document.querySelector(".js-header"), n = document.querySelector("#lower-motion-logo"), i = document.querySelector(".js-header-logo"); let r = sessionStorage.getItem("isVisited"); t.style.setProperty("--scrollBar", "0px"), null == r ? (function () { e = Ci.timeline({ scrollTrigger: { id: "headerTrigger", trigger: "#js-header-trigger", start: () => "top top", onEnter: () => { e.play() }, once: !0, markers: !1, invalidateOnRefresh: !0 }, paused: !0 }); const r = t.querySelector(".items-right"), s = n.querySelectorAll(".letter-fade-1"), a = n.querySelectorAll(".letter-fade-2"), o = n.querySelector(".lig-is"), l = n.querySelector(".lig-life"), c = n.querySelector(".lig-good"); if (window.LIG.mql.matches) { const t = 535; e.fromTo(s, { opacity: 1 }, { duration: .3, opacity: 0, ease: "circ.out" }, "0").fromTo(a, { opacity: 1 }, { duration: .3, opacity: 0, ease: "circ.out" }, "-=0.3").fromTo(o, { x: 0 }, { duration: .3, x: t - 362, ease: "circ.out" }, "-=0.3").fromTo(l, { x: 0 }, { duration: .3, x: t, ease: "circ.out" }, "-=0.3").fromTo(c, { x: 0 }, { duration: .3, x: t - 560, ease: "circ.out" }, "-=0.3").set(n, { autoAlpha: 0 }, "-=0").set(i, { opacity: 1 }, "-=0").fromTo(c, { x: 0 }, { duration: .3, x: t - 560, ease: "circ.out" }, "-=0.3") } else { const t = 0; Ci.set(r, { opacity: 0 }), e.fromTo(s, { opacity: 1 }, { duration: .3, opacity: 0, ease: "circ.out" }, "0").fromTo(a, { opacity: 1 }, { duration: .3, opacity: 0, ease: "circ.out" }, "-=0.3").fromTo(o, { x: 0 }, { duration: .3, x: t - 370, ease: "circ.out" }, "-=0.3").fromTo(l, { x: 0 }, { duration: .3, x: t, ease: "circ.out" }, "-=0.3").fromTo(c, { x: 0 }, { duration: .3, x: t - 570, ease: "circ.out" }, "-=0.3").set(n, { autoAlpha: 0 }, "-=0").set(i, { opacity: 1 }, "-=0").fromTo(r, { opacity: 0 }, { duration: .3, opacity: 1, ease: "circ.out" }, "-=0.1") } }(), Ci.set(i, { opacity: 0 }), document.querySelector("#contents_404") && window.addEventListener("load", (() => { e.play() }), { once: !0 }), sessionStorage.setItem("isVisited", "1")) : Ci.set(n, { display: "none" }) }(), function () { let e, t = window.LIG.mql.matches; window.addEventListener("resize", (() => { e || (e = setTimeout((function () { e = 0, window.LIG.mql.matches != t && location.reload() }), 200)) })) }(), function () { const e = document.querySelector("#js-contact-cancel-form"); e && e.addEventListener("click", (function (e) { e.preventDefault(), document.querySelector("#js-contact-form").classList.remove("hidden"), document.querySelector("#js-contact-preview").classList.add("hidden"), document.querySelector("#js-contact-parent") && (document.querySelector("#js-contact-parent").classList.add("md:mt-[88px]", "md:pt-[96px]"), document.querySelector("#js-contact-parent").classList.remove("md:mt-[91px]", "md:pt-[92px]")), document.querySelector("#js-contact-inquiries") && (document.querySelector("#js-contact-inquiries").style.display = null), document.querySelector("#js-contact-feelfree") && (document.querySelector("#js-contact-feelfree").innerText = "料金や納期など、まずは気軽にお問い合わせください。<br>フォームを送信いただけましたら、担当より折り返しご連絡いたします。"), document.querySelector("#js-contact-text-etc") && (document.querySelector("#js-contact-text-etc").innerText = "弊社にご関心をお持ちいただきまして、ありがとうございます。当社に関することなど、お気軽にお問合わせください。お問合せ内容の確認後、担当者よりご連絡させていただきます。各項目を入力していただき、入力が終わりましたら入力内容の確認ボタンを押してください。"), document.querySelector("#js-contact-text-collect") && (document.querySelector("#js-contact-text-collect").innerText = "弊社にご関心をお持ちいただきまして、ありがとうございます。LIGおよびLIGに所属する個人への取材依頼はこちらのフォームよりお問い合わせください。お問合せ内容の確認後、担当者よりご連絡させていただきます。各項目を入力していただき、入力が終わりましたら入力内容の確認ボタンを押してください。"), document.querySelector("#js-contact-notice") && (document.querySelector("#js-contact-notice").style.display = null), window.scrollTo({ top: 0 }) })); const t = document.querySelector("#js-contact-submit-form"); t && t.addEventListener("click", (function (e) { e.preventDefault(), document.querySelector(".hbspt-form form").submit() }), { once: !0 }) }(); const i = document.body.dataset.imgUri; if (i && [i + "lig_logo_white_sprite.png", i + "lig_logo_black_sprite.png"].forEach((e => { (new Image).src = e })), -1 != e.indexOf("safari")) { const t = e.indexOf("version"), n = e.indexOf(" ", t), i = e.substring(t + 8, n); Math.floor(parseInt(i)) < 15 && Ci.set(".logo-link", { width: "58px" }) } }(), t().use(r()), t().hooks.beforeEnter(ux.beforeEnter), t().hooks.afterEnter(ux.afterEnter), t().hooks.beforeLeave(ux.beforeLeave), t().hooks.leave(ux.leave), t().hooks.afterLeave(ux.afterLeave), t().init({ prevent: function (e) { const t = e.el, n = e.href; let i = location.protocol + "//" + location.host; if (!n.startsWith(i)) return t.setAttribute("target", "_blank"), !0; const r = n.replace(i, ""); if (r.match(/^\/contact\/(.*)/)) return !0; if (r.match(/^\/[0-9]+/)) return !0; let s = location.protocol + "//" + location.host + location.pathname, a = n.replace(/#.*$/, ""); return !(n.startsWith(location.protocol + "//" + location.host) && n.indexOf("#") > -1 && a != s) && (/\.(xlsx?|docx?|pptx?|pdf|jpe?g|png|gif|svg)/.test(n.toLowerCase()) ? (t.setAttribute("target", "_blank"), !0) : !!t.classList.contains("ab-item") || !!t.classList.contains("js-no-barba") || void 0) }, views: [px, mx, xx, _x, wx, Sx, x_, Ex, Tx, Dx, __, w_, Lx, y_, b_, S_], timeout: 6e3, transitions: [{ name: "transition-animation", leave(e) { return E_(this, null, (function* () { const t = this.async(); let n; const i = function () { "" !== e.next.namespace ? (cancelAnimationFrame(n), ((e, t) => { console.log("%cstartTransition", "font-weight: bold;color:blue;"), console.log("current page - " + e.current.namespace), console.log("next page - " + e.next.namespace); const n = document.body.classList.contains("in-menu"), i = document.querySelector(".barba-container"), r = n ? 0 : .4, s = document.querySelector(".js-header"), a = document.documentElement; switch (e.current.namespace) { case "front_page": case "solutions_child_page": case "culture_page": ThreeHandler.removeTopMovie(r, "circ.out", (() => { console.log("webGL remove Movie") })); break; case "solutions_page": ThreeHandler.removeSolution(r, "circ.out", (() => { console.log("webGL remove solution") })); break; case "404_page": ThreeHandler.remove404(r, "circ.out", (() => { console.log("webGL remove 404") })) }switch (e.next.namespace) { case "blog_single_page": case "blog_archive_page": a.classList.remove("html-bg-black"), a.classList.add("html-bg-white"), s.classList.add("bg-header-white"), s.classList.remove("bg-header-gradient"), window.LIG.isBgBlack && (window.LIG.isBgBlack = !1, ThreeHandler.removeNoiseToWhite(.4, "circ.out", (() => { console.log("noise white") }))); break; default: a.classList.remove("html-bg-white"), a.classList.add("html-bg-black"), s.classList.remove("bg-header-white"), s.classList.add("bg-header-gradient"), window.LIG.isBgBlack || (window.LIG.isBgBlack = !0, ThreeHandler.addNoiseToBlack(.4, "circ.out", (() => { console.log("noise white") }))) }if ("front_page" === e.next.namespace && !sessionStorage.getItem("isTop")) { const e = document.querySelector(".js-header-logo"); Ci.to([e], { duration: .4, opacity: 0 }), document.querySelector(".js-header").classList.add("isTop") } if (i.classList.add("js_transitionOut"), n) if ("solutions_child_page" !== e.next.namespace) Ci.set(i, { display: "none" }), window.LIG.headerClose(.4, (function () { t() })); else { const n = ty(), r = document.querySelector(".js-transition-cover"), s = e.next.container.querySelector(".js-solution-child-content").getAttribute("data-solution-color"); Ci.set(r, { visibility: "visible" }), r.classList.add("isTransition"), r.classList.add("bg-solution-" + s), n.addEventListener(r, "transitionend", (e => { e.target.classList.contains("js-transition-cover") && (Ci.set(i, { display: "none" }), window.LIG.headerClose(0, (function () { t() })), n.destroy()) })) } else { const n = ty(); if ("solutions_child_page" === e.next.namespace) { const r = document.querySelector(".js-transition-cover"), s = e.next.container.querySelector(".js-solution-child-content").getAttribute("data-solution-color"); Ci.set(r, { visibility: "visible" }), r.classList.add("isTransition", "bg-solution-" + s), n.addEventListener(r, "transitionend", (e => { e.target.classList.contains("js-transition-cover") && (Ci.set(i, { display: "none" }), n.destroy(), t()) })) } else i.classList.remove("js_showContents"), n.addEventListener(i, "transitionend", (e => { e.target.classList.contains("barba-container") && (i.classList.add("hidden"), n.destroy(), t()) })) } })(e, t)) : n = requestAnimationFrame((() => { i() })) }; i() })) }, enter(e) { return E_(this, null, (function* () { const t = this.async(); window.pageLoadObjects.length > 0 ? Promise.all(window.pageLoadObjects).then((() => { ny(e, t) })).catch((() => { location.reload() })) : ny(e, t) })) } }] }), window.LIG.barba = t() })() })();